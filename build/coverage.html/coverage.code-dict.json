{"/home/travis/build/npmtest/node-npmtest-swagger-node-express/test.js":"/* istanbul instrument in package npmtest_swagger_node_express */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/lib.npmtest_swagger_node_express.js":"/* istanbul instrument in package npmtest_swagger_node_express */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_swagger_node_express = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_swagger_node_express = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-swagger-node-express && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_swagger_node_express */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_swagger_node_express\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_swagger_node_express.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_swagger_node_express.rollup.js'] =\n            local.assetsDict['/assets.npmtest_swagger_node_express.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_swagger_node_express.__dirname + '/lib.npmtest_swagger_node_express.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/index.js":"module.exports = require('./lib');\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/lib/index.js":"var params            = require('./paramTypes');\nvar errorHandling     = require('./errorHandling');\nvar swagger           = require('./swagger');\n\nmodule.exports        = swagger;\nmodule.exports.params = params;\nmodule.exports.queryParam    = params.query;\nmodule.exports.pathParam     = params.path;\nmodule.exports.bodyParam     = params.body;\nmodule.exports.formParam     = params.form;\nmodule.exports.headerParam   = params.header;\nmodule.exports.error         = errorHandling.error;\n\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/lib/paramTypes.js":"/**\n *  Copyright 2013 Wordnik, Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n'use strict';\n\n\nexports.query = exports.q = function(name, description, type, required, allowableValuesEnum, defaultValue) {\n  return {\n    'name' : name,\n    'description' : description,\n    'type' : type,\n    'required' : required,\n    'enum' : allowableValuesEnum,\n    'defaultValue' : defaultValue,\n    'paramType' : 'query'\n  };\n};\n\nexports.path = function(name, description, type, allowableValuesEnum, defaultValue) {\n  return {\n    'name' : name,\n    'description' : description,\n    'type' : type,\n    'required' : true,\n    'enum' : allowableValuesEnum,\n    'paramType' : 'path',\n    'defaultValue' : defaultValue\n  };\n};\n\nexports.body = function(name, description, type, defaultValue, required) {\n  return {\n    'name' : name,\n    'description' : description,\n    'type' : type,\n    'required' : required || false,\n    'paramType' : 'body',\n    'defaultValue' : defaultValue\n  };\n};\n\nexports.form = function(name, description, type, required, allowableValuesEnum, defaultValue) {\n  return {\n    'name' : name,\n    'description' : description,\n    'type' : type,\n    'required' : (typeof required !== 'undefined') ? required : true,\n    'enum' : allowableValuesEnum,\n    'paramType' : 'form',\n    'defaultValue' : defaultValue\n  };\n};\n\nexports.header = function(name, description, type, required) {\n  return {\n    'name' : name,\n    'description' : description,\n    'type' : type,\n    'required' : required,\n    'allowMultiple' : false,\n    'paramType' : 'header'\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/lib/errorHandling.js":"'use strict';\n\nexports.error = error;\n\n// TODO can this be removed?\n// Create Error JSON by code and text\nfunction error(code, description) {\n  return {\n    'code'   : code,\n    'message': description\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/lib/swagger.js":"/**\n *  Copyright 2014 Wordnik, Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n'use strict';\n\nvar _ = require('lodash');\nvar allowedMethods = ['get', 'post', 'put', 'patch', 'delete'];\nvar allowedDataTypes = ['string', 'integer', 'boolean', 'array'];\nvar toJsonType = require('./toJsonType');\nvar shallowClone = require('./shallowClone');\nvar resourceHelpers = require('./resourceHelpers');\nvar wrap = resourceHelpers.wrap;\nvar appendToApi = resourceHelpers.appendToApi;\nvar params = require('./paramTypes');\n\n\n// TODO-3.0.0 REMOVE\nvar ignoreAppHandlerInConstructor = true;\n\n// TODO-3.0.0 REMOVE\n// For backwards compatability, we just export a new instance of Swagger\nmodule.exports = exports = new Swagger();\n\nfunction Swagger(appHandler) {\n\n  if (!(this instanceof Swagger)){\n    return new Swagger(appHandler);\n  }\n\n  this.formatString = '.{format}';\n  this.resourcePath = '/api-docs' + this.formatString;\n  this.jsonSuffix = '.json';\n  this.basePath = '/';\n  this.apiInfo = null;\n  this.authorizations = null;\n  this.swaggerVersion = '1.2';\n  this.apiVersion = '1.0';\n  this.allModels = {};\n  this.validators = [];\n  this.appHandler = appHandler || null;\n  this.resources = {};\n  this.paramTypes = params;\n\n  // For backwards compatability\n  this.getModels = this.allModels;\n\n  // TODO-3.0.0 REMOVE\n  ignoreAppHandlerInConstructor = false;\n}\n\n//TODO-3.0.0 REMOVE\n/**\n * returns a new instance of swagger\n */\nSwagger.prototype.createNew = function(appHandler){\n  return new Swagger(appHandler);\n};\n\nSwagger.prototype.configureSwaggerPaths = function(format, path, suffix) {\n  if(path.indexOf('/') !== 0) path = '/' + path;\n  this.formatString = format;\n  this.resourcePath = path;\n  this.jsonSuffix = suffix;\n};\n\n// Configuring swagger will set the basepath and api version for all\n// subdocuments.  It should only be done once, and during bootstrap of the app\n\nSwagger.prototype.configure = function(bp, av) {\n  var self = this;\n  self.basePath = bp;\n  self.apiVersion = av;\n  self.setResourceListingPaths(self.appHandler);\n\n  // add the GET for resource listing\n  var resourceListing = _.bind(self.resourceListing, self);\n  self.appHandler.get(self.resourcePath.replace(self.formatString, self.jsonSuffix), resourceListing);\n\n  // update resources if already configured\n\n  _.forOwn(self.resources, function (resource) {\n    resource.apiVersion = av;\n    resource.basePath = bp;\n  });\n};\n\n// Convenience to set default headers in each response.\n\nSwagger.prototype.setHeaders = function(res) {\n  res.header('Access-Control-Allow-Headers', 'Content-Type, api_key');\n  res.header('Content-Type', 'application/json; charset=utf-8');\n};\n\n// creates declarations for each resource path.\n\nSwagger.prototype.setResourceListingPaths = function(app) {\n  var self = this;\n  _.forOwn(this.resources, function (resource, key) {\n\n    // pet.json => api-docs.json/pet\n    var path = self.baseApiFromPath(key);\n    app.get(path, function (req, res) {\n      // find the api base path from the request URL\n      // /api-docs.json/pet => /pet.json\n\n      var p = self.basePathFromApi(req.url.split('?')[0]);\n\n      // this handles the request\n      // api-docs.json/pet => pet.{format}\n      var r = self.resources[p] || self.resources[p.replace(self.formatString, '')];\n      if (!r) {\n        console.error('unable to find listing');\n        return self.stopWithError(res, {\n          'message': 'internal error',\n          'code': 500\n        });\n      } else {\n        self.setHeaders(res);\n        var data = self.filterApiListing(req, res, r);\n        data.basePath = self.basePath;\n        if (data.code) {\n          res.send(data, data.code);\n        } else {\n          res.send(JSON.stringify(data));\n        }\n      }\n    });\n  });\n};\n\nSwagger.prototype.basePathFromApi = function(path) {\n  var l = this.resourcePath.replace(this.formatString, this.jsonSuffix);\n  var p = path.substring(l.length + 1) + this.formatString;\n  return p;\n};\n\nSwagger.prototype.baseApiFromPath = function(path) {\n  var p = this.resourcePath.replace(this.formatString, this.jsonSuffix) + '/' + path.replace(this.formatString, '');\n  return p;\n};\n\nSwagger.prototype.addPropertiesToRequiredModels = function(properties, requiredModels) {\n  var self = this;\n  _.forOwn(properties, function (property) {\n    var type = property.type;\n    if(type) {\n      switch (type) {\n      case 'array':\n        if (property.items) {\n          var ref = property.items.$ref;\n          if (ref && requiredModels.indexOf(ref) < 0) {\n            requiredModels.push(ref);\n            self.addPropertiesToRequiredModels(self.allModels[ref].properties, requiredModels);\n          }\n        }\n        break;\n      case 'string':\n      case 'integer':\n        break;\n      default:\n        if (requiredModels.indexOf(type) < 0) {\n          requiredModels.push(type);\n        }\n        break;\n      }\n    }\n    else {\n      if (property.$ref){\n        requiredModels.push(property.$ref);\n        self.addPropertiesToRequiredModels(self.allModels[property.$ref].properties, requiredModels);\n      }\n    }\n    if (property.properties) {\n      self.addPropertiesToRequiredModels(property.properties, requiredModels);\n    }\n  });\n};\n\n// Applies a filter to an api listing.  When done, the api listing will only contain\n// methods and models that the user actually has access to.\n\nSwagger.prototype.filterApiListing = function(req, res, r) {\n  var self = this;\n  var excludedPaths = [];\n\n  if (!r || !r.apis) {\n    return self.stopWithError(res, {\n      'message': 'internal error',\n      'code': 500\n    });\n  }\n\n  _.forOwn(r.apis, function (api) {\n    for (var opKey in api.operations) {\n      if (!api.operations.hasOwnProperty(opKey)) {\n        continue;\n      }\n      var op = api.operations[opKey];\n      var path = api.path.replace(self.formatString, '').replace(/{.*\\}/, '*');\n      if (!self.canAccessResource(req, path, op.method)) {\n        excludedPaths.push(op.method + ':' + api.path);\n      }\n    }\n  });\n\n  //  clone attributes in the resource\n  var output = shallowClone(r);\n\n  // clone arrays for\n  if(r.produces) output.produces = r.produces.slice(0);\n  if(r.consumes) output.consumes = r.consumes.slice(0);\n  if(r.authorizations) output.authorizations = r.authorizations.slice(0);\n  if(r.protocols) output.protocols = r.protocols.slice(0);\n\n  //  models required in the api listing\n  var requiredModels = [];\n\n  //  clone methods that user can access\n  output.apis = [];\n  var apis = JSON.parse(JSON.stringify(r.apis));\n  _.forOwn(apis, function (api) {\n    var clonedApi = shallowClone(api);\n\n    clonedApi.operations = [];\n    _.forOwn(api.operations, function (operation) {\n      if (excludedPaths.indexOf(operation.method + ':' + api.path) === -1) {\n        var co = JSON.parse(JSON.stringify(operation));\n        delete co.path;\n\n        var type = toJsonType(co.type);\n        if(type) {\n          for(var nm in type) {\n            delete co[nm];\n            co[nm] = type[nm];\n          }\n        }\n        clonedApi.operations.push(co);\n        self.addModelsFromBody(operation, requiredModels);\n        self.addModelsFromResponse(operation, requiredModels);\n      }\n    });\n    //  only add cloned api if there are operations\n    if (clonedApi.operations.length > 0) {\n      output.apis.push(clonedApi);\n    }\n  });\n\n  // add required models to output\n  output.models = {};\n  _.forOwn(requiredModels, function (modelName) {\n    var model = self.allModels[modelName];\n    if (model) {\n      output.models[modelName] = model;\n    }\n  });\n\n  //  look in object graph\n  _.forOwn(output.models, function (model) {\n    if (model && model.properties) {\n      self.addPropertiesToRequiredModels(model.properties, requiredModels);\n    }\n  });\n  _.forOwn(requiredModels, function (modelName) {\n    if (!output[modelName]) {\n      var model = self.allModels[modelName];\n      if (model) {\n        output.models[modelName] = model;\n      }\n    }\n  });\n\n  return output;\n};\n\n\n\n// Add model to list and parse List[model] elements\n\nSwagger.prototype.addModelsFromBody = function(operation, models) {\n  var self = this;\n  if (operation.parameters) {\n    _.forOwn(operation.parameters, function (param) {\n      if (param.paramType === 'body' && param.type) {\n        var model = param.type.replace(/^List\\[/, '').replace(/\\]/, '');\n        models.push(model);\n      }\n    });\n  }\n};\n\n// Add model to list and parse List[model] elements\n\nSwagger.prototype.addModelsFromResponse = function(operation, models) {\n  var responseModel = operation.type;\n  if(responseModel === 'array' && operation.items) {\n    var items = operation.items;\n    if(items.$ref) {\n      models.push(items.$ref);\n    } else if (items.type && allowedDataTypes.indexOf(items.type) === -1) {\n      models.push(items.type);\n    }\n  }\n  // if not void or a json-schema type, add the model\n  else if (responseModel !== 'void' && allowedDataTypes.indexOf(responseModel) === -1) {\n    models.push(responseModel);\n  }\n};\n\n\n// function for filtering a resource.  override this with your own implementation.\n// if consumer can access the resource, method returns true.\n\nSwagger.prototype.canAccessResource = function(req, path, method) {\n  for (var i = 0; i < this.validators.length; i++) {\n    var validator = this.validators[i];\n    if (_.isFunction(validator) && !validator(req, path, method)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * returns the json representation of a resource\n *\n * @param request\n * @param response\n */\n\nSwagger.prototype.resourceListing = function(req, res) {\n  var self = this;\n  var r = {\n    'apiVersion': self.apiVersion,\n    'swaggerVersion': self.swaggerVersion,\n    'apis': []\n  };\n\n  if(self.authorizations)\n    r.authorizations = self.authorizations;\n\n  if(self.apiInfo)\n    r.info = self.apiInfo;\n\n  _.forOwn(self.resources, function (value, key) {\n    var p = '/' + key.replace(self.formatString, '');\n    r.apis.push({\n      'path': p,\n      'description': value.description\n    });\n  });\n  self.setHeaders(res);\n  res.write(JSON.stringify(r));\n  res.end();\n};\n\n// Adds a method to the api along with a spec.  If the spec fails to validate, it won't be added\n\nSwagger.prototype.addMethod = function(app, callback, spec) {\n  var self = this;\n  var apiRootPath = spec.path.split(/[\\/\\(]/)[1];\n  var root = self.resources[apiRootPath];\n\n  if (root && root.apis) {\n    // this path already exists in swagger resources\n    _.forOwn(root.apis, function (api) {\n      if (api && api.path === spec.path && api.method === spec.method) {\n        // add operation & return\n        appendToApi(root, api, spec);\n        return;\n      }\n    });\n  }\n\n  var api = {\n    'path': spec.path\n  };\n  if (!self.resources[apiRootPath]) {\n    if (!root) {\n      //\n      var resourcePath = '/' + apiRootPath.replace(self.formatString, '');\n      root = {\n        'apiVersion': self.apiVersion,\n        'swaggerVersion': self.swaggerVersion,\n        'basePath': self.basePath,\n        'resourcePath': resourcePath,\n        'apis': [],\n        'models': []\n      };\n    }\n    self.resources[apiRootPath] = root;\n  }\n\n  root.apis.push(api);\n  appendToApi(root, api, spec);\n\n  //  convert .{format} to .json, make path params happy\n  var fullPath = spec.path.replace(self.formatString, self.jsonSuffix).replace(/\\/{/g, '/:').replace(/\\}/g, '');\n  var currentMethod = spec.method.toLowerCase();\n  if (allowedMethods.indexOf(currentMethod) > -1) {\n    app[currentMethod](fullPath, function (req, res, next) {\n      self.setHeaders(res);\n\n      // todo: needs to do smarter matching against the defined paths\n      var path = req.url.split('?')[0].replace(self.jsonSuffix, '').replace(/{.*\\}/, '*');\n      if (!self.canAccessResource(req, path, req.method)) {\n        res.send(JSON.stringify({\n          'message': 'forbidden',\n          'code': 403\n        }), 403);\n      } else {\n        callback(req, res, next);\n      }\n    });\n  } else {\n    console.error('unable to add ' + currentMethod.toUpperCase() + ' handler');\n    return;\n  }\n};\n\n// Set expressjs app handler\n\n// TODO-3.0.0 REMOVE\nSwagger.prototype.setAppHandler = function(app) {\n  if (!ignoreAppHandlerInConstructor) {\n    console.warn('setAppHandler is deprecated!  Pass it to the constructor instead.');\n  }\n  this.appHandler = app;\n};\n\n// Add swagger handlers to express\n\nSwagger.prototype.addHandlers = function(type, handlers) {\n  var self = this;\n  _.forOwn(handlers, function (handler) {\n    handler.spec.method = type;\n    self.addMethod(self.appHandler, handler.action, handler.spec);\n  });\n};\n\n// Discover swagger handler from resource\n\nSwagger.prototype.discover = function(resource) {\n  var self = this;\n  _.forOwn(resource, function (handler, key) {\n    if (handler.spec && handler.spec.method && allowedMethods.indexOf(handler.spec.method.toLowerCase()) > -1) {\n      self.addMethod(self.appHandler, handler.action, handler.spec);\n    } else\n      console.error('auto discover failed for: ' + key);\n  });\n};\n\n// Discover swagger handler from resource file path\n\nSwagger.prototype.setErrorHandler= function(handler) {\n  console.warn(\n    '.setErrorHandler() has been deprecated and is no longer used!  '\n    + 'You should use middleware with your express app instead.'\n  );\n};\n\nSwagger.prototype.discoverFile = function(file) {\n  return this.discover(require(file));\n};\n\n// adds get handler\n\nSwagger.prototype.addGet = Swagger.prototype.addGET = function() {\n  this.addHandlers('GET', arguments);\n  return this;\n};\n\n// adds post handler\n\nSwagger.prototype.addPost = Swagger.prototype.addPOST = function() {\n  this.addHandlers('POST', arguments);\n  return this;\n};\n\n// adds delete handler\n\nSwagger.prototype.addDelete = Swagger.prototype.addDELETE = function() {\n  this.addHandlers('DELETE', arguments);\n  return this;\n};\n\n// adds put handler\n\nSwagger.prototype.addPut = Swagger.prototype.addPUT = function() {\n  this.addHandlers('PUT', arguments);\n  return this;\n};\n\n// adds patch handler\n\nSwagger.prototype.addPatch = Swagger.prototype.addPATCH = function() {\n  this.addHandlers('PATCH', arguments);\n  return this;\n};\n\n// adds models to swagger\n\nSwagger.prototype.addModels = function(models) {\n  models = _.cloneDeep(models).models;\n  var self = this;\n  if (!self.allModels) {\n    self.allModels = models;\n  } else {\n    _.forOwn(models, function (model, key) {\n      self.allModels[key] = model;\n    });\n  }\n  return this;\n};\n\nSwagger.prototype.addValidator = function(v) {\n  this.validators.push(v);\n};\n\n// Stop express ressource with error code\nSwagger.prototype.stopWithError = function(res, error) {\n  this.setHeaders(res);\n  if (error && error.message && error.code)\n    console.log(JSON.stringify(error));\n\n  res.send(JSON.stringify({\n    'message': 'internal error',\n    'code': 500\n  }), 500);\n};\n\nSwagger.prototype.setApiInfo = function(data) {\n  this.apiInfo = data;\n};\n\nSwagger.prototype.setAuthorizations = function(data) {\n  this.authorizations = data;\n};\n\n// Export most needed error types for easier handling\nSwagger.prototype.errors = {\n  'notFound': function (field, res) {\n    if (!res) {\n      return {\n        'code': 404,\n        'message': field + ' not found'\n      };\n    } else {\n      res.send({\n        'code': 404,\n        'message': field + ' not found'\n      }, 404);\n    }\n  },\n  'invalid': function (field, res) {\n    if (!res) {\n      return {\n        'code': 400,\n        'message': 'invalid ' + field\n      };\n    } else {\n      res.send({\n        'code': 400,\n        'message': 'invalid ' + field\n      }, 404);\n    }\n  },\n  'forbidden': function (res) {\n    if (!res) {\n      return {\n        'code': 403,\n        'message': 'forbidden'\n      };\n    } else {\n      res.send({\n        'code': 403,\n        'message': 'forbidden'\n      }, 403);\n    }\n  }\n};\n\nSwagger.prototype.configureDeclaration = function(resourceName, obj) {\n  if(this.resources[resourceName]) {\n    var resource = this.resources[resourceName];\n\n    if(obj.description) {\n      resource.description = obj.description;\n    }\n    if(obj.consumes) {\n      resource.consumes = obj.consumes;\n    }\n    if(obj.produces) {\n      resource.produces = obj.produces;\n    }\n    if(obj.protocols) {\n      resource.protocols = obj.protocols;\n    }\n    if(obj.authorizations) {\n      resource.authorizations = obj.authorizations;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/lib/toJsonType.js":"'use strict';\n\nmodule.exports = toJsonType;\n\nvar mappings = {\n  'int': {\n    type: 'integer',\n    format: 'int32'\n  },\n  'long': {\n    type: 'integer',\n    format: 'int64'\n  },\n  'float': {\n    type: 'number',\n    format: 'float'\n  },\n  'double': {\n    type: 'number',\n    format: 'double'\n  },\n  'date': {\n    type: 'string',\n    format: 'date-time'\n  }\n};\n\nfunction toJsonType(model) {\n  if(model && mappings[model]) {\n    return mappings[model];\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/lib/shallowClone.js":"'use strict';\n\nmodule.exports = shallowClone;\n\n// clone anything but objects to avoid shared references\nfunction shallowClone(obj) {\n  var cloned = {};\n  for (var i in obj) {\n    if (!obj.hasOwnProperty(i)) {\n      continue;\n    }\n    if (typeof (obj[i]) !== 'object') {\n      cloned[i] = obj[i];\n    }\n  }\n  return cloned;\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/lib/resourceHelpers.js":"'use strict';\n\nvar _ = require('lodash');\n\nmodule.exports.wrap = wrap;\nmodule.exports.appendToApi = appendToApi;\n\nfunction wrap(callback, req, resp) {\n  callback(req, resp);\n}\n\n// appends a spec to an existing operation\n\nfunction appendToApi(rootResource, api, spec) {\n  var validationErrors = [];\n\n  if (!spec.nickname || spec.nickname.indexOf(' ') >= 0) {\n    //  nicknames don't allow spaces\n    validationErrors.push({\n      'path': api.path,\n      'error': 'invalid nickname \"' + spec.nickname + '\"'\n    });\n  }\n  // validate params\n  _.forOwn(spec.parameters, function (parameter) {\n\n    switch (parameter.paramType) {\n    case 'path':\n      if (api.path.indexOf('{' + parameter.name + '}') < 0) {\n        validationErrors.push({\n          'path': api.path,\n          'name': parameter.name,\n          'error': 'invalid path'\n        });\n      }\n      break;\n    case 'query':\n      break;\n    case 'body':\n      break;\n    case 'form':\n      break;\n    case 'header':\n      break;\n    default:\n      validationErrors.push({\n        'path': api.path,\n        'name': parameter.name,\n        'error': 'invalid param type ' + parameter.paramType\n      });\n      break;\n    }\n  });\n\n  if (validationErrors.length > 0) {\n    console.error(validationErrors);\n    return;\n  }\n\n  if (!api.operations) {\n    api.operations = [];\n  }\n\n  // TODO: replace if existing HTTP operation in same api path\n  var op = {\n    'parameters': spec.parameters,\n    'method': spec.method,\n    'notes': spec.notes,\n    'responseMessages': spec.responseMessages,\n    'nickname': spec.nickname,\n    'summary': spec.summary,\n    'consumes' : spec.consumes,\n    'produces' : spec.produces\n  };\n\n  // Add custom fields.\n  op = _.extend({}, spec, op);\n\n  if (!spec.type) {\n    op.type = 'void';\n  }\n  api.operations.push(op);\n\n  if (!rootResource.models) {\n    rootResource.models = {};\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/swagger-ui/swagger-ui.js":"// swagger-ui.js\n// version 2.1.0-alpha.3\n$(function() {\r\n\r\n\t// Helper function for vertically aligning DOM elements\r\n\t// http://www.seodenver.com/simple-vertical-align-plugin-for-jquery/\r\n\t$.fn.vAlign = function() {\r\n\t\treturn this.each(function(i){\r\n\t\tvar ah = $(this).height();\r\n\t\tvar ph = $(this).parent().height();\r\n\t\tvar mh = (ph - ah) / 2;\r\n\t\t$(this).css('margin-top', mh);\r\n\t\t});\r\n\t};\r\n\r\n\t$.fn.stretchFormtasticInputWidthToParent = function() {\r\n\t\treturn this.each(function(i){\r\n\t\tvar p_width = $(this).closest(\"form\").innerWidth();\r\n\t\tvar p_padding = parseInt($(this).closest(\"form\").css('padding-left') ,10) + parseInt($(this).closest(\"form\").css('padding-right'), 10);\r\n\t\tvar this_padding = parseInt($(this).css('padding-left'), 10) + parseInt($(this).css('padding-right'), 10);\r\n\t\t$(this).css('width', p_width - p_padding - this_padding);\r\n\t\t});\r\n\t};\r\n\r\n\t$('form.formtastic li.string input, form.formtastic textarea').stretchFormtasticInputWidthToParent();\r\n\r\n\t// Vertically center these paragraphs\r\n\t// Parent may need a min-height for this to work..\r\n\t$('ul.downplayed li div.content p').vAlign();\r\n\r\n\t// When a sandbox form is submitted..\r\n\t$(\"form.sandbox\").submit(function(){\r\n\r\n\t\tvar error_free = true;\r\n\r\n\t\t// Cycle through the forms required inputs\r\n \t\t$(this).find(\"input.required\").each(function() {\r\n\r\n\t\t\t// Remove any existing error styles from the input\r\n\t\t\t$(this).removeClass('error');\r\n\r\n\t\t\t// Tack the error style on if the input is empty..\r\n\t\t\tif ($(this).val() == '') {\r\n\t\t\t\t$(this).addClass('error');\r\n\t\t\t\t$(this).wiggle();\r\n\t\t\t\terror_free = false;\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\treturn error_free;\r\n\t});\r\n\r\n});\r\n\r\nfunction clippyCopiedCallback(a) {\r\n  $('#api_key_copied').fadeIn().delay(1000).fadeOut();\r\n\r\n  // var b = $(\"#clippy_tooltip_\" + a);\r\n  // b.length != 0 && (b.attr(\"title\", \"copied!\").trigger(\"tipsy.reload\"), setTimeout(function() {\r\n  //   b.attr(\"title\", \"copy to clipboard\")\r\n  // },\r\n  // 500))\r\n}\r\n\r\n// Logging function that accounts for browsers that don't have window.console\r\nlog = function(){\r\n  log.history = log.history || [];\r\n  log.history.push(arguments);\r\n  if(this.console){\r\n    console.log( Array.prototype.slice.call(arguments)[0] );\r\n  }\r\n};\r\n\r\n// Handle browsers that do console incorrectly (IE9 and below, see http://stackoverflow.com/a/5539378/7913)\r\nif (Function.prototype.bind && console && typeof console.log == \"object\") {\r\n    [\r\n      \"log\",\"info\",\"warn\",\"error\",\"assert\",\"dir\",\"clear\",\"profile\",\"profileEnd\"\r\n    ].forEach(function (method) {\r\n        console[method] = this.bind(console[method], console);\r\n    }, Function.prototype.call);\r\n}\r\n\r\nvar Docs = {\r\n\r\n\tshebang: function() {\r\n\r\n\t\t// If shebang has an operation nickname in it..\r\n\t\t// e.g. /docs/#!/words/get_search\r\n\t\tvar fragments = $.param.fragment().split('/');\r\n\t\tfragments.shift(); // get rid of the bang\r\n\r\n\t\tswitch (fragments.length) {\r\n\t\t\tcase 1:\r\n\t\t\t\t// Expand all operations for the resource and scroll to it\r\n\t\t\t\tvar dom_id = 'resource_' + fragments[0];\r\n\r\n\t\t\t\tDocs.expandEndpointListForResource(fragments[0]);\r\n\t\t\t\t$(\"#\"+dom_id).slideto({highlight: false});\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\t// Refer to the endpoint DOM element, e.g. #words_get_search\r\n\r\n        // Expand Resource\r\n        Docs.expandEndpointListForResource(fragments[0]);\r\n        $(\"#\"+dom_id).slideto({highlight: false});\r\n\r\n        // Expand operation\r\n\t\t\t\tvar li_dom_id = fragments.join('_');\r\n\t\t\t\tvar li_content_dom_id = li_dom_id + \"_content\";\r\n\r\n\r\n\t\t\t\tDocs.expandOperation($('#'+li_content_dom_id));\r\n\t\t\t\t$('#'+li_dom_id).slideto({highlight: false});\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoggleEndpointListForResource: function(resource) {\r\n\t\tvar elem = $('li#resource_' + Docs.escapeResourceName(resource) + ' ul.endpoints');\r\n\t\tif (elem.is(':visible')) {\r\n\t\t\tDocs.collapseEndpointListForResource(resource);\r\n\t\t} else {\r\n\t\t\tDocs.expandEndpointListForResource(resource);\r\n\t\t}\r\n\t},\r\n\r\n\t// Expand resource\r\n\texpandEndpointListForResource: function(resource) {\r\n\t\tvar resource = Docs.escapeResourceName(resource);\r\n\t\tif (resource == '') {\r\n\t\t\t$('.resource ul.endpoints').slideDown();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t$('li#resource_' + resource).addClass('active');\r\n\r\n\t\tvar elem = $('li#resource_' + resource + ' ul.endpoints');\r\n\t\telem.slideDown();\r\n\t},\r\n\r\n\t// Collapse resource and mark as explicitly closed\r\n\tcollapseEndpointListForResource: function(resource) {\r\n\t\tvar resource = Docs.escapeResourceName(resource);\r\n\t\t$('li#resource_' + resource).removeClass('active');\r\n\r\n\t\tvar elem = $('li#resource_' + resource + ' ul.endpoints');\r\n\t\telem.slideUp();\r\n\t},\r\n\r\n\texpandOperationsForResource: function(resource) {\r\n\t\t// Make sure the resource container is open..\r\n\t\tDocs.expandEndpointListForResource(resource);\r\n\t\t\r\n\t\tif (resource == '') {\r\n\t\t\t$('.resource ul.endpoints li.operation div.content').slideDown();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t$('li#resource_' + Docs.escapeResourceName(resource) + ' li.operation div.content').each(function() {\r\n\t\t\tDocs.expandOperation($(this));\r\n\t\t});\r\n\t},\r\n\r\n\tcollapseOperationsForResource: function(resource) {\r\n\t\t// Make sure the resource container is open..\r\n\t\tDocs.expandEndpointListForResource(resource);\r\n\r\n\t\t$('li#resource_' + Docs.escapeResourceName(resource) + ' li.operation div.content').each(function() {\r\n\t\t\tDocs.collapseOperation($(this));\r\n\t\t});\r\n\t},\r\n\r\n\tescapeResourceName: function(resource) {\r\n\t\treturn resource.replace(/[!\"#$%&'()*+,.\\/:;<=>?@\\[\\\\\\]\\^`{|}~]/g, \"\\\\$&\");\r\n\t},\r\n\r\n\texpandOperation: function(elem) {\r\n\t\telem.slideDown();\r\n\t},\r\n\r\n\tcollapseOperation: function(elem) {\r\n\t\telem.slideUp();\r\n\t}\r\n};(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['apikey_button_view'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", escapeExpression=this.escapeExpression;\n\n\n  buffer += \"<div class='auth_button' id='apikey_button'><img class='auth_icon' alt='apply api key' src='images/apikey.jpeg'></div>\\n<div class='auth_container' id='apikey_container'>\\n  <div class='key_input_container'>\\n    <div class='auth_label'>\";\n  if (stack1 = helpers.keyName) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.keyName; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</div>\\n    <input placeholder=\\\"api_key\\\" class=\\\"auth_input\\\" id=\\\"input_apiKey_entry\\\" name=\\\"apiKey\\\" type=\\\"text\\\"/>\\n    <div class='auth_submit'><a class='auth_submit_button' id=\\\"apply_api_key\\\" href=\\\"#\\\">apply</a></div>\\n  </div>\\n</div>\\n\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['basic_auth_button_view'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  \n\n\n  return \"<div class='auth_button' id='basic_auth_button'><img class='auth_icon' src='images/password.jpeg'></div>\\n<div class='auth_container' id='basic_auth_container'>\\n  <div class='key_input_container'>\\n    <div class=\\\"auth_label\\\">Username</div>\\n    <input placeholder=\\\"username\\\" class=\\\"auth_input\\\" id=\\\"input_username\\\" name=\\\"username\\\" type=\\\"text\\\"/>\\n    <div class=\\\"auth_label\\\">Password</div>\\n    <input placeholder=\\\"password\\\" class=\\\"auth_input\\\" id=\\\"input_password\\\" name=\\\"password\\\" type=\\\"password\\\"/>\\n    <div class='auth_submit'><a class='auth_submit_button' id=\\\"apply_basic_auth\\\" href=\\\"#\\\">apply</a></div>\\n  </div>\\n</div>\\n\\n\";\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['content_type'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", self=this;\n\nfunction program1(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n  \";\n  stack1 = helpers.each.call(depth0, depth0.produces, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\";\n  return buffer;\n  }\nfunction program2(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t<option value=\\\"\";\n  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\\">\";\n  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</option>\\n\t\";\n  return buffer;\n  }\n\nfunction program4(depth0,data) {\n  \n  \n  return \"\\n  <option value=\\\"application/json\\\">application/json</option>\\n\";\n  }\n\n  buffer += \"<label for=\\\"contentType\\\"></label>\\n<select name=\\\"contentType\\\">\\n\";\n  stack1 = helpers['if'].call(depth0, depth0.produces, {hash:{},inverse:self.program(4, program4, data),fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n</select>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['main'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, stack2, functionType=\"function\", escapeExpression=this.escapeExpression, self=this;\n\nfunction program1(depth0,data) {\n  \n  var buffer = \"\", stack1, stack2;\n  buffer += \"\\n  <div class=\\\"info_title\\\">\"\n    + escapeExpression(((stack1 = ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.title)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + \"</div>\\n  <div class=\\\"info_description\\\">\";\n  stack2 = ((stack1 = ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.description)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"</div>\\n  \";\n  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.termsOfServiceUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"\\n  \";\n  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.contact), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"\\n  \";\n  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.license), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"\\n  \";\n  return buffer;\n  }\nfunction program2(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"<div class=\\\"info_tos\\\"><a href=\\\"\"\n    + escapeExpression(((stack1 = ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.termsOfServiceUrl)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + \"\\\">Terms of service</a></div>\";\n  return buffer;\n  }\n\nfunction program4(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"<div class='info_contact'><a href=\\\"mailto:\"\n    + escapeExpression(((stack1 = ((stack1 = ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.contact)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + \"\\\">Contact the developer</a></div>\";\n  return buffer;\n  }\n\nfunction program6(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"<div class='info_license'><a href='\"\n    + escapeExpression(((stack1 = ((stack1 = ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.license)),stack1 == null || stack1 === false ? stack1 : stack1.url)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + \"'>\"\n    + escapeExpression(((stack1 = ((stack1 = ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.license)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + \"</a></div>\";\n  return buffer;\n  }\n\nfunction program8(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n    , <span style=\\\"font-variant: small-caps\\\">api version</span>: \"\n    + escapeExpression(((stack1 = ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.version)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + \"\\n    \";\n  return buffer;\n  }\n\nfunction program10(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n    <span style=\\\"float:right\\\"><a href=\\\"\";\n  if (stack1 = helpers.validatorUrl) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.validatorUrl; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"/debug?url=\";\n  if (stack1 = helpers.url) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.url; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"\\\"><img id=\\\"validator\\\" src=\\\"\";\n  if (stack1 = helpers.validatorUrl) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.validatorUrl; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"?url=\";\n  if (stack1 = helpers.url) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.url; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"\\\"></a>\\n    </span>\\n    \";\n  return buffer;\n  }\n\n  buffer += \"<div class='info' id='api_info'>\\n  \";\n  stack1 = helpers['if'].call(depth0, depth0.info, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n</div>\\n<div class='container' id='resources_container'>\\n  <ul id='resources'></ul>\\n\\n  <div class=\\\"footer\\\">\\n    <br>\\n    <br>\\n    <h4 style=\\\"color: #999\\\">[ <span style=\\\"font-variant: small-caps\\\">base url</span>: \";\n  if (stack1 = helpers.basePath) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.basePath; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"\\n    \";\n  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.info),stack1 == null || stack1 === false ? stack1 : stack1.version), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"]\\n    \";\n  stack2 = helpers['if'].call(depth0, depth0.validatorUrl, {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"\\n    </h4>\\n    </div>\\n</div>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['operation'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, options, functionType=\"function\", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;\n\nfunction program1(depth0,data) {\n  \n  \n  return \"deprecated\";\n  }\n\nfunction program3(depth0,data) {\n  \n  \n  return \"\\n            <h4>Warning: Deprecated</h4>\\n        \";\n  }\n\nfunction program5(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n        <h4>Implementation Notes</h4>\\n        <p>\";\n  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</p>\\n        \";\n  return buffer;\n  }\n\nfunction program7(depth0,data) {\n  \n  \n  return \"\\n        <div class=\\\"auth\\\">\\n        <span class=\\\"api-ic ic-error\\\"></span>\";\n  }\n\nfunction program9(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n          <div id=\\\"api_information_panel\\\" style=\\\"top: 526px; left: 776px; display: none;\\\">\\n          \";\n  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n          </div>\\n        \";\n  return buffer;\n  }\nfunction program10(depth0,data) {\n  \n  var buffer = \"\", stack1, stack2;\n  buffer += \"\\n            <div title='\";\n  stack2 = ((stack1 = depth0.description),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"'>\"\n    + escapeExpression(((stack1 = depth0.scope),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + \"</div>\\n          \";\n  return buffer;\n  }\n\nfunction program12(depth0,data) {\n  \n  \n  return \"</div>\";\n  }\n\nfunction program14(depth0,data) {\n  \n  \n  return \"\\n        <div class='access'>\\n          <span class=\\\"api-ic ic-off\\\" title=\\\"click to authenticate\\\"></span>\\n        </div>\\n        \";\n  }\n\nfunction program16(depth0,data) {\n  \n  \n  return \"\\n          <h4>Response Class</h4>\\n          <p><span class=\\\"model-signature\\\" /></p>\\n          <br/>\\n          <div class=\\\"response-content-type\\\" />\\n        \";\n  }\n\nfunction program18(depth0,data) {\n  \n  \n  return \"\\n          <h4>Parameters</h4>\\n          <table class='fullwidth'>\\n          <thead>\\n            <tr>\\n            <th style=\\\"width: 100px; max-width: 100px\\\">Parameter</th>\\n            <th style=\\\"width: 310px; max-width: 310px\\\">Value</th>\\n            <th style=\\\"width: 200px; max-width: 200px\\\">Description</th>\\n            <th style=\\\"width: 100px; max-width: 100px\\\">Parameter Type</th>\\n            <th style=\\\"width: 220px; max-width: 230px\\\">Data Type</th>\\n            </tr>\\n          </thead>\\n          <tbody class=\\\"operation-params\\\">\\n\\n          </tbody>\\n          </table>\\n          \";\n  }\n\nfunction program20(depth0,data) {\n  \n  \n  return \"\\n          <div style='margin:0;padding:0;display:inline'></div>\\n          <h4>Response Messages</h4>\\n          <table class='fullwidth'>\\n            <thead>\\n            <tr>\\n              <th>HTTP Status Code</th>\\n              <th>Reason</th>\\n              <th>Response Model</th>\\n            </tr>\\n            </thead>\\n            <tbody class=\\\"operation-status\\\">\\n            \\n            </tbody>\\n          </table>\\n          \";\n  }\n\nfunction program22(depth0,data) {\n  \n  \n  return \"\\n          \";\n  }\n\nfunction program24(depth0,data) {\n  \n  \n  return \"\\n          <div class='sandbox_header'>\\n            <input class='submit' name='commit' type='button' value='Try it out!' />\\n            <a href='#' class='response_hider' style='display:none'>Hide Response</a>\\n            <span class='response_throbber' style='display:none'></span>\\n          </div>\\n          \";\n  }\n\n  buffer += \"\\n  <ul class='operations' >\\n    <li class='\";\n  if (stack1 = helpers.method) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.method; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \" operation' id='\";\n  if (stack1 = helpers.parentId) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.parentId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"_\";\n  if (stack1 = helpers.nickname) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.nickname; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'>\\n      <div class='heading'>\\n        <h3>\\n          <span class='http_method'>\\n          <a href='#!/\";\n  if (stack1 = helpers.parentId) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.parentId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"/\";\n  if (stack1 = helpers.nickname) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.nickname; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' class=\\\"toggleOperation\\\">\";\n  if (stack1 = helpers.method) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.method; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</a>\\n          </span>\\n          <span class='path'>\\n          <a href='#!/\";\n  if (stack1 = helpers.parentId) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.parentId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"/\";\n  if (stack1 = helpers.nickname) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.nickname; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' class=\\\"toggleOperation \";\n  stack1 = helpers['if'].call(depth0, depth0.deprecated, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\\">\";\n  if (stack1 = helpers.path) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.path; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</a>\\n          </span>\\n        </h3>\\n        <ul class='options'>\\n          <li>\\n          <a href='#!/\";\n  if (stack1 = helpers.parentId) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.parentId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"/\";\n  if (stack1 = helpers.nickname) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.nickname; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' class=\\\"toggleOperation\\\">\";\n  if (stack1 = helpers.summary) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.summary; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</a>\\n          </li>\\n        </ul>\\n      </div>\\n      <div class='content' id='\";\n  if (stack1 = helpers.parentId) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.parentId; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"_\";\n  if (stack1 = helpers.nickname) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.nickname; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"_content' style='display:none'>\\n        \";\n  stack1 = helpers['if'].call(depth0, depth0.deprecated, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n        \";\n  stack1 = helpers['if'].call(depth0, depth0.description, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n        \";\n  options = {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data};\n  if (stack1 = helpers.oauth) { stack1 = stack1.call(depth0, options); }\n  else { stack1 = depth0.oauth; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if (!helpers.oauth) { stack1 = blockHelperMissing.call(depth0, stack1, options); }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n        \";\n  stack1 = helpers.each.call(depth0, depth0.oauth, {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n        \";\n  options = {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data};\n  if (stack1 = helpers.oauth) { stack1 = stack1.call(depth0, options); }\n  else { stack1 = depth0.oauth; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if (!helpers.oauth) { stack1 = blockHelperMissing.call(depth0, stack1, options); }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n        \";\n  options = {hash:{},inverse:self.noop,fn:self.program(14, program14, data),data:data};\n  if (stack1 = helpers.oauth) { stack1 = stack1.call(depth0, options); }\n  else { stack1 = depth0.oauth; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if (!helpers.oauth) { stack1 = blockHelperMissing.call(depth0, stack1, options); }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n        \";\n  stack1 = helpers['if'].call(depth0, depth0.type, {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n        <form accept-charset='UTF-8' class='sandbox'>\\n          <div style='margin:0;padding:0;display:inline'></div>\\n          \";\n  stack1 = helpers['if'].call(depth0, depth0.parameters, {hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n          \";\n  stack1 = helpers['if'].call(depth0, depth0.responseMessages, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n          \";\n  stack1 = helpers['if'].call(depth0, depth0.isReadOnly, {hash:{},inverse:self.program(24, program24, data),fn:self.program(22, program22, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n        </form>\\n        <div class='response' style='display:none'>\\n          <h4>Request URL</h4>\\n          <div class='block request_url'></div>\\n          <h4>Response Body</h4>\\n          <div class='block response_body'></div>\\n          <h4>Response Code</h4>\\n          <div class='block response_code'></div>\\n          <h4>Response Headers</h4>\\n          <div class='block response_headers'></div>\\n        </div>\\n      </div>\\n    </li>\\n  </ul>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['param'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", escapeExpression=this.escapeExpression, self=this;\n\nfunction program1(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\";\n  stack1 = helpers['if'].call(depth0, depth0.isFile, {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\t\";\n  return buffer;\n  }\nfunction program2(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t<input type=\\\"file\\\" name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'/>\\n\t\t\t<div class=\\\"parameter-content-type\\\" />\\n\t\t\";\n  return buffer;\n  }\n\nfunction program4(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\";\n  stack1 = helpers['if'].call(depth0, depth0['default'], {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\t\t\";\n  return buffer;\n  }\nfunction program5(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\t<textarea class='body-textarea' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'>\";\n  if (stack1 = helpers['default']) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0['default']; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</textarea>\\n\t\t\t\";\n  return buffer;\n  }\n\nfunction program7(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\t<textarea class='body-textarea' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'></textarea>\\n\t\t\t\t<br />\\n\t\t\t\t<div class=\\\"parameter-content-type\\\" />\\n\t\t\t\";\n  return buffer;\n  }\n\nfunction program9(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\";\n  stack1 = helpers['if'].call(depth0, depth0.isFile, {hash:{},inverse:self.program(10, program10, data),fn:self.program(2, program2, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\t\";\n  return buffer;\n  }\nfunction program10(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\";\n  stack1 = helpers['if'].call(depth0, depth0['default'], {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\t\t\";\n  return buffer;\n  }\nfunction program11(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\t<input class='parameter' minlength='0' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' placeholder='' type='text' value='\";\n  if (stack1 = helpers['default']) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0['default']; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'/>\\n\t\t\t\";\n  return buffer;\n  }\n\nfunction program13(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\t<input class='parameter' minlength='0' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' placeholder='' type='text' value=''/>\\n\t\t\t\";\n  return buffer;\n  }\n\n  buffer += \"<td class='code'>\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</td>\\n<td>\\n\\n\t\";\n  stack1 = helpers['if'].call(depth0, depth0.isBody, {hash:{},inverse:self.program(9, program9, data),fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\\n</td>\\n<td>\";\n  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</td>\\n<td>\";\n  if (stack1 = helpers.paramType) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.paramType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</td>\\n<td>\\n\t<span class=\\\"model-signature\\\"></span>\\n</td>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['param_list'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, stack2, options, self=this, helperMissing=helpers.helperMissing, functionType=\"function\", escapeExpression=this.escapeExpression;\n\nfunction program1(depth0,data) {\n  \n  \n  return \" multiple='multiple'\";\n  }\n\nfunction program3(depth0,data) {\n  \n  \n  return \"\\n    \";\n  }\n\nfunction program5(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n      \";\n  stack1 = helpers['if'].call(depth0, depth0.defaultValue, {hash:{},inverse:self.program(8, program8, data),fn:self.program(6, program6, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n    \";\n  return buffer;\n  }\nfunction program6(depth0,data) {\n  \n  \n  return \"\\n      \";\n  }\n\nfunction program8(depth0,data) {\n  \n  var buffer = \"\", stack1, stack2, options;\n  buffer += \"\\n        \";\n  options = {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data};\n  stack2 = ((stack1 = helpers.isArray || depth0.isArray),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, \"isArray\", depth0, options));\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"\\n      \";\n  return buffer;\n  }\nfunction program9(depth0,data) {\n  \n  \n  return \"\\n        \";\n  }\n\nfunction program11(depth0,data) {\n  \n  \n  return \"\\n          <option selected=\\\"\\\" value=''></option>\\n        \";\n  }\n\nfunction program13(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n      \";\n  stack1 = helpers['if'].call(depth0, depth0.isDefault, {hash:{},inverse:self.program(16, program16, data),fn:self.program(14, program14, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n    \";\n  return buffer;\n  }\nfunction program14(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n        <option selected=\\\"\\\" value='\";\n  if (stack1 = helpers.value) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.value; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'>\";\n  if (stack1 = helpers.value) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.value; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \" (default)</option>\\n      \";\n  return buffer;\n  }\n\nfunction program16(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n        <option value='\";\n  if (stack1 = helpers.value) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.value; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'>\";\n  if (stack1 = helpers.value) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.value; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</option>\\n      \";\n  return buffer;\n  }\n\n  buffer += \"<td class='code'>\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</td>\\n<td>\\n  <select \";\n  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data};\n  stack2 = ((stack1 = helpers.isArray || depth0.isArray),stack1 ? stack1.call(depth0, depth0, options) : helperMissing.call(depth0, \"isArray\", depth0, options));\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \" class='parameter' name='\";\n  if (stack2 = helpers.name) { stack2 = stack2.call(depth0, {hash:{},data:data}); }\n  else { stack2 = depth0.name; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }\n  buffer += escapeExpression(stack2)\n    + \"'>\\n    \";\n  stack2 = helpers['if'].call(depth0, depth0.required, {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"\\n    \";\n  stack2 = helpers.each.call(depth0, ((stack1 = depth0.allowableValues),stack1 == null || stack1 === false ? stack1 : stack1.descriptiveValues), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"\\n  </select>\\n</td>\\n<td>\";\n  if (stack2 = helpers.description) { stack2 = stack2.call(depth0, {hash:{},data:data}); }\n  else { stack2 = depth0.description; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"</td>\\n<td>\";\n  if (stack2 = helpers.paramType) { stack2 = stack2.call(depth0, {hash:{},data:data}); }\n  else { stack2 = depth0.paramType; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }\n  if(stack2 || stack2 === 0) { buffer += stack2; }\n  buffer += \"</td>\\n<td><span class=\\\"model-signature\\\"></span></td>\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['param_readonly'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", escapeExpression=this.escapeExpression, self=this;\n\nfunction program1(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n        <textarea class='body-textarea' readonly='readonly' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'>\";\n  if (stack1 = helpers.defaultValue) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.defaultValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</textarea>\\n    \";\n  return buffer;\n  }\n\nfunction program3(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n        \";\n  stack1 = helpers['if'].call(depth0, depth0.defaultValue, {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n    \";\n  return buffer;\n  }\nfunction program4(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n            \";\n  if (stack1 = helpers.defaultValue) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.defaultValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"\\n        \";\n  return buffer;\n  }\n\nfunction program6(depth0,data) {\n  \n  \n  return \"\\n            (empty)\\n        \";\n  }\n\n  buffer += \"<td class='code'>\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</td>\\n<td>\\n    \";\n  stack1 = helpers['if'].call(depth0, depth0.isBody, {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n</td>\\n<td>\";\n  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</td>\\n<td>\";\n  if (stack1 = helpers.paramType) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.paramType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</td>\\n<td><span class=\\\"model-signature\\\"></span></td>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['param_readonly_required'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", escapeExpression=this.escapeExpression, self=this;\n\nfunction program1(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n        <textarea class='body-textarea'  readonly='readonly' placeholder='(required)' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'>\";\n  if (stack1 = helpers.defaultValue) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.defaultValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</textarea>\\n    \";\n  return buffer;\n  }\n\nfunction program3(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n        \";\n  stack1 = helpers['if'].call(depth0, depth0.defaultValue, {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n    \";\n  return buffer;\n  }\nfunction program4(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n            \";\n  if (stack1 = helpers.defaultValue) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.defaultValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"\\n        \";\n  return buffer;\n  }\n\nfunction program6(depth0,data) {\n  \n  \n  return \"\\n            (empty)\\n        \";\n  }\n\n  buffer += \"<td class='code required'>\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</td>\\n<td>\\n    \";\n  stack1 = helpers['if'].call(depth0, depth0.isBody, {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n</td>\\n<td>\";\n  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</td>\\n<td>\";\n  if (stack1 = helpers.paramType) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.paramType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</td>\\n<td><span class=\\\"model-signature\\\"></span></td>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['param_required'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", escapeExpression=this.escapeExpression, self=this;\n\nfunction program1(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\";\n  stack1 = helpers['if'].call(depth0, depth0.isFile, {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\t\";\n  return buffer;\n  }\nfunction program2(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t<input type=\\\"file\\\" name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'/>\\n\t\t\";\n  return buffer;\n  }\n\nfunction program4(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\";\n  stack1 = helpers['if'].call(depth0, depth0.defaultValue, {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\t\t\";\n  return buffer;\n  }\nfunction program5(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\t<textarea class='body-textarea' placeholder='(required)' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'>\";\n  if (stack1 = helpers.defaultValue) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.defaultValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</textarea>\\n\t\t\t\";\n  return buffer;\n  }\n\nfunction program7(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\t<textarea class='body-textarea' placeholder='(required)' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'></textarea>\\n\t\t\t\t<br />\\n\t\t\t\t<div class=\\\"parameter-content-type\\\" />\\n\t\t\t\";\n  return buffer;\n  }\n\nfunction program9(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\";\n  stack1 = helpers['if'].call(depth0, depth0.isFile, {hash:{},inverse:self.program(12, program12, data),fn:self.program(10, program10, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\t\";\n  return buffer;\n  }\nfunction program10(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t<input class='parameter' class='required' type='file' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'/>\\n\t\t\";\n  return buffer;\n  }\n\nfunction program12(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\";\n  stack1 = helpers['if'].call(depth0, depth0.defaultValue, {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\t\t\";\n  return buffer;\n  }\nfunction program13(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\t<input class='parameter required' minlength='1' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' placeholder='(required)' type='text' value='\";\n  if (stack1 = helpers.defaultValue) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.defaultValue; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'/>\\n\t\t\t\";\n  return buffer;\n  }\n\nfunction program15(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n\t\t\t\t<input class='parameter required' minlength='1' name='\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' placeholder='(required)' type='text' value=''/>\\n\t\t\t\";\n  return buffer;\n  }\n\n  buffer += \"<td class='code required'>\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</td>\\n<td>\\n\t\";\n  stack1 = helpers['if'].call(depth0, depth0.isBody, {hash:{},inverse:self.program(9, program9, data),fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n</td>\\n<td>\\n\t<strong>\";\n  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</strong>\\n</td>\\n<td>\";\n  if (stack1 = helpers.paramType) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.paramType; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</td>\\n<td><span class=\\\"model-signature\\\"></span></td>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['parameter_content_type'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", self=this;\n\nfunction program1(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n  \";\n  stack1 = helpers.each.call(depth0, depth0.consumes, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\";\n  return buffer;\n  }\nfunction program2(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n  <option value=\\\"\";\n  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\\">\";\n  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</option>\\n  \";\n  return buffer;\n  }\n\nfunction program4(depth0,data) {\n  \n  \n  return \"\\n  <option value=\\\"application/json\\\">application/json</option>\\n\";\n  }\n\n  buffer += \"<label for=\\\"parameterContentType\\\"></label>\\n<select name=\\\"parameterContentType\\\">\\n\";\n  stack1 = helpers['if'].call(depth0, depth0.consumes, {hash:{},inverse:self.program(4, program4, data),fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n</select>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['resource'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, options, functionType=\"function\", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;\n\nfunction program1(depth0,data) {\n  \n  \n  return \" : \";\n  }\n\nfunction program3(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"<li>\\n      <a href='\";\n  if (stack1 = helpers.url) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.url; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"'>Raw</a>\\n    </li>\";\n  return buffer;\n  }\n\n  buffer += \"<div class='heading'>\\n  <h2>\\n    <a href='#!/\";\n  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' class=\\\"toggleEndpointList\\\" data-id=\\\"\";\n  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"\\\">\";\n  if (stack1 = helpers.name) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.name; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</a> \";\n  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data};\n  if (stack1 = helpers.summary) { stack1 = stack1.call(depth0, options); }\n  else { stack1 = depth0.summary; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if (!helpers.summary) { stack1 = blockHelperMissing.call(depth0, stack1, options); }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  if (stack1 = helpers.summary) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.summary; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n  </h2>\\n  <ul class='options'>\\n    <li>\\n      <a href='#!/\";\n  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' id='endpointListTogger_\";\n  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"' class=\\\"toggleEndpointList\\\" data-id=\\\"\";\n  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"\\\">Show/Hide</a>\\n    </li>\\n    <li>\\n      <a href='#' class=\\\"collapseResource\\\" data-id=\\\"\";\n  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"\\\">\\n        List Operations\\n      </a>\\n    </li>\\n    <li>\\n      <a href='#' class=\\\"expandResource\\\" data-id=\";\n  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \">\\n        Expand Operations\\n      </a>\\n    </li>\\n    \";\n  options = {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data};\n  if (stack1 = helpers.url) { stack1 = stack1.call(depth0, options); }\n  else { stack1 = depth0.url; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if (!helpers.url) { stack1 = blockHelperMissing.call(depth0, stack1, options); }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n  </ul>\\n</div>\\n<ul class='endpoints' id='\";\n  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"_endpoint_list' style='display:none'>\\n\\n</ul>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['response_content_type'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", self=this;\n\nfunction program1(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n  \";\n  stack1 = helpers.each.call(depth0, depth0.produces, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n\";\n  return buffer;\n  }\nfunction program2(depth0,data) {\n  \n  var buffer = \"\", stack1;\n  buffer += \"\\n  <option value=\\\"\";\n  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\\">\";\n  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</option>\\n  \";\n  return buffer;\n  }\n\nfunction program4(depth0,data) {\n  \n  \n  return \"\\n  <option value=\\\"application/json\\\">application/json</option>\\n\";\n  }\n\n  buffer += \"<label for=\\\"responseContentType\\\"></label>\\n<select name=\\\"responseContentType\\\">\\n\";\n  stack1 = helpers['if'].call(depth0, depth0.produces, {hash:{},inverse:self.program(4, program4, data),fn:self.program(1, program1, data),data:data});\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n</select>\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['signature'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", escapeExpression=this.escapeExpression;\n\n\n  buffer += \"<div>\\n<ul class=\\\"signature-nav\\\">\\n  <li><a class=\\\"description-link\\\" href=\\\"#\\\">Model</a></li>\\n  <li><a class=\\\"snippet-link\\\" href=\\\"#\\\">Model Schema</a></li>\\n</ul>\\n<div>\\n\\n<div class=\\\"signature-container\\\">\\n  <div class=\\\"description\\\">\\n    \";\n  if (stack1 = helpers.signature) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.signature; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"\\n  </div>\\n\\n  <div class=\\\"snippet\\\">\\n    <pre><code>\";\n  if (stack1 = helpers.sampleJSON) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.sampleJSON; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</code></pre>\\n    <small class=\\\"notice\\\"></small>\\n  </div>\\n</div>\\n\\n\";\n  return buffer;\n  });\n})();\n\n(function() {\n  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\ntemplates['status_code'] = template(function (Handlebars,depth0,helpers,partials,data) {\n  this.compilerInfo = [4,'>= 1.0.0'];\nhelpers = this.merge(helpers, Handlebars.helpers); data = data || {};\n  var buffer = \"\", stack1, functionType=\"function\", escapeExpression=this.escapeExpression;\n\n\n  buffer += \"<td width='15%' class='code'>\";\n  if (stack1 = helpers.code) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.code; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  buffer += escapeExpression(stack1)\n    + \"</td>\\n<td>\";\n  if (stack1 = helpers.message) { stack1 = stack1.call(depth0, {hash:{},data:data}); }\n  else { stack1 = depth0.message; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }\n  if(stack1 || stack1 === 0) { buffer += stack1; }\n  buffer += \"</td>\\n<td width='50%'><span class=\\\"model-signature\\\" /></td>\";\n  return buffer;\n  });\n})();\n\n\n\n// Generated by CoffeeScript 1.6.3\n(function() {\n  var ApiKeyButton, BasicAuthButton, ContentTypeView, HeaderView, MainView, OperationView, ParameterContentTypeView, ParameterView, ResourceView, ResponseContentTypeView, SignatureView, StatusCodeView, SwaggerUi, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  SwaggerUi = (function(_super) {\n    __extends(SwaggerUi, _super);\n\n    function SwaggerUi() {\n      _ref = SwaggerUi.__super__.constructor.apply(this, arguments);\n      return _ref;\n    }\n\n    SwaggerUi.prototype.dom_id = \"swagger_ui\";\n\n    SwaggerUi.prototype.options = null;\n\n    SwaggerUi.prototype.api = null;\n\n    SwaggerUi.prototype.headerView = null;\n\n    SwaggerUi.prototype.mainView = null;\n\n    SwaggerUi.prototype.initialize = function(options) {\n      var _this = this;\n      if (options == null) {\n        options = {};\n      }\n      if (options.dom_id != null) {\n        this.dom_id = options.dom_id;\n        delete options.dom_id;\n      }\n      if ($('#' + this.dom_id) == null) {\n        $('body').append('<div id=\"' + this.dom_id + '\"></div>');\n      }\n      this.options = options;\n      this.options.success = function() {\n        return _this.render();\n      };\n      this.options.progress = function(d) {\n        return _this.showMessage(d);\n      };\n      this.options.failure = function(d) {\n        if (_this.api && _this.api.isValid === false) {\n          log(\"not a valid 2.0 spec, loading legacy client\");\n          _this.api = new SwaggerApi(_this.options);\n          return _this.api.build();\n        } else {\n          return _this.onLoadFailure(d);\n        }\n      };\n      this.headerView = new HeaderView({\n        el: $('#header')\n      });\n      return this.headerView.on('update-swagger-ui', function(data) {\n        return _this.updateSwaggerUi(data);\n      });\n    };\n\n    SwaggerUi.prototype.setOption = function(option, value) {\n      return this.options[option] = value;\n    };\n\n    SwaggerUi.prototype.getOption = function(option) {\n      return this.options[option];\n    };\n\n    SwaggerUi.prototype.updateSwaggerUi = function(data) {\n      this.options.url = data.url;\n      return this.load();\n    };\n\n    SwaggerUi.prototype.load = function() {\n      var url, _ref1;\n      if ((_ref1 = this.mainView) != null) {\n        _ref1.clear();\n      }\n      url = this.options.url;\n      if (url.indexOf(\"http\") !== 0) {\n        url = this.buildUrl(window.location.href.toString(), url);\n      }\n      this.options.url = url;\n      this.headerView.update(url);\n      this.api = new SwaggerClient(this.options);\n      return this.api.build();\n    };\n\n    SwaggerUi.prototype.render = function() {\n      var _this = this;\n      this.showMessage('Finished Loading Resource Information. Rendering Swagger UI...');\n      this.mainView = new MainView({\n        model: this.api,\n        el: $('#' + this.dom_id),\n        swaggerOptions: this.options\n      }).render();\n      this.showMessage();\n      switch (this.options.docExpansion) {\n        case \"full\":\n          Docs.expandOperationsForResource('');\n          break;\n        case \"list\":\n          Docs.collapseOperationsForResource('');\n      }\n      if (this.options.onComplete) {\n        this.options.onComplete(this.api, this);\n      }\n      return setTimeout(function() {\n        return Docs.shebang();\n      }, 400);\n    };\n\n    SwaggerUi.prototype.buildUrl = function(base, url) {\n      var endOfPath, parts;\n      log(\"base is \" + base);\n      if (url.indexOf(\"/\") === 0) {\n        parts = base.split(\"/\");\n        base = parts[0] + \"//\" + parts[2];\n        return base + url;\n      } else {\n        endOfPath = base.length;\n        if (base.indexOf(\"?\") > -1) {\n          endOfPath = Math.min(endOfPath, base.indexOf(\"?\"));\n        }\n        if (base.indexOf(\"#\") > -1) {\n          endOfPath = Math.min(endOfPath, base.indexOf(\"#\"));\n        }\n        base = base.substring(0, endOfPath);\n        if (base.indexOf(\"/\", base.length - 1) !== -1) {\n          return base + url;\n        }\n        return base + \"/\" + url;\n      }\n    };\n\n    SwaggerUi.prototype.showMessage = function(data) {\n      if (data == null) {\n        data = '';\n      }\n      $('#message-bar').removeClass('message-fail');\n      $('#message-bar').addClass('message-success');\n      return $('#message-bar').html(data);\n    };\n\n    SwaggerUi.prototype.onLoadFailure = function(data) {\n      var val;\n      if (data == null) {\n        data = '';\n      }\n      $('#message-bar').removeClass('message-success');\n      $('#message-bar').addClass('message-fail');\n      val = $('#message-bar').html(data);\n      if (this.options.onFailure != null) {\n        this.options.onFailure(data);\n      }\n      return val;\n    };\n\n    return SwaggerUi;\n\n  })(Backbone.Router);\n\n  window.SwaggerUi = SwaggerUi;\n\n  HeaderView = (function(_super) {\n    __extends(HeaderView, _super);\n\n    function HeaderView() {\n      _ref1 = HeaderView.__super__.constructor.apply(this, arguments);\n      return _ref1;\n    }\n\n    HeaderView.prototype.events = {\n      'click #show-pet-store-icon': 'showPetStore',\n      'click #show-wordnik-dev-icon': 'showWordnikDev',\n      'click #explore': 'showCustom',\n      'keyup #input_baseUrl': 'showCustomOnKeyup',\n      'keyup #input_apiKey': 'showCustomOnKeyup'\n    };\n\n    HeaderView.prototype.initialize = function() {};\n\n    HeaderView.prototype.showPetStore = function(e) {\n      return this.trigger('update-swagger-ui', {\n        url: \"http://petstore.swagger.wordnik.com/api/api-docs\"\n      });\n    };\n\n    HeaderView.prototype.showWordnikDev = function(e) {\n      return this.trigger('update-swagger-ui', {\n        url: \"http://api.wordnik.com/v4/resources.json\"\n      });\n    };\n\n    HeaderView.prototype.showCustomOnKeyup = function(e) {\n      if (e.keyCode === 13) {\n        return this.showCustom();\n      }\n    };\n\n    HeaderView.prototype.showCustom = function(e) {\n      if (e != null) {\n        e.preventDefault();\n      }\n      return this.trigger('update-swagger-ui', {\n        url: $('#input_baseUrl').val(),\n        apiKey: $('#input_apiKey').val()\n      });\n    };\n\n    HeaderView.prototype.update = function(url, apiKey, trigger) {\n      if (trigger == null) {\n        trigger = false;\n      }\n      $('#input_baseUrl').val(url);\n      if (trigger) {\n        return this.trigger('update-swagger-ui', {\n          url: url\n        });\n      }\n    };\n\n    return HeaderView;\n\n  })(Backbone.View);\n\n  MainView = (function(_super) {\n    var sorters;\n\n    __extends(MainView, _super);\n\n    function MainView() {\n      _ref2 = MainView.__super__.constructor.apply(this, arguments);\n      return _ref2;\n    }\n\n    sorters = {\n      'alpha': function(a, b) {\n        return a.path.localeCompare(b.path);\n      },\n      'method': function(a, b) {\n        return a.method.localeCompare(b.method);\n      }\n    };\n\n    MainView.prototype.initialize = function(opts) {\n      var auth, key, name, url, value, _ref3;\n      if (opts == null) {\n        opts = {};\n      }\n      this.model.auths = [];\n      _ref3 = this.model.securityDefinitions;\n      for (key in _ref3) {\n        value = _ref3[key];\n        auth = {\n          name: key,\n          type: value.type,\n          value: value\n        };\n        this.model.auths.push(auth);\n      }\n      if (this.model.info && this.model.info.license && typeof this.model.info.license === 'string') {\n        name = this.model.info.license;\n        url = this.model.info.licenseUrl;\n        this.model.info.license = {};\n        this.model.info.license.name = name;\n        this.model.info.license.url = url;\n      }\n      if (!this.model.info) {\n        this.model.info = {};\n      }\n      if (!this.model.info.version) {\n        this.model.info.version = this.model.apiVersion;\n      }\n      if (this.model.swaggerVersion === \"2.0\") {\n        if (\"validatorUrl\" in opts.swaggerOptions) {\n          return this.model.validatorUrl = opts.swaggerOptions.validatorUrl;\n        } else if (this.model.url.match(/https?:\\/\\/localhost/)) {\n          return this.model.validatorUrl = this.model.url;\n        } else {\n          return this.model.validatorUrl = \"http://online.swagger.io/validator\";\n        }\n      }\n    };\n\n    MainView.prototype.render = function() {\n      var auth, button, counter, id, name, resource, resources, _i, _len, _ref3;\n      if (this.model.securityDefinitions) {\n        for (name in this.model.securityDefinitions) {\n          auth = this.model.securityDefinitions[name];\n          if (auth.type === \"apiKey\" && $(\"#apikey_button\").length === 0) {\n            button = new ApiKeyButton({\n              model: auth\n            }).render().el;\n            $('.auth_main_container').append(button);\n          }\n          if (auth.type === \"basicAuth\" && $(\"#basic_auth_button\").length === 0) {\n            button = new BasicAuthButton({\n              model: auth\n            }).render().el;\n            $('.auth_main_container').append(button);\n          }\n        }\n      }\n      $(this.el).html(Handlebars.templates.main(this.model));\n      resources = {};\n      counter = 0;\n      _ref3 = this.model.apisArray;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        resource = _ref3[_i];\n        id = resource.name;\n        while (typeof resources[id] !== 'undefined') {\n          id = id + \"_\" + counter;\n          counter += 1;\n        }\n        resource.id = id;\n        resources[id] = resource;\n        this.addResource(resource, this.model.auths);\n      }\n      return this;\n    };\n\n    MainView.prototype.addResource = function(resource, auths) {\n      var resourceView;\n      resource.id = resource.id.replace(/\\s/g, '_');\n      resourceView = new ResourceView({\n        model: resource,\n        tagName: 'li',\n        id: 'resource_' + resource.id,\n        className: 'resource',\n        auths: auths,\n        swaggerOptions: this.options.swaggerOptions\n      });\n      return $('#resources').append(resourceView.render().el);\n    };\n\n    MainView.prototype.clear = function() {\n      return $(this.el).html('');\n    };\n\n    return MainView;\n\n  })(Backbone.View);\n\n  ResourceView = (function(_super) {\n    __extends(ResourceView, _super);\n\n    function ResourceView() {\n      _ref3 = ResourceView.__super__.constructor.apply(this, arguments);\n      return _ref3;\n    }\n\n    ResourceView.prototype.initialize = function(opts) {\n      if (opts == null) {\n        opts = {};\n      }\n      this.auths = opts.auths;\n      if (\"\" === this.model.description) {\n        return this.model.description = null;\n      }\n    };\n\n    ResourceView.prototype.render = function() {\n      var counter, id, methods, operation, _i, _len, _ref4;\n      $(this.el).html(Handlebars.templates.resource(this.model));\n      methods = {};\n      if (this.model.description) {\n        this.model.summary = this.model.description;\n      }\n      _ref4 = this.model.operationsArray;\n      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n        operation = _ref4[_i];\n        counter = 0;\n        id = operation.nickname;\n        while (typeof methods[id] !== 'undefined') {\n          id = id + \"_\" + counter;\n          counter += 1;\n        }\n        methods[id] = operation;\n        operation.nickname = id;\n        operation.parentId = this.model.id;\n        this.addOperation(operation);\n      }\n      $('.toggleEndpointList', this.el).click(this.callDocs.bind(this, 'toggleEndpointListForResource'));\n      $('.collapseResource', this.el).click(this.callDocs.bind(this, 'collapseOperationsForResource'));\n      $('.expandResource', this.el).click(this.callDocs.bind(this, 'expandOperationsForResource'));\n      return this;\n    };\n\n    ResourceView.prototype.addOperation = function(operation) {\n      var operationView;\n      operation.number = this.number;\n      operationView = new OperationView({\n        model: operation,\n        tagName: 'li',\n        className: 'endpoint',\n        swaggerOptions: this.options.swaggerOptions,\n        auths: this.auths\n      });\n      $('.endpoints', $(this.el)).append(operationView.render().el);\n      return this.number++;\n    };\n\n    ResourceView.prototype.callDocs = function(fnName, e) {\n      e.preventDefault();\n      return Docs[fnName](e.currentTarget.getAttribute('data-id'));\n    };\n\n    return ResourceView;\n\n  })(Backbone.View);\n\n  OperationView = (function(_super) {\n    __extends(OperationView, _super);\n\n    function OperationView() {\n      _ref4 = OperationView.__super__.constructor.apply(this, arguments);\n      return _ref4;\n    }\n\n    OperationView.prototype.invocationUrl = null;\n\n    OperationView.prototype.events = {\n      'submit .sandbox': 'submitOperation',\n      'click .submit': 'submitOperation',\n      'click .response_hider': 'hideResponse',\n      'click .toggleOperation': 'toggleOperationContent',\n      'mouseenter .api-ic': 'mouseEnter',\n      'mouseout .api-ic': 'mouseExit'\n    };\n\n    OperationView.prototype.initialize = function(opts) {\n      if (opts == null) {\n        opts = {};\n      }\n      this.auths = opts.auths;\n      return this;\n    };\n\n    OperationView.prototype.mouseEnter = function(e) {\n      var elem, hgh, pos, scMaxX, scMaxY, scX, scY, wd, x, y;\n      elem = $(e.currentTarget.parentNode).find('#api_information_panel');\n      x = e.pageX;\n      y = e.pageY;\n      scX = $(window).scrollLeft();\n      scY = $(window).scrollTop();\n      scMaxX = scX + $(window).width();\n      scMaxY = scY + $(window).height();\n      wd = elem.width();\n      hgh = elem.height();\n      if (x + wd > scMaxX) {\n        x = scMaxX - wd;\n      }\n      if (x < scX) {\n        x = scX;\n      }\n      if (y + hgh > scMaxY) {\n        y = scMaxY - hgh;\n      }\n      if (y < scY) {\n        y = scY;\n      }\n      pos = {};\n      pos.top = y;\n      pos.left = x;\n      elem.css(pos);\n      return $(e.currentTarget.parentNode).find('#api_information_panel').show();\n    };\n\n    OperationView.prototype.mouseExit = function(e) {\n      return $(e.currentTarget.parentNode).find('#api_information_panel').hide();\n    };\n\n    OperationView.prototype.render = function() {\n      var a, auth, auths, code, contentTypeModel, isMethodSubmissionSupported, k, key, o, param, ref, responseContentTypeView, responseSignatureView, schema, schemaObj, signatureModel, statusCode, type, v, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref10, _ref11, _ref5, _ref6, _ref7, _ref8, _ref9;\n      isMethodSubmissionSupported = true;\n      if (!isMethodSubmissionSupported) {\n        this.model.isReadOnly = true;\n      }\n      this.model.description = this.model.description || this.model.notes;\n      if (this.model.description) {\n        this.model.description = this.model.description.replace(/(?:\\r\\n|\\r|\\n)/g, '<br />');\n      }\n      this.model.oauth = null;\n      log(this.model.authorizations);\n      if (this.model.authorizations) {\n        if (Array.isArray(this.model.authorizations)) {\n          _ref5 = this.model.authorizations;\n          for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n            auths = _ref5[_i];\n            for (key in auths) {\n              auth = auths[key];\n              for (a in this.auths) {\n                auth = this.auths[a];\n                if (auth.type === 'oauth2') {\n                  this.model.oauth = {};\n                  this.model.oauth.scopes = [];\n                  _ref6 = auth.value.scopes;\n                  for (k in _ref6) {\n                    v = _ref6[k];\n                    o = {\n                      scope: k,\n                      description: v\n                    };\n                    this.model.oauth.scopes.push(o);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          _ref7 = this.model.authorizations;\n          for (k in _ref7) {\n            v = _ref7[k];\n            if (k === \"oauth2\") {\n              if (this.model.oauth === null) {\n                this.model.oauth = {};\n              }\n              if (this.model.oauth.scopes === void 0) {\n                this.model.oauth.scopes = [];\n              }\n              for (_j = 0, _len1 = v.length; _j < _len1; _j++) {\n                o = v[_j];\n                this.model.oauth.scopes.push(o);\n              }\n            }\n          }\n        }\n      }\n      if (typeof this.model.responses !== 'undefined') {\n        this.model.responseMessages = [];\n        _ref8 = this.model.responses;\n        for (code in _ref8) {\n          value = _ref8[code];\n          schema = null;\n          schemaObj = this.model.responses[code].schema;\n          if (schemaObj && schemaObj['$ref']) {\n            schema = schemaObj['$ref'];\n            if (schema.indexOf('#/definitions/') === 0) {\n              schema = schema.substring('#/definitions/'.length);\n            }\n          }\n          this.model.responseMessages.push({\n            code: code,\n            message: value.description,\n            responseModel: schema\n          });\n        }\n      }\n      if (typeof this.model.responseMessages === 'undefined') {\n        this.model.responseMessages = [];\n      }\n      $(this.el).html(Handlebars.templates.operation(this.model));\n      if (this.model.responseClassSignature && this.model.responseClassSignature !== 'string') {\n        signatureModel = {\n          sampleJSON: this.model.responseSampleJSON,\n          isParam: false,\n          signature: this.model.responseClassSignature\n        };\n        responseSignatureView = new SignatureView({\n          model: signatureModel,\n          tagName: 'div'\n        });\n        $('.model-signature', $(this.el)).append(responseSignatureView.render().el);\n      } else {\n        this.model.responseClassSignature = 'string';\n        $('.model-signature', $(this.el)).html(this.model.type);\n      }\n      contentTypeModel = {\n        isParam: false\n      };\n      contentTypeModel.consumes = this.model.consumes;\n      contentTypeModel.produces = this.model.produces;\n      _ref9 = this.model.parameters;\n      for (_k = 0, _len2 = _ref9.length; _k < _len2; _k++) {\n        param = _ref9[_k];\n        type = param.type || param.dataType;\n        if (typeof type === 'undefined') {\n          schema = param.schema;\n          if (schema && schema['$ref']) {\n            ref = schema['$ref'];\n            if (ref.indexOf('#/definitions/') === 0) {\n              type = ref.substring('#/definitions/'.length);\n            } else {\n              type = ref;\n            }\n          }\n        }\n        if (type && type.toLowerCase() === 'file') {\n          if (!contentTypeModel.consumes) {\n            contentTypeModel.consumes = 'multipart/form-data';\n          }\n        }\n        param.type = type;\n      }\n      responseContentTypeView = new ResponseContentTypeView({\n        model: contentTypeModel\n      });\n      $('.response-content-type', $(this.el)).append(responseContentTypeView.render().el);\n      _ref10 = this.model.parameters;\n      for (_l = 0, _len3 = _ref10.length; _l < _len3; _l++) {\n        param = _ref10[_l];\n        this.addParameter(param, contentTypeModel.consumes);\n      }\n      _ref11 = this.model.responseMessages;\n      for (_m = 0, _len4 = _ref11.length; _m < _len4; _m++) {\n        statusCode = _ref11[_m];\n        this.addStatusCode(statusCode);\n      }\n      return this;\n    };\n\n    OperationView.prototype.addParameter = function(param, consumes) {\n      var paramView;\n      param.consumes = consumes;\n      paramView = new ParameterView({\n        model: param,\n        tagName: 'tr',\n        readOnly: this.model.isReadOnly\n      });\n      return $('.operation-params', $(this.el)).append(paramView.render().el);\n    };\n\n    OperationView.prototype.addStatusCode = function(statusCode) {\n      var statusCodeView;\n      statusCodeView = new StatusCodeView({\n        model: statusCode,\n        tagName: 'tr'\n      });\n      return $('.operation-status', $(this.el)).append(statusCodeView.render().el);\n    };\n\n    OperationView.prototype.submitOperation = function(e) {\n      var error_free, form, isFileUpload, map, o, opts, val, _i, _j, _k, _len, _len1, _len2, _ref5, _ref6, _ref7;\n      if (e != null) {\n        e.preventDefault();\n      }\n      form = $('.sandbox', $(this.el));\n      error_free = true;\n      form.find(\"input.required\").each(function() {\n        var _this = this;\n        $(this).removeClass(\"error\");\n        if (jQuery.trim($(this).val()) === \"\") {\n          $(this).addClass(\"error\");\n          $(this).wiggle({\n            callback: function() {\n              return $(_this).focus();\n            }\n          });\n          return error_free = false;\n        }\n      });\n      if (error_free) {\n        map = {};\n        opts = {\n          parent: this\n        };\n        isFileUpload = false;\n        _ref5 = form.find(\"input\");\n        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n          o = _ref5[_i];\n          if ((o.value != null) && jQuery.trim(o.value).length > 0) {\n            map[o.name] = o.value;\n          }\n          if (o.type === \"file\") {\n            isFileUpload = true;\n          }\n        }\n        _ref6 = form.find(\"textarea\");\n        for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {\n          o = _ref6[_j];\n          if ((o.value != null) && jQuery.trim(o.value).length > 0) {\n            map[o.name] = o.value;\n          }\n        }\n        _ref7 = form.find(\"select\");\n        for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {\n          o = _ref7[_k];\n          val = this.getSelectedValue(o);\n          if ((val != null) && jQuery.trim(val).length > 0) {\n            map[o.name] = val;\n          }\n        }\n        opts.responseContentType = $(\"div select[name=responseContentType]\", $(this.el)).val();\n        opts.requestContentType = $(\"div select[name=parameterContentType]\", $(this.el)).val();\n        $(\".response_throbber\", $(this.el)).show();\n        if (isFileUpload) {\n          return this.handleFileUpload(map, form);\n        } else {\n          return this.model[\"do\"](map, opts, this.showCompleteStatus, this.showErrorStatus, this);\n        }\n      }\n    };\n\n    OperationView.prototype.success = function(response, parent) {\n      return parent.showCompleteStatus(response);\n    };\n\n    OperationView.prototype.handleFileUpload = function(map, form) {\n      var bodyParam, el, headerParams, o, obj, param, params, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref5, _ref6, _ref7, _ref8,\n        _this = this;\n      _ref5 = form.serializeArray();\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        o = _ref5[_i];\n        if ((o.value != null) && jQuery.trim(o.value).length > 0) {\n          map[o.name] = o.value;\n        }\n      }\n      bodyParam = new FormData();\n      params = 0;\n      _ref6 = this.model.parameters;\n      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {\n        param = _ref6[_j];\n        if (param.paramType === 'form') {\n          if (param.type.toLowerCase() !== 'file' && map[param.name] !== void 0) {\n            bodyParam.append(param.name, map[param.name]);\n          }\n        }\n      }\n      headerParams = {};\n      _ref7 = this.model.parameters;\n      for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {\n        param = _ref7[_k];\n        if (param.paramType === 'header') {\n          headerParams[param.name] = map[param.name];\n        }\n      }\n      _ref8 = form.find('input[type~=\"file\"]');\n      for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {\n        el = _ref8[_l];\n        if (typeof el.files[0] !== 'undefined') {\n          bodyParam.append($(el).attr('name'), el.files[0]);\n          params += 1;\n        }\n      }\n      this.invocationUrl = this.model.supportHeaderParams() ? (headerParams = this.model.getHeaderParams(map), this.model.urlify(map, false)) : this.model.urlify(map, true);\n      $(\".request_url\", $(this.el)).html(\"<pre></pre>\");\n      $(\".request_url pre\", $(this.el)).text(this.invocationUrl);\n      obj = {\n        type: this.model.method,\n        url: this.invocationUrl,\n        headers: headerParams,\n        data: bodyParam,\n        dataType: 'json',\n        contentType: false,\n        processData: false,\n        error: function(data, textStatus, error) {\n          return _this.showErrorStatus(_this.wrap(data), _this);\n        },\n        success: function(data) {\n          return _this.showResponse(data, _this);\n        },\n        complete: function(data) {\n          return _this.showCompleteStatus(_this.wrap(data), _this);\n        }\n      };\n      if (window.authorizations) {\n        window.authorizations.apply(obj);\n      }\n      if (params === 0) {\n        obj.data.append(\"fake\", \"true\");\n      }\n      jQuery.ajax(obj);\n      return false;\n    };\n\n    OperationView.prototype.wrap = function(data) {\n      var h, headerArray, headers, i, o, _i, _len;\n      headers = {};\n      headerArray = data.getAllResponseHeaders().split(\"\\r\");\n      for (_i = 0, _len = headerArray.length; _i < _len; _i++) {\n        i = headerArray[_i];\n        h = i.split(':');\n        if (h[0] !== void 0 && h[1] !== void 0) {\n          headers[h[0].trim()] = h[1].trim();\n        }\n      }\n      o = {};\n      o.content = {};\n      o.content.data = data.responseText;\n      o.headers = headers;\n      o.request = {};\n      o.request.url = this.invocationUrl;\n      o.status = data.status;\n      return o;\n    };\n\n    OperationView.prototype.getSelectedValue = function(select) {\n      var opt, options, _i, _len, _ref5;\n      if (!select.multiple) {\n        return select.value;\n      } else {\n        options = [];\n        _ref5 = select.options;\n        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n          opt = _ref5[_i];\n          if (opt.selected) {\n            options.push(opt.value);\n          }\n        }\n        if (options.length > 0) {\n          return options;\n        } else {\n          return null;\n        }\n      }\n    };\n\n    OperationView.prototype.hideResponse = function(e) {\n      if (e != null) {\n        e.preventDefault();\n      }\n      $(\".response\", $(this.el)).slideUp();\n      return $(\".response_hider\", $(this.el)).fadeOut();\n    };\n\n    OperationView.prototype.showResponse = function(response) {\n      var prettyJson;\n      prettyJson = JSON.stringify(response, null, \"\\t\").replace(/\\n/g, \"<br>\");\n      return $(\".response_body\", $(this.el)).html(escape(prettyJson));\n    };\n\n    OperationView.prototype.showErrorStatus = function(data, parent) {\n      return parent.showStatus(data);\n    };\n\n    OperationView.prototype.showCompleteStatus = function(data, parent) {\n      return parent.showStatus(data);\n    };\n\n    OperationView.prototype.formatXml = function(xml) {\n      var contexp, formatted, indent, lastType, lines, ln, pad, reg, transitions, wsexp, _fn, _i, _len;\n      reg = /(>)(<)(\\/*)/g;\n      wsexp = /[ ]*(.*)[ ]+\\n/g;\n      contexp = /(<.+>)(.+\\n)/g;\n      xml = xml.replace(reg, '$1\\n$2$3').replace(wsexp, '$1\\n').replace(contexp, '$1\\n$2');\n      pad = 0;\n      formatted = '';\n      lines = xml.split('\\n');\n      indent = 0;\n      lastType = 'other';\n      transitions = {\n        'single->single': 0,\n        'single->closing': -1,\n        'single->opening': 0,\n        'single->other': 0,\n        'closing->single': 0,\n        'closing->closing': -1,\n        'closing->opening': 0,\n        'closing->other': 0,\n        'opening->single': 1,\n        'opening->closing': 0,\n        'opening->opening': 1,\n        'opening->other': 1,\n        'other->single': 0,\n        'other->closing': -1,\n        'other->opening': 0,\n        'other->other': 0\n      };\n      _fn = function(ln) {\n        var fromTo, j, key, padding, type, types, value;\n        types = {\n          single: Boolean(ln.match(/<.+\\/>/)),\n          closing: Boolean(ln.match(/<\\/.+>/)),\n          opening: Boolean(ln.match(/<[^!?].*>/))\n        };\n        type = ((function() {\n          var _results;\n          _results = [];\n          for (key in types) {\n            value = types[key];\n            if (value) {\n              _results.push(key);\n            }\n          }\n          return _results;\n        })())[0];\n        type = type === void 0 ? 'other' : type;\n        fromTo = lastType + '->' + type;\n        lastType = type;\n        padding = '';\n        indent += transitions[fromTo];\n        padding = ((function() {\n          var _j, _ref5, _results;\n          _results = [];\n          for (j = _j = 0, _ref5 = indent; 0 <= _ref5 ? _j < _ref5 : _j > _ref5; j = 0 <= _ref5 ? ++_j : --_j) {\n            _results.push('  ');\n          }\n          return _results;\n        })()).join('');\n        if (fromTo === 'opening->closing') {\n          return formatted = formatted.substr(0, formatted.length - 1) + ln + '\\n';\n        } else {\n          return formatted += padding + ln + '\\n';\n        }\n      };\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        ln = lines[_i];\n        _fn(ln);\n      }\n      return formatted;\n    };\n\n    OperationView.prototype.showStatus = function(response) {\n      var code, content, contentType, e, headers, json, opts, pre, response_body, response_body_el, url;\n      if (response.content === void 0) {\n        content = response.data;\n        url = response.url;\n      } else {\n        content = response.content.data;\n        url = response.request.url;\n      }\n      headers = response.headers;\n      contentType = headers && headers[\"Content-Type\"] ? headers[\"Content-Type\"].split(\";\")[0].trim() : null;\n      if (!content) {\n        code = $('<code />').text(\"no content\");\n        pre = $('<pre class=\"json\" />').append(code);\n      } else if (contentType === \"application/json\" || /\\+json$/.test(contentType)) {\n        json = null;\n        try {\n          json = JSON.stringify(JSON.parse(content), null, \"  \");\n        } catch (_error) {\n          e = _error;\n          json = \"can't parse JSON.  Raw result:\\n\\n\" + content;\n        }\n        code = $('<code />').text(json);\n        pre = $('<pre class=\"json\" />').append(code);\n      } else if (contentType === \"application/xml\" || /\\+xml$/.test(contentType)) {\n        code = $('<code />').text(this.formatXml(content));\n        pre = $('<pre class=\"xml\" />').append(code);\n      } else if (contentType === \"text/html\") {\n        code = $('<code />').html(_.escape(content));\n        pre = $('<pre class=\"xml\" />').append(code);\n      } else if (/^image\\//.test(contentType)) {\n        pre = $('<img>').attr('src', url);\n      } else {\n        code = $('<code />').text(content);\n        pre = $('<pre class=\"json\" />').append(code);\n      }\n      response_body = pre;\n      $(\".request_url\", $(this.el)).html(\"<pre></pre>\");\n      $(\".request_url pre\", $(this.el)).text(url);\n      $(\".response_code\", $(this.el)).html(\"<pre>\" + response.status + \"</pre>\");\n      $(\".response_body\", $(this.el)).html(response_body);\n      $(\".response_headers\", $(this.el)).html(\"<pre>\" + _.escape(JSON.stringify(response.headers, null, \"  \")).replace(/\\n/g, \"<br>\") + \"</pre>\");\n      $(\".response\", $(this.el)).slideDown();\n      $(\".response_hider\", $(this.el)).show();\n      $(\".response_throbber\", $(this.el)).hide();\n      response_body_el = $('.response_body', $(this.el))[0];\n      opts = this.options.swaggerOptions;\n      if (opts.highlightSizeThreshold && response.data.length > opts.highlightSizeThreshold) {\n        return response_body_el;\n      } else {\n        return hljs.highlightBlock(response_body_el);\n      }\n    };\n\n    OperationView.prototype.toggleOperationContent = function() {\n      var elem;\n      elem = $('#' + Docs.escapeResourceName(this.model.parentId) + \"_\" + this.model.nickname + \"_content\");\n      if (elem.is(':visible')) {\n        return Docs.collapseOperation(elem);\n      } else {\n        return Docs.expandOperation(elem);\n      }\n    };\n\n    return OperationView;\n\n  })(Backbone.View);\n\n  StatusCodeView = (function(_super) {\n    __extends(StatusCodeView, _super);\n\n    function StatusCodeView() {\n      _ref5 = StatusCodeView.__super__.constructor.apply(this, arguments);\n      return _ref5;\n    }\n\n    StatusCodeView.prototype.initialize = function() {};\n\n    StatusCodeView.prototype.render = function() {\n      var responseModel, responseModelView, template;\n      template = this.template();\n      $(this.el).html(template(this.model));\n      if (swaggerUi.api.models.hasOwnProperty(this.model.responseModel)) {\n        responseModel = {\n          sampleJSON: JSON.stringify(swaggerUi.api.models[this.model.responseModel].createJSONSample(), null, 2),\n          isParam: false,\n          signature: swaggerUi.api.models[this.model.responseModel].getMockSignature()\n        };\n        responseModelView = new SignatureView({\n          model: responseModel,\n          tagName: 'div'\n        });\n        $('.model-signature', this.$el).append(responseModelView.render().el);\n      } else {\n        $('.model-signature', this.$el).html('');\n      }\n      return this;\n    };\n\n    StatusCodeView.prototype.template = function() {\n      return Handlebars.templates.status_code;\n    };\n\n    return StatusCodeView;\n\n  })(Backbone.View);\n\n  ParameterView = (function(_super) {\n    __extends(ParameterView, _super);\n\n    function ParameterView() {\n      _ref6 = ParameterView.__super__.constructor.apply(this, arguments);\n      return _ref6;\n    }\n\n    ParameterView.prototype.initialize = function() {\n      return Handlebars.registerHelper('isArray', function(param, opts) {\n        if (param.type.toLowerCase() === 'array' || param.allowMultiple) {\n          return opts.fn(this);\n        } else {\n          return opts.inverse(this);\n        }\n      });\n    };\n\n    ParameterView.prototype.render = function() {\n      var contentTypeModel, isParam, parameterContentTypeView, ref, responseContentTypeView, schema, signatureModel, signatureView, template, type;\n      type = this.model.type || this.model.dataType;\n      if (typeof type === 'undefined') {\n        schema = this.model.schema;\n        if (schema && schema['$ref']) {\n          ref = schema['$ref'];\n          if (ref.indexOf('#/definitions/') === 0) {\n            type = ref.substring('#/definitions/'.length);\n          } else {\n            type = ref;\n          }\n        }\n      }\n      this.model.type = type;\n      this.model.paramType = this.model[\"in\"] || this.model.paramType;\n      if (this.model.paramType === 'body') {\n        this.model.isBody = true;\n      }\n      if (type && type.toLowerCase() === 'file') {\n        this.model.isFile = true;\n      }\n      this.model[\"default\"] = this.model[\"default\"] || this.model.defaultValue;\n      template = this.template();\n      $(this.el).html(template(this.model));\n      signatureModel = {\n        sampleJSON: this.model.sampleJSON,\n        isParam: true,\n        signature: this.model.signature\n      };\n      if (this.model.sampleJSON) {\n        signatureView = new SignatureView({\n          model: signatureModel,\n          tagName: 'div'\n        });\n        $('.model-signature', $(this.el)).append(signatureView.render().el);\n      } else {\n        $('.model-signature', $(this.el)).html(this.model.signature);\n      }\n      isParam = false;\n      if (this.model.isBody) {\n        isParam = true;\n      }\n      contentTypeModel = {\n        isParam: isParam\n      };\n      contentTypeModel.consumes = this.model.consumes;\n      if (isParam) {\n        parameterContentTypeView = new ParameterContentTypeView({\n          model: contentTypeModel\n        });\n        $('.parameter-content-type', $(this.el)).append(parameterContentTypeView.render().el);\n      } else {\n        responseContentTypeView = new ResponseContentTypeView({\n          model: contentTypeModel\n        });\n        $('.response-content-type', $(this.el)).append(responseContentTypeView.render().el);\n      }\n      return this;\n    };\n\n    ParameterView.prototype.template = function() {\n      if (this.model.isList) {\n        return Handlebars.templates.param_list;\n      } else {\n        if (this.options.readOnly) {\n          if (this.model.required) {\n            return Handlebars.templates.param_readonly_required;\n          } else {\n            return Handlebars.templates.param_readonly;\n          }\n        } else {\n          if (this.model.required) {\n            return Handlebars.templates.param_required;\n          } else {\n            return Handlebars.templates.param;\n          }\n        }\n      }\n    };\n\n    return ParameterView;\n\n  })(Backbone.View);\n\n  SignatureView = (function(_super) {\n    __extends(SignatureView, _super);\n\n    function SignatureView() {\n      _ref7 = SignatureView.__super__.constructor.apply(this, arguments);\n      return _ref7;\n    }\n\n    SignatureView.prototype.events = {\n      'click a.description-link': 'switchToDescription',\n      'click a.snippet-link': 'switchToSnippet',\n      'mousedown .snippet': 'snippetToTextArea'\n    };\n\n    SignatureView.prototype.initialize = function() {};\n\n    SignatureView.prototype.render = function() {\n      var template;\n      template = this.template();\n      $(this.el).html(template(this.model));\n      this.switchToSnippet();\n      this.isParam = this.model.isParam;\n      if (this.isParam) {\n        $('.notice', $(this.el)).text('Click to set as parameter value');\n      }\n      return this;\n    };\n\n    SignatureView.prototype.template = function() {\n      return Handlebars.templates.signature;\n    };\n\n    SignatureView.prototype.switchToDescription = function(e) {\n      if (e != null) {\n        e.preventDefault();\n      }\n      $(\".snippet\", $(this.el)).hide();\n      $(\".description\", $(this.el)).show();\n      $('.description-link', $(this.el)).addClass('selected');\n      return $('.snippet-link', $(this.el)).removeClass('selected');\n    };\n\n    SignatureView.prototype.switchToSnippet = function(e) {\n      if (e != null) {\n        e.preventDefault();\n      }\n      $(\".description\", $(this.el)).hide();\n      $(\".snippet\", $(this.el)).show();\n      $('.snippet-link', $(this.el)).addClass('selected');\n      return $('.description-link', $(this.el)).removeClass('selected');\n    };\n\n    SignatureView.prototype.snippetToTextArea = function(e) {\n      var textArea;\n      if (this.isParam) {\n        if (e != null) {\n          e.preventDefault();\n        }\n        textArea = $('textarea', $(this.el.parentNode.parentNode.parentNode));\n        if ($.trim(textArea.val()) === '') {\n          return textArea.val(this.model.sampleJSON);\n        }\n      }\n    };\n\n    return SignatureView;\n\n  })(Backbone.View);\n\n  ContentTypeView = (function(_super) {\n    __extends(ContentTypeView, _super);\n\n    function ContentTypeView() {\n      _ref8 = ContentTypeView.__super__.constructor.apply(this, arguments);\n      return _ref8;\n    }\n\n    ContentTypeView.prototype.initialize = function() {};\n\n    ContentTypeView.prototype.render = function() {\n      var template;\n      template = this.template();\n      $(this.el).html(template(this.model));\n      $('label[for=contentType]', $(this.el)).text('Response Content Type');\n      return this;\n    };\n\n    ContentTypeView.prototype.template = function() {\n      return Handlebars.templates.content_type;\n    };\n\n    return ContentTypeView;\n\n  })(Backbone.View);\n\n  ResponseContentTypeView = (function(_super) {\n    __extends(ResponseContentTypeView, _super);\n\n    function ResponseContentTypeView() {\n      _ref9 = ResponseContentTypeView.__super__.constructor.apply(this, arguments);\n      return _ref9;\n    }\n\n    ResponseContentTypeView.prototype.initialize = function() {};\n\n    ResponseContentTypeView.prototype.render = function() {\n      var template;\n      template = this.template();\n      $(this.el).html(template(this.model));\n      $('label[for=responseContentType]', $(this.el)).text('Response Content Type');\n      return this;\n    };\n\n    ResponseContentTypeView.prototype.template = function() {\n      return Handlebars.templates.response_content_type;\n    };\n\n    return ResponseContentTypeView;\n\n  })(Backbone.View);\n\n  ParameterContentTypeView = (function(_super) {\n    __extends(ParameterContentTypeView, _super);\n\n    function ParameterContentTypeView() {\n      _ref10 = ParameterContentTypeView.__super__.constructor.apply(this, arguments);\n      return _ref10;\n    }\n\n    ParameterContentTypeView.prototype.initialize = function() {};\n\n    ParameterContentTypeView.prototype.render = function() {\n      var template;\n      template = this.template();\n      $(this.el).html(template(this.model));\n      $('label[for=parameterContentType]', $(this.el)).text('Parameter content type:');\n      return this;\n    };\n\n    ParameterContentTypeView.prototype.template = function() {\n      return Handlebars.templates.parameter_content_type;\n    };\n\n    return ParameterContentTypeView;\n\n  })(Backbone.View);\n\n  ApiKeyButton = (function(_super) {\n    __extends(ApiKeyButton, _super);\n\n    function ApiKeyButton() {\n      _ref11 = ApiKeyButton.__super__.constructor.apply(this, arguments);\n      return _ref11;\n    }\n\n    ApiKeyButton.prototype.initialize = function() {};\n\n    ApiKeyButton.prototype.render = function() {\n      var template;\n      template = this.template();\n      $(this.el).html(template(this.model));\n      return this;\n    };\n\n    ApiKeyButton.prototype.events = {\n      \"click #apikey_button\": \"toggleApiKeyContainer\",\n      \"click #apply_api_key\": \"applyApiKey\"\n    };\n\n    ApiKeyButton.prototype.applyApiKey = function() {\n      var elem;\n      window.authorizations.add(this.model.name, new ApiKeyAuthorization(this.model.name, $(\"#input_apiKey_entry\").val(), this.model[\"in\"]));\n      window.swaggerUi.load();\n      return elem = $('#apikey_container').show();\n    };\n\n    ApiKeyButton.prototype.toggleApiKeyContainer = function() {\n      var elem;\n      if ($('#apikey_container').length > 0) {\n        elem = $('#apikey_container').first();\n        if (elem.is(':visible')) {\n          return elem.hide();\n        } else {\n          $('.auth_container').hide();\n          return elem.show();\n        }\n      }\n    };\n\n    ApiKeyButton.prototype.template = function() {\n      return Handlebars.templates.apikey_button_view;\n    };\n\n    return ApiKeyButton;\n\n  })(Backbone.View);\n\n  BasicAuthButton = (function(_super) {\n    __extends(BasicAuthButton, _super);\n\n    function BasicAuthButton() {\n      _ref12 = BasicAuthButton.__super__.constructor.apply(this, arguments);\n      return _ref12;\n    }\n\n    BasicAuthButton.prototype.initialize = function() {};\n\n    BasicAuthButton.prototype.render = function() {\n      var template;\n      template = this.template();\n      $(this.el).html(template(this.model));\n      return this;\n    };\n\n    BasicAuthButton.prototype.events = {\n      \"click #basic_auth_button\": \"togglePasswordContainer\",\n      \"click #apply_basic_auth\": \"applyPassword\"\n    };\n\n    BasicAuthButton.prototype.applyPassword = function() {\n      var elem, password, username;\n      console.log(\"applying password\");\n      username = $(\".input_username\").val();\n      password = $(\".input_password\").val();\n      window.authorizations.add(this.model.type, new PasswordAuthorization(\"basic\", username, password));\n      window.swaggerUi.load();\n      return elem = $('#basic_auth_container').hide();\n    };\n\n    BasicAuthButton.prototype.togglePasswordContainer = function() {\n      var elem;\n      if ($('#basic_auth_container').length > 0) {\n        elem = $('#basic_auth_container').show();\n        if (elem.is(':visible')) {\n          return elem.slideUp();\n        } else {\n          $('.auth_container').hide();\n          return elem.show();\n        }\n      }\n    };\n\n    BasicAuthButton.prototype.template = function() {\n      return Handlebars.templates.basic_auth_button_view;\n    };\n\n    return BasicAuthButton;\n\n  })(Backbone.View);\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/swagger-ui/lib/handlebars-1.0.0.js":"/*\n\nCopyright (C) 2011 by Yehuda Katz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// lib/handlebars/browser-prefix.js\nvar Handlebars = {};\n\n(function(Handlebars, undefined) {\n;\n// lib/handlebars/base.js\n\nHandlebars.VERSION = \"1.0.0\";\nHandlebars.COMPILER_REVISION = 4;\n\nHandlebars.REVISION_CHANGES = {\n  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it\n  2: '== 1.0.0-rc.3',\n  3: '== 1.0.0-rc.4',\n  4: '>= 1.0.0'\n};\n\nHandlebars.helpers  = {};\nHandlebars.partials = {};\n\nvar toString = Object.prototype.toString,\n    functionType = '[object Function]',\n    objectType = '[object Object]';\n\nHandlebars.registerHelper = function(name, fn, inverse) {\n  if (toString.call(name) === objectType) {\n    if (inverse || fn) { throw new Handlebars.Exception('Arg not supported with multiple helpers'); }\n    Handlebars.Utils.extend(this.helpers, name);\n  } else {\n    if (inverse) { fn.not = inverse; }\n    this.helpers[name] = fn;\n  }\n};\n\nHandlebars.registerPartial = function(name, str) {\n  if (toString.call(name) === objectType) {\n    Handlebars.Utils.extend(this.partials,  name);\n  } else {\n    this.partials[name] = str;\n  }\n};\n\nHandlebars.registerHelper('helperMissing', function(arg) {\n  if(arguments.length === 2) {\n    return undefined;\n  } else {\n    throw new Error(\"Missing helper: '\" + arg + \"'\");\n  }\n});\n\nHandlebars.registerHelper('blockHelperMissing', function(context, options) {\n  var inverse = options.inverse || function() {}, fn = options.fn;\n\n  var type = toString.call(context);\n\n  if(type === functionType) { context = context.call(this); }\n\n  if(context === true) {\n    return fn(this);\n  } else if(context === false || context == null) {\n    return inverse(this);\n  } else if(type === \"[object Array]\") {\n    if(context.length > 0) {\n      return Handlebars.helpers.each(context, options);\n    } else {\n      return inverse(this);\n    }\n  } else {\n    return fn(context);\n  }\n});\n\nHandlebars.K = function() {};\n\nHandlebars.createFrame = Object.create || function(object) {\n  Handlebars.K.prototype = object;\n  var obj = new Handlebars.K();\n  Handlebars.K.prototype = null;\n  return obj;\n};\n\nHandlebars.logger = {\n  DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, level: 3,\n\n  methodMap: {0: 'debug', 1: 'info', 2: 'warn', 3: 'error'},\n\n  // can be overridden in the host environment\n  log: function(level, obj) {\n    if (Handlebars.logger.level <= level) {\n      var method = Handlebars.logger.methodMap[level];\n      if (typeof console !== 'undefined' && console[method]) {\n        console[method].call(console, obj);\n      }\n    }\n  }\n};\n\nHandlebars.log = function(level, obj) { Handlebars.logger.log(level, obj); };\n\nHandlebars.registerHelper('each', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  var i = 0, ret = \"\", data;\n\n  var type = toString.call(context);\n  if(type === functionType) { context = context.call(this); }\n\n  if (options.data) {\n    data = Handlebars.createFrame(options.data);\n  }\n\n  if(context && typeof context === 'object') {\n    if(context instanceof Array){\n      for(var j = context.length; i<j; i++) {\n        if (data) { data.index = i; }\n        ret = ret + fn(context[i], { data: data });\n      }\n    } else {\n      for(var key in context) {\n        if(context.hasOwnProperty(key)) {\n          if(data) { data.key = key; }\n          ret = ret + fn(context[key], {data: data});\n          i++;\n        }\n      }\n    }\n  }\n\n  if(i === 0){\n    ret = inverse(this);\n  }\n\n  return ret;\n});\n\nHandlebars.registerHelper('if', function(conditional, options) {\n  var type = toString.call(conditional);\n  if(type === functionType) { conditional = conditional.call(this); }\n\n  if(!conditional || Handlebars.Utils.isEmpty(conditional)) {\n    return options.inverse(this);\n  } else {\n    return options.fn(this);\n  }\n});\n\nHandlebars.registerHelper('unless', function(conditional, options) {\n  return Handlebars.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn});\n});\n\nHandlebars.registerHelper('with', function(context, options) {\n  var type = toString.call(context);\n  if(type === functionType) { context = context.call(this); }\n\n  if (!Handlebars.Utils.isEmpty(context)) return options.fn(context);\n});\n\nHandlebars.registerHelper('log', function(context, options) {\n  var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;\n  Handlebars.log(level, context);\n});\n;\n// lib/handlebars/compiler/parser.js\n/* Jison generated parser */\nvar handlebars = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"program\":4,\"EOF\":5,\"simpleInverse\":6,\"statements\":7,\"statement\":8,\"openInverse\":9,\"closeBlock\":10,\"openBlock\":11,\"mustache\":12,\"partial\":13,\"CONTENT\":14,\"COMMENT\":15,\"OPEN_BLOCK\":16,\"inMustache\":17,\"CLOSE\":18,\"OPEN_INVERSE\":19,\"OPEN_ENDBLOCK\":20,\"path\":21,\"OPEN\":22,\"OPEN_UNESCAPED\":23,\"CLOSE_UNESCAPED\":24,\"OPEN_PARTIAL\":25,\"partialName\":26,\"params\":27,\"hash\":28,\"dataName\":29,\"param\":30,\"STRING\":31,\"INTEGER\":32,\"BOOLEAN\":33,\"hashSegments\":34,\"hashSegment\":35,\"ID\":36,\"EQUALS\":37,\"DATA\":38,\"pathSegments\":39,\"SEP\":40,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",14:\"CONTENT\",15:\"COMMENT\",16:\"OPEN_BLOCK\",18:\"CLOSE\",19:\"OPEN_INVERSE\",20:\"OPEN_ENDBLOCK\",22:\"OPEN\",23:\"OPEN_UNESCAPED\",24:\"CLOSE_UNESCAPED\",25:\"OPEN_PARTIAL\",31:\"STRING\",32:\"INTEGER\",33:\"BOOLEAN\",36:\"ID\",37:\"EQUALS\",38:\"DATA\",40:\"SEP\"},\nproductions_: [0,[3,2],[4,2],[4,3],[4,2],[4,1],[4,1],[4,0],[7,1],[7,2],[8,3],[8,3],[8,1],[8,1],[8,1],[8,1],[11,3],[9,3],[10,3],[12,3],[12,3],[13,3],[13,4],[6,2],[17,3],[17,2],[17,2],[17,1],[17,1],[27,2],[27,1],[30,1],[30,1],[30,1],[30,1],[30,1],[28,1],[34,2],[34,1],[35,3],[35,3],[35,3],[35,3],[35,3],[26,1],[26,1],[26,1],[29,2],[21,1],[39,3],[39,1]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: return $$[$0-1]; \nbreak;\ncase 2: this.$ = new yy.ProgramNode([], $$[$0]); \nbreak;\ncase 3: this.$ = new yy.ProgramNode($$[$0-2], $$[$0]); \nbreak;\ncase 4: this.$ = new yy.ProgramNode($$[$0-1], []); \nbreak;\ncase 5: this.$ = new yy.ProgramNode($$[$0]); \nbreak;\ncase 6: this.$ = new yy.ProgramNode([], []); \nbreak;\ncase 7: this.$ = new yy.ProgramNode([]); \nbreak;\ncase 8: this.$ = [$$[$0]]; \nbreak;\ncase 9: $$[$0-1].push($$[$0]); this.$ = $$[$0-1]; \nbreak;\ncase 10: this.$ = new yy.BlockNode($$[$0-2], $$[$0-1].inverse, $$[$0-1], $$[$0]); \nbreak;\ncase 11: this.$ = new yy.BlockNode($$[$0-2], $$[$0-1], $$[$0-1].inverse, $$[$0]); \nbreak;\ncase 12: this.$ = $$[$0]; \nbreak;\ncase 13: this.$ = $$[$0]; \nbreak;\ncase 14: this.$ = new yy.ContentNode($$[$0]); \nbreak;\ncase 15: this.$ = new yy.CommentNode($$[$0]); \nbreak;\ncase 16: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]); \nbreak;\ncase 17: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]); \nbreak;\ncase 18: this.$ = $$[$0-1]; \nbreak;\ncase 19:\n    // Parsing out the '&' escape token at this level saves ~500 bytes after min due to the removal of one parser node.\n    this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1], $$[$0-2][2] === '&');\n  \nbreak;\ncase 20: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1], true); \nbreak;\ncase 21: this.$ = new yy.PartialNode($$[$0-1]); \nbreak;\ncase 22: this.$ = new yy.PartialNode($$[$0-2], $$[$0-1]); \nbreak;\ncase 23: \nbreak;\ncase 24: this.$ = [[$$[$0-2]].concat($$[$0-1]), $$[$0]]; \nbreak;\ncase 25: this.$ = [[$$[$0-1]].concat($$[$0]), null]; \nbreak;\ncase 26: this.$ = [[$$[$0-1]], $$[$0]]; \nbreak;\ncase 27: this.$ = [[$$[$0]], null]; \nbreak;\ncase 28: this.$ = [[$$[$0]], null]; \nbreak;\ncase 29: $$[$0-1].push($$[$0]); this.$ = $$[$0-1]; \nbreak;\ncase 30: this.$ = [$$[$0]]; \nbreak;\ncase 31: this.$ = $$[$0]; \nbreak;\ncase 32: this.$ = new yy.StringNode($$[$0]); \nbreak;\ncase 33: this.$ = new yy.IntegerNode($$[$0]); \nbreak;\ncase 34: this.$ = new yy.BooleanNode($$[$0]); \nbreak;\ncase 35: this.$ = $$[$0]; \nbreak;\ncase 36: this.$ = new yy.HashNode($$[$0]); \nbreak;\ncase 37: $$[$0-1].push($$[$0]); this.$ = $$[$0-1]; \nbreak;\ncase 38: this.$ = [$$[$0]]; \nbreak;\ncase 39: this.$ = [$$[$0-2], $$[$0]]; \nbreak;\ncase 40: this.$ = [$$[$0-2], new yy.StringNode($$[$0])]; \nbreak;\ncase 41: this.$ = [$$[$0-2], new yy.IntegerNode($$[$0])]; \nbreak;\ncase 42: this.$ = [$$[$0-2], new yy.BooleanNode($$[$0])]; \nbreak;\ncase 43: this.$ = [$$[$0-2], $$[$0]]; \nbreak;\ncase 44: this.$ = new yy.PartialNameNode($$[$0]); \nbreak;\ncase 45: this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0])); \nbreak;\ncase 46: this.$ = new yy.PartialNameNode(new yy.IntegerNode($$[$0])); \nbreak;\ncase 47: this.$ = new yy.DataNode($$[$0]); \nbreak;\ncase 48: this.$ = new yy.IdNode($$[$0]); \nbreak;\ncase 49: $$[$0-2].push({part: $$[$0], separator: $$[$0-1]}); this.$ = $$[$0-2]; \nbreak;\ncase 50: this.$ = [{part: $$[$0]}]; \nbreak;\n}\n},\ntable: [{3:1,4:2,5:[2,7],6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],22:[1,14],23:[1,15],25:[1,16]},{1:[3]},{5:[1,17]},{5:[2,6],7:18,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,6],22:[1,14],23:[1,15],25:[1,16]},{5:[2,5],6:20,8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,5],22:[1,14],23:[1,15],25:[1,16]},{17:23,18:[1,22],21:24,29:25,36:[1,28],38:[1,27],39:26},{5:[2,8],14:[2,8],15:[2,8],16:[2,8],19:[2,8],20:[2,8],22:[2,8],23:[2,8],25:[2,8]},{4:29,6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,7],22:[1,14],23:[1,15],25:[1,16]},{4:30,6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,7],22:[1,14],23:[1,15],25:[1,16]},{5:[2,12],14:[2,12],15:[2,12],16:[2,12],19:[2,12],20:[2,12],22:[2,12],23:[2,12],25:[2,12]},{5:[2,13],14:[2,13],15:[2,13],16:[2,13],19:[2,13],20:[2,13],22:[2,13],23:[2,13],25:[2,13]},{5:[2,14],14:[2,14],15:[2,14],16:[2,14],19:[2,14],20:[2,14],22:[2,14],23:[2,14],25:[2,14]},{5:[2,15],14:[2,15],15:[2,15],16:[2,15],19:[2,15],20:[2,15],22:[2,15],23:[2,15],25:[2,15]},{17:31,21:24,29:25,36:[1,28],38:[1,27],39:26},{17:32,21:24,29:25,36:[1,28],38:[1,27],39:26},{17:33,21:24,29:25,36:[1,28],38:[1,27],39:26},{21:35,26:34,31:[1,36],32:[1,37],36:[1,28],39:26},{1:[2,1]},{5:[2,2],8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,2],22:[1,14],23:[1,15],25:[1,16]},{17:23,21:24,29:25,36:[1,28],38:[1,27],39:26},{5:[2,4],7:38,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,4],22:[1,14],23:[1,15],25:[1,16]},{5:[2,9],14:[2,9],15:[2,9],16:[2,9],19:[2,9],20:[2,9],22:[2,9],23:[2,9],25:[2,9]},{5:[2,23],14:[2,23],15:[2,23],16:[2,23],19:[2,23],20:[2,23],22:[2,23],23:[2,23],25:[2,23]},{18:[1,39]},{18:[2,27],21:44,24:[2,27],27:40,28:41,29:48,30:42,31:[1,45],32:[1,46],33:[1,47],34:43,35:49,36:[1,50],38:[1,27],39:26},{18:[2,28],24:[2,28]},{18:[2,48],24:[2,48],31:[2,48],32:[2,48],33:[2,48],36:[2,48],38:[2,48],40:[1,51]},{21:52,36:[1,28],39:26},{18:[2,50],24:[2,50],31:[2,50],32:[2,50],33:[2,50],36:[2,50],38:[2,50],40:[2,50]},{10:53,20:[1,54]},{10:55,20:[1,54]},{18:[1,56]},{18:[1,57]},{24:[1,58]},{18:[1,59],21:60,36:[1,28],39:26},{18:[2,44],36:[2,44]},{18:[2,45],36:[2,45]},{18:[2,46],36:[2,46]},{5:[2,3],8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,3],22:[1,14],23:[1,15],25:[1,16]},{14:[2,17],15:[2,17],16:[2,17],19:[2,17],20:[2,17],22:[2,17],23:[2,17],25:[2,17]},{18:[2,25],21:44,24:[2,25],28:61,29:48,30:62,31:[1,45],32:[1,46],33:[1,47],34:43,35:49,36:[1,50],38:[1,27],39:26},{18:[2,26],24:[2,26]},{18:[2,30],24:[2,30],31:[2,30],32:[2,30],33:[2,30],36:[2,30],38:[2,30]},{18:[2,36],24:[2,36],35:63,36:[1,64]},{18:[2,31],24:[2,31],31:[2,31],32:[2,31],33:[2,31],36:[2,31],38:[2,31]},{18:[2,32],24:[2,32],31:[2,32],32:[2,32],33:[2,32],36:[2,32],38:[2,32]},{18:[2,33],24:[2,33],31:[2,33],32:[2,33],33:[2,33],36:[2,33],38:[2,33]},{18:[2,34],24:[2,34],31:[2,34],32:[2,34],33:[2,34],36:[2,34],38:[2,34]},{18:[2,35],24:[2,35],31:[2,35],32:[2,35],33:[2,35],36:[2,35],38:[2,35]},{18:[2,38],24:[2,38],36:[2,38]},{18:[2,50],24:[2,50],31:[2,50],32:[2,50],33:[2,50],36:[2,50],37:[1,65],38:[2,50],40:[2,50]},{36:[1,66]},{18:[2,47],24:[2,47],31:[2,47],32:[2,47],33:[2,47],36:[2,47],38:[2,47]},{5:[2,10],14:[2,10],15:[2,10],16:[2,10],19:[2,10],20:[2,10],22:[2,10],23:[2,10],25:[2,10]},{21:67,36:[1,28],39:26},{5:[2,11],14:[2,11],15:[2,11],16:[2,11],19:[2,11],20:[2,11],22:[2,11],23:[2,11],25:[2,11]},{14:[2,16],15:[2,16],16:[2,16],19:[2,16],20:[2,16],22:[2,16],23:[2,16],25:[2,16]},{5:[2,19],14:[2,19],15:[2,19],16:[2,19],19:[2,19],20:[2,19],22:[2,19],23:[2,19],25:[2,19]},{5:[2,20],14:[2,20],15:[2,20],16:[2,20],19:[2,20],20:[2,20],22:[2,20],23:[2,20],25:[2,20]},{5:[2,21],14:[2,21],15:[2,21],16:[2,21],19:[2,21],20:[2,21],22:[2,21],23:[2,21],25:[2,21]},{18:[1,68]},{18:[2,24],24:[2,24]},{18:[2,29],24:[2,29],31:[2,29],32:[2,29],33:[2,29],36:[2,29],38:[2,29]},{18:[2,37],24:[2,37],36:[2,37]},{37:[1,65]},{21:69,29:73,31:[1,70],32:[1,71],33:[1,72],36:[1,28],38:[1,27],39:26},{18:[2,49],24:[2,49],31:[2,49],32:[2,49],33:[2,49],36:[2,49],38:[2,49],40:[2,49]},{18:[1,74]},{5:[2,22],14:[2,22],15:[2,22],16:[2,22],19:[2,22],20:[2,22],22:[2,22],23:[2,22],25:[2,22]},{18:[2,39],24:[2,39],36:[2,39]},{18:[2,40],24:[2,40],36:[2,40]},{18:[2,41],24:[2,41],36:[2,41]},{18:[2,42],24:[2,42],36:[2,42]},{18:[2,43],24:[2,43],36:[2,43]},{5:[2,18],14:[2,18],15:[2,18],16:[2,18],19:[2,18],20:[2,18],22:[2,18],23:[2,18],25:[2,18]}],\ndefaultActions: {17:[2,1]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n    if (typeof this.lexer.yylloc == \"undefined\")\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n    if (typeof this.yy.parseError === \"function\")\n        this.parseError = this.yy.parseError;\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1;\n        if (typeof token !== \"number\") {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == \"undefined\") {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n            var errStr = \"\";\n            if (!recovering) {\n                expected = [];\n                for (p in table[state])\n                    if (this.terminals_[p] && p > 2) {\n                        expected.push(\"'\" + this.terminals_[p] + \"'\");\n                    }\n                if (this.lexer.showPosition) {\n                    errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n                } else {\n                    errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == 1?\"end of input\":\"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n                }\n                this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(this.lexer.yytext);\n            lstack.push(this.lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                if (recovering > 0)\n                    recovering--;\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};\n            if (ranges) {\n                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n            }\n            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n            if (typeof r !== \"undefined\") {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}\n};\n/* Jison generated lexer */\nvar lexer = (function(){\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        if (this.options.ranges) this.yylloc.range = [0,0];\n        this.offset = 0;\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) this.yylloc.range[1]++;\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length-len-1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length-1);\n        this.matched = this.matched.substr(0, this.matched.length-1);\n\n        if (lines.length-1) this.yylineno -= lines.length-1;\n        var r = this.yylloc.range;\n\n        this.yylloc = {first_line: this.yylloc.first_line,\n          last_line: this.yylineno+1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ?\n              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:\n              this.yylloc.first_column - len\n          };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            tempMatch,\n            index,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (!this.options.flex) break;\n            }\n        }\n        if (match) {\n            lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n            if (lines) this.yylineno += lines.length;\n            this.yylloc = {first_line: this.yylloc.last_line,\n                           last_line: this.yylineno+1,\n                           first_column: this.yylloc.last_column,\n                           last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length};\n            this.yytext += match[0];\n            this.match += match[0];\n            this.matches = match;\n            this.yyleng = this.yytext.length;\n            if (this.options.ranges) {\n                this.yylloc.range = [this.offset, this.offset += this.yyleng];\n            }\n            this._more = false;\n            this._input = this._input.slice(match[0].length);\n            this.matched += match[0];\n            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);\n            if (this.done && this._input) this.done = false;\n            if (token) return token;\n            else return;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(),\n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.options = {};\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START\nswitch($avoiding_name_collisions) {\ncase 0: yy_.yytext = \"\\\\\"; return 14; \nbreak;\ncase 1:\n                                   if(yy_.yytext.slice(-1) !== \"\\\\\") this.begin(\"mu\");\n                                   if(yy_.yytext.slice(-1) === \"\\\\\") yy_.yytext = yy_.yytext.substr(0,yy_.yyleng-1), this.begin(\"emu\");\n                                   if(yy_.yytext) return 14;\n                                 \nbreak;\ncase 2: return 14; \nbreak;\ncase 3:\n                                   if(yy_.yytext.slice(-1) !== \"\\\\\") this.popState();\n                                   if(yy_.yytext.slice(-1) === \"\\\\\") yy_.yytext = yy_.yytext.substr(0,yy_.yyleng-1);\n                                   return 14;\n                                 \nbreak;\ncase 4: yy_.yytext = yy_.yytext.substr(0, yy_.yyleng-4); this.popState(); return 15; \nbreak;\ncase 5: return 25; \nbreak;\ncase 6: return 16; \nbreak;\ncase 7: return 20; \nbreak;\ncase 8: return 19; \nbreak;\ncase 9: return 19; \nbreak;\ncase 10: return 23; \nbreak;\ncase 11: return 22; \nbreak;\ncase 12: this.popState(); this.begin('com'); \nbreak;\ncase 13: yy_.yytext = yy_.yytext.substr(3,yy_.yyleng-5); this.popState(); return 15; \nbreak;\ncase 14: return 22; \nbreak;\ncase 15: return 37; \nbreak;\ncase 16: return 36; \nbreak;\ncase 17: return 36; \nbreak;\ncase 18: return 40; \nbreak;\ncase 19: /*ignore whitespace*/ \nbreak;\ncase 20: this.popState(); return 24; \nbreak;\ncase 21: this.popState(); return 18; \nbreak;\ncase 22: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\\\\\"/g,'\"'); return 31; \nbreak;\ncase 23: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\\\\'/g,\"'\"); return 31; \nbreak;\ncase 24: return 38; \nbreak;\ncase 25: return 33; \nbreak;\ncase 26: return 33; \nbreak;\ncase 27: return 32; \nbreak;\ncase 28: return 36; \nbreak;\ncase 29: yy_.yytext = yy_.yytext.substr(1, yy_.yyleng-2); return 36; \nbreak;\ncase 30: return 'INVALID'; \nbreak;\ncase 31: return 5; \nbreak;\n}\n};\nlexer.rules = [/^(?:\\\\\\\\(?=(\\{\\{)))/,/^(?:[^\\x00]*?(?=(\\{\\{)))/,/^(?:[^\\x00]+)/,/^(?:[^\\x00]{2,}?(?=(\\{\\{|$)))/,/^(?:[\\s\\S]*?--\\}\\})/,/^(?:\\{\\{>)/,/^(?:\\{\\{#)/,/^(?:\\{\\{\\/)/,/^(?:\\{\\{\\^)/,/^(?:\\{\\{\\s*else\\b)/,/^(?:\\{\\{\\{)/,/^(?:\\{\\{&)/,/^(?:\\{\\{!--)/,/^(?:\\{\\{![\\s\\S]*?\\}\\})/,/^(?:\\{\\{)/,/^(?:=)/,/^(?:\\.(?=[}\\/ ]))/,/^(?:\\.\\.)/,/^(?:[\\/.])/,/^(?:\\s+)/,/^(?:\\}\\}\\})/,/^(?:\\}\\})/,/^(?:\"(\\\\[\"]|[^\"])*\")/,/^(?:'(\\\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=[}\\s]))/,/^(?:false(?=[}\\s]))/,/^(?:-?[0-9]+(?=[}\\s]))/,/^(?:[^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+(?=[=}\\s\\/.]))/,/^(?:\\[[^\\]]*\\])/,/^(?:.)/,/^(?:$)/];\nlexer.conditions = {\"mu\":{\"rules\":[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31],\"inclusive\":false},\"emu\":{\"rules\":[3],\"inclusive\":false},\"com\":{\"rules\":[4],\"inclusive\":false},\"INITIAL\":{\"rules\":[0,1,2,31],\"inclusive\":true}};\nreturn lexer;})()\nparser.lexer = lexer;\nfunction Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();;\n// lib/handlebars/compiler/base.js\n\nHandlebars.Parser = handlebars;\n\nHandlebars.parse = function(input) {\n\n  // Just return if an already-compile AST was passed in.\n  if(input.constructor === Handlebars.AST.ProgramNode) { return input; }\n\n  Handlebars.Parser.yy = Handlebars.AST;\n  return Handlebars.Parser.parse(input);\n};\n;\n// lib/handlebars/compiler/ast.js\nHandlebars.AST = {};\n\nHandlebars.AST.ProgramNode = function(statements, inverse) {\n  this.type = \"program\";\n  this.statements = statements;\n  if(inverse) { this.inverse = new Handlebars.AST.ProgramNode(inverse); }\n};\n\nHandlebars.AST.MustacheNode = function(rawParams, hash, unescaped) {\n  this.type = \"mustache\";\n  this.escaped = !unescaped;\n  this.hash = hash;\n\n  var id = this.id = rawParams[0];\n  var params = this.params = rawParams.slice(1);\n\n  // a mustache is an eligible helper if:\n  // * its id is simple (a single part, not `this` or `..`)\n  var eligibleHelper = this.eligibleHelper = id.isSimple;\n\n  // a mustache is definitely a helper if:\n  // * it is an eligible helper, and\n  // * it has at least one parameter or hash segment\n  this.isHelper = eligibleHelper && (params.length || hash);\n\n  // if a mustache is an eligible helper but not a definite\n  // helper, it is ambiguous, and will be resolved in a later\n  // pass or at runtime.\n};\n\nHandlebars.AST.PartialNode = function(partialName, context) {\n  this.type         = \"partial\";\n  this.partialName  = partialName;\n  this.context      = context;\n};\n\nHandlebars.AST.BlockNode = function(mustache, program, inverse, close) {\n  var verifyMatch = function(open, close) {\n    if(open.original !== close.original) {\n      throw new Handlebars.Exception(open.original + \" doesn't match \" + close.original);\n    }\n  };\n\n  verifyMatch(mustache.id, close);\n  this.type = \"block\";\n  this.mustache = mustache;\n  this.program  = program;\n  this.inverse  = inverse;\n\n  if (this.inverse && !this.program) {\n    this.isInverse = true;\n  }\n};\n\nHandlebars.AST.ContentNode = function(string) {\n  this.type = \"content\";\n  this.string = string;\n};\n\nHandlebars.AST.HashNode = function(pairs) {\n  this.type = \"hash\";\n  this.pairs = pairs;\n};\n\nHandlebars.AST.IdNode = function(parts) {\n  this.type = \"ID\";\n\n  var original = \"\",\n      dig = [],\n      depth = 0;\n\n  for(var i=0,l=parts.length; i<l; i++) {\n    var part = parts[i].part;\n    original += (parts[i].separator || '') + part;\n\n    if (part === \"..\" || part === \".\" || part === \"this\") {\n      if (dig.length > 0) { throw new Handlebars.Exception(\"Invalid path: \" + original); }\n      else if (part === \"..\") { depth++; }\n      else { this.isScoped = true; }\n    }\n    else { dig.push(part); }\n  }\n\n  this.original = original;\n  this.parts    = dig;\n  this.string   = dig.join('.');\n  this.depth    = depth;\n\n  // an ID is simple if it only has one part, and that part is not\n  // `..` or `this`.\n  this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;\n\n  this.stringModeValue = this.string;\n};\n\nHandlebars.AST.PartialNameNode = function(name) {\n  this.type = \"PARTIAL_NAME\";\n  this.name = name.original;\n};\n\nHandlebars.AST.DataNode = function(id) {\n  this.type = \"DATA\";\n  this.id = id;\n};\n\nHandlebars.AST.StringNode = function(string) {\n  this.type = \"STRING\";\n  this.original =\n    this.string =\n    this.stringModeValue = string;\n};\n\nHandlebars.AST.IntegerNode = function(integer) {\n  this.type = \"INTEGER\";\n  this.original =\n    this.integer = integer;\n  this.stringModeValue = Number(integer);\n};\n\nHandlebars.AST.BooleanNode = function(bool) {\n  this.type = \"BOOLEAN\";\n  this.bool = bool;\n  this.stringModeValue = bool === \"true\";\n};\n\nHandlebars.AST.CommentNode = function(comment) {\n  this.type = \"comment\";\n  this.comment = comment;\n};\n;\n// lib/handlebars/utils.js\n\nvar errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\nHandlebars.Exception = function(message) {\n  var tmp = Error.prototype.constructor.apply(this, arguments);\n\n  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n  for (var idx = 0; idx < errorProps.length; idx++) {\n    this[errorProps[idx]] = tmp[errorProps[idx]];\n  }\n};\nHandlebars.Exception.prototype = new Error();\n\n// Build out our basic SafeString type\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n\nvar escape = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#x27;\",\n  \"`\": \"&#x60;\"\n};\n\nvar badChars = /[&<>\"'`]/g;\nvar possible = /[&<>\"'`]/;\n\nvar escapeChar = function(chr) {\n  return escape[chr] || \"&amp;\";\n};\n\nHandlebars.Utils = {\n  extend: function(obj, value) {\n    for(var key in value) {\n      if(value.hasOwnProperty(key)) {\n        obj[key] = value[key];\n      }\n    }\n  },\n\n  escapeExpression: function(string) {\n    // don't escape SafeStrings, since they're already safe\n    if (string instanceof Handlebars.SafeString) {\n      return string.toString();\n    } else if (string == null || string === false) {\n      return \"\";\n    }\n\n    // Force a string conversion as this will be done by the append regardless and\n    // the regex test will do this transparently behind the scenes, causing issues if\n    // an object's to string has escaped characters in it.\n    string = string.toString();\n\n    if(!possible.test(string)) { return string; }\n    return string.replace(badChars, escapeChar);\n  },\n\n  isEmpty: function(value) {\n    if (!value && value !== 0) {\n      return true;\n    } else if(toString.call(value) === \"[object Array]\" && value.length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n;\n// lib/handlebars/compiler/compiler.js\n\n/*jshint eqnull:true*/\nvar Compiler = Handlebars.Compiler = function() {};\nvar JavaScriptCompiler = Handlebars.JavaScriptCompiler = function() {};\n\n// the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\nCompiler.prototype = {\n  compiler: Compiler,\n\n  disassemble: function() {\n    var opcodes = this.opcodes, opcode, out = [], params, param;\n\n    for (var i=0, l=opcodes.length; i<l; i++) {\n      opcode = opcodes[i];\n\n      if (opcode.opcode === 'DECLARE') {\n        out.push(\"DECLARE \" + opcode.name + \"=\" + opcode.value);\n      } else {\n        params = [];\n        for (var j=0; j<opcode.args.length; j++) {\n          param = opcode.args[j];\n          if (typeof param === \"string\") {\n            param = \"\\\"\" + param.replace(\"\\n\", \"\\\\n\") + \"\\\"\";\n          }\n          params.push(param);\n        }\n        out.push(opcode.opcode + \" \" + params.join(\" \"));\n      }\n    }\n\n    return out.join(\"\\n\");\n  },\n  equals: function(other) {\n    var len = this.opcodes.length;\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (var i = 0; i < len; i++) {\n      var opcode = this.opcodes[i],\n          otherOpcode = other.opcodes[i];\n      if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) {\n        return false;\n      }\n      for (var j = 0; j < opcode.args.length; j++) {\n        if (opcode.args[j] !== otherOpcode.args[j]) {\n          return false;\n        }\n      }\n    }\n\n    len = this.children.length;\n    if (other.children.length !== len) {\n      return false;\n    }\n    for (i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  guid: 0,\n\n  compile: function(program, options) {\n    this.children = [];\n    this.depths = {list: []};\n    this.options = options;\n\n    // These changes will propagate to the other compiler components\n    var knownHelpers = this.options.knownHelpers;\n    this.options.knownHelpers = {\n      'helperMissing': true,\n      'blockHelperMissing': true,\n      'each': true,\n      'if': true,\n      'unless': true,\n      'with': true,\n      'log': true\n    };\n    if (knownHelpers) {\n      for (var name in knownHelpers) {\n        this.options.knownHelpers[name] = knownHelpers[name];\n      }\n    }\n\n    return this.program(program);\n  },\n\n  accept: function(node) {\n    return this[node.type](node);\n  },\n\n  program: function(program) {\n    var statements = program.statements, statement;\n    this.opcodes = [];\n\n    for(var i=0, l=statements.length; i<l; i++) {\n      statement = statements[i];\n      this[statement.type](statement);\n    }\n    this.isSimple = l === 1;\n\n    this.depths.list = this.depths.list.sort(function(a, b) {\n      return a - b;\n    });\n\n    return this;\n  },\n\n  compileProgram: function(program) {\n    var result = new this.compiler().compile(program, this.options);\n    var guid = this.guid++, depth;\n\n    this.usePartial = this.usePartial || result.usePartial;\n\n    this.children[guid] = result;\n\n    for(var i=0, l=result.depths.list.length; i<l; i++) {\n      depth = result.depths.list[i];\n\n      if(depth < 2) { continue; }\n      else { this.addDepth(depth - 1); }\n    }\n\n    return guid;\n  },\n\n  block: function(block) {\n    var mustache = block.mustache,\n        program = block.program,\n        inverse = block.inverse;\n\n    if (program) {\n      program = this.compileProgram(program);\n    }\n\n    if (inverse) {\n      inverse = this.compileProgram(inverse);\n    }\n\n    var type = this.classifyMustache(mustache);\n\n    if (type === \"helper\") {\n      this.helperMustache(mustache, program, inverse);\n    } else if (type === \"simple\") {\n      this.simpleMustache(mustache);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue');\n    } else {\n      this.ambiguousMustache(mustache, program, inverse);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n\n  hash: function(hash) {\n    var pairs = hash.pairs, pair, val;\n\n    this.opcode('pushHash');\n\n    for(var i=0, l=pairs.length; i<l; i++) {\n      pair = pairs[i];\n      val  = pair[1];\n\n      if (this.options.stringParams) {\n        if(val.depth) {\n          this.addDepth(val.depth);\n        }\n        this.opcode('getContext', val.depth || 0);\n        this.opcode('pushStringParam', val.stringModeValue, val.type);\n      } else {\n        this.accept(val);\n      }\n\n      this.opcode('assignToHash', pair[0]);\n    }\n    this.opcode('popHash');\n  },\n\n  partial: function(partial) {\n    var partialName = partial.partialName;\n    this.usePartial = true;\n\n    if(partial.context) {\n      this.ID(partial.context);\n    } else {\n      this.opcode('push', 'depth0');\n    }\n\n    this.opcode('invokePartial', partialName.name);\n    this.opcode('append');\n  },\n\n  content: function(content) {\n    this.opcode('appendContent', content.string);\n  },\n\n  mustache: function(mustache) {\n    var options = this.options;\n    var type = this.classifyMustache(mustache);\n\n    if (type === \"simple\") {\n      this.simpleMustache(mustache);\n    } else if (type === \"helper\") {\n      this.helperMustache(mustache);\n    } else {\n      this.ambiguousMustache(mustache);\n    }\n\n    if(mustache.escaped && !options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n\n  ambiguousMustache: function(mustache, program, inverse) {\n    var id = mustache.id,\n        name = id.parts[0],\n        isBlock = program != null || inverse != null;\n\n    this.opcode('getContext', id.depth);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n\n  simpleMustache: function(mustache) {\n    var id = mustache.id;\n\n    if (id.type === 'DATA') {\n      this.DATA(id);\n    } else if (id.parts.length) {\n      this.ID(id);\n    } else {\n      // Simplified ID for `this`\n      this.addDepth(id.depth);\n      this.opcode('getContext', id.depth);\n      this.opcode('pushContext');\n    }\n\n    this.opcode('resolvePossibleLambda');\n  },\n\n  helperMustache: function(mustache, program, inverse) {\n    var params = this.setupFullMustacheParams(mustache, program, inverse),\n        name = mustache.id.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new Error(\"You specified knownHelpersOnly, but used the unknown helper \" + name);\n    } else {\n      this.opcode('invokeHelper', params.length, name);\n    }\n  },\n\n  ID: function(id) {\n    this.addDepth(id.depth);\n    this.opcode('getContext', id.depth);\n\n    var name = id.parts[0];\n    if (!name) {\n      this.opcode('pushContext');\n    } else {\n      this.opcode('lookupOnContext', id.parts[0]);\n    }\n\n    for(var i=1, l=id.parts.length; i<l; i++) {\n      this.opcode('lookup', id.parts[i]);\n    }\n  },\n\n  DATA: function(data) {\n    this.options.data = true;\n    if (data.id.isScoped || data.id.depth) {\n      throw new Handlebars.Exception('Scoped data references are not supported: ' + data.original);\n    }\n\n    this.opcode('lookupData');\n    var parts = data.id.parts;\n    for(var i=0, l=parts.length; i<l; i++) {\n      this.opcode('lookup', parts[i]);\n    }\n  },\n\n  STRING: function(string) {\n    this.opcode('pushString', string.string);\n  },\n\n  INTEGER: function(integer) {\n    this.opcode('pushLiteral', integer.integer);\n  },\n\n  BOOLEAN: function(bool) {\n    this.opcode('pushLiteral', bool.bool);\n  },\n\n  comment: function() {},\n\n  // HELPERS\n  opcode: function(name) {\n    this.opcodes.push({ opcode: name, args: [].slice.call(arguments, 1) });\n  },\n\n  declare: function(name, value) {\n    this.opcodes.push({ opcode: 'DECLARE', name: name, value: value });\n  },\n\n  addDepth: function(depth) {\n    if(isNaN(depth)) { throw new Error(\"EWOT\"); }\n    if(depth === 0) { return; }\n\n    if(!this.depths[depth]) {\n      this.depths[depth] = true;\n      this.depths.list.push(depth);\n    }\n  },\n\n  classifyMustache: function(mustache) {\n    var isHelper   = mustache.isHelper;\n    var isEligible = mustache.eligibleHelper;\n    var options    = this.options;\n\n    // if ambiguous, we can possibly resolve the ambiguity now\n    if (isEligible && !isHelper) {\n      var name = mustache.id.parts[0];\n\n      if (options.knownHelpers[name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) { return \"helper\"; }\n    else if (isEligible) { return \"ambiguous\"; }\n    else { return \"simple\"; }\n  },\n\n  pushParams: function(params) {\n    var i = params.length, param;\n\n    while(i--) {\n      param = params[i];\n\n      if(this.options.stringParams) {\n        if(param.depth) {\n          this.addDepth(param.depth);\n        }\n\n        this.opcode('getContext', param.depth || 0);\n        this.opcode('pushStringParam', param.stringModeValue, param.type);\n      } else {\n        this[param.type](param);\n      }\n    }\n  },\n\n  setupMustacheParams: function(mustache) {\n    var params = mustache.params;\n    this.pushParams(params);\n\n    if(mustache.hash) {\n      this.hash(mustache.hash);\n    } else {\n      this.opcode('emptyHash');\n    }\n\n    return params;\n  },\n\n  // this will replace setupMustacheParams when we're done\n  setupFullMustacheParams: function(mustache, program, inverse) {\n    var params = mustache.params;\n    this.pushParams(params);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if(mustache.hash) {\n      this.hash(mustache.hash);\n    } else {\n      this.opcode('emptyHash');\n    }\n\n    return params;\n  }\n};\n\nvar Literal = function(value) {\n  this.value = value;\n};\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function(parent, name /* , type*/) {\n    if (/^[0-9]+$/.test(name)) {\n      return parent + \"[\" + name + \"]\";\n    } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {\n      return parent + \".\" + name;\n    }\n    else {\n      return parent + \"['\" + name + \"']\";\n    }\n  },\n\n  appendToBuffer: function(string) {\n    if (this.environment.isSimple) {\n      return \"return \" + string + \";\";\n    } else {\n      return {\n        appendToBuffer: true,\n        content: string,\n        toString: function() { return \"buffer += \" + string + \";\"; }\n      };\n    }\n  },\n\n  initializeBuffer: function() {\n    return this.quotedString(\"\");\n  },\n\n  namespace: \"Handlebars\",\n  // END PUBLIC API\n\n  compile: function(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options || {};\n\n    Handlebars.log(Handlebars.logger.DEBUG, this.environment.disassemble() + \"\\n\\n\");\n\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      programs: [],\n      environments: [],\n      aliases: { }\n    };\n\n    this.preamble();\n\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.registers = { list: [] };\n    this.compileStack = [];\n    this.inlineStack = [];\n\n    this.compileChildren(environment, options);\n\n    var opcodes = environment.opcodes, opcode;\n\n    this.i = 0;\n\n    for(l=opcodes.length; this.i<l; this.i++) {\n      opcode = opcodes[this.i];\n\n      if(opcode.opcode === 'DECLARE') {\n        this[opcode.name] = opcode.value;\n      } else {\n        this[opcode.opcode].apply(this, opcode.args);\n      }\n    }\n\n    return this.createFunctionContext(asObject);\n  },\n\n  nextOpcode: function() {\n    var opcodes = this.environment.opcodes;\n    return opcodes[this.i + 1];\n  },\n\n  eat: function() {\n    this.i = this.i + 1;\n  },\n\n  preamble: function() {\n    var out = [];\n\n    if (!this.isChild) {\n      var namespace = this.namespace;\n\n      var copies = \"helpers = this.merge(helpers, \" + namespace + \".helpers);\";\n      if (this.environment.usePartial) { copies = copies + \" partials = this.merge(partials, \" + namespace + \".partials);\"; }\n      if (this.options.data) { copies = copies + \" data = data || {};\"; }\n      out.push(copies);\n    } else {\n      out.push('');\n    }\n\n    if (!this.environment.isSimple) {\n      out.push(\", buffer = \" + this.initializeBuffer());\n    } else {\n      out.push(\"\");\n    }\n\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = out;\n  },\n\n  createFunctionContext: function(asObject) {\n    var locals = this.stackVars.concat(this.registers.list);\n\n    if(locals.length > 0) {\n      this.source[1] = this.source[1] + \", \" + locals.join(\", \");\n    }\n\n    // Generate minimizer alias mappings\n    if (!this.isChild) {\n      for (var alias in this.context.aliases) {\n        if (this.context.aliases.hasOwnProperty(alias)) {\n          this.source[1] = this.source[1] + ', ' + alias + '=' + this.context.aliases[alias];\n        }\n      }\n    }\n\n    if (this.source[1]) {\n      this.source[1] = \"var \" + this.source[1].substring(2) + \";\";\n    }\n\n    // Merge children\n    if (!this.isChild) {\n      this.source[1] += '\\n' + this.context.programs.join('\\n') + '\\n';\n    }\n\n    if (!this.environment.isSimple) {\n      this.source.push(\"return buffer;\");\n    }\n\n    var params = this.isChild ? [\"depth0\", \"data\"] : [\"Handlebars\", \"depth0\", \"helpers\", \"partials\", \"data\"];\n\n    for(var i=0, l=this.environment.depths.list.length; i<l; i++) {\n      params.push(\"depth\" + this.environment.depths.list[i]);\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    var source = this.mergeSource();\n\n    if (!this.isChild) {\n      var revision = Handlebars.COMPILER_REVISION,\n          versions = Handlebars.REVISION_CHANGES[revision];\n      source = \"this.compilerInfo = [\"+revision+\",'\"+versions+\"'];\\n\"+source;\n    }\n\n    if (asObject) {\n      params.push(source);\n\n      return Function.apply(this, params);\n    } else {\n      var functionSource = 'function ' + (this.name || '') + '(' + params.join(',') + ') {\\n  ' + source + '}';\n      Handlebars.log(Handlebars.logger.DEBUG, functionSource + \"\\n\\n\");\n      return functionSource;\n    }\n  },\n  mergeSource: function() {\n    // WARN: We are not handling the case where buffer is still populated as the source should\n    // not have buffer append operations as their final action.\n    var source = '',\n        buffer;\n    for (var i = 0, len = this.source.length; i < len; i++) {\n      var line = this.source[i];\n      if (line.appendToBuffer) {\n        if (buffer) {\n          buffer = buffer + '\\n    + ' + line.content;\n        } else {\n          buffer = line.content;\n        }\n      } else {\n        if (buffer) {\n          source += 'buffer += ' + buffer + ';\\n  ';\n          buffer = undefined;\n        }\n        source += line + '\\n  ';\n      }\n    }\n    return source;\n  },\n\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#foo}}...{{/foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function() {\n    this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';\n\n    var params = [\"depth0\"];\n    this.setupParams(0, params);\n\n    this.replaceStack(function(current) {\n      params.splice(1, 0, current);\n      return \"blockHelperMissing.call(\" + params.join(\", \") + \")\";\n    });\n  },\n\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function() {\n    this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';\n\n    var params = [\"depth0\"];\n    this.setupParams(0, params);\n\n    var current = this.topStack();\n    params.splice(1, 0, current);\n\n    // Use the options value generated from the invocation\n    params[params.length-1] = 'options';\n\n    this.source.push(\"if (!\" + this.lastHelper + \") { \" + current + \" = blockHelperMissing.call(\" + params.join(\", \") + \"); }\");\n  },\n\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function(content) {\n    this.source.push(this.appendToBuffer(this.quotedString(content)));\n  },\n\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function() {\n    // Force anything that is inlined onto the stack so we don't have duplication\n    // when we examine local\n    this.flushInline();\n    var local = this.popStack();\n    this.source.push(\"if(\" + local + \" || \" + local + \" === 0) { \" + this.appendToBuffer(local) + \" }\");\n    if (this.environment.isSimple) {\n      this.source.push(\"else { \" + this.appendToBuffer(\"''\") + \" }\");\n    }\n  },\n\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function() {\n    this.context.aliases.escapeExpression = 'this.escapeExpression';\n\n    this.source.push(this.appendToBuffer(\"escapeExpression(\" + this.popStack() + \")\"));\n  },\n\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function(depth) {\n    if(this.lastContext !== depth) {\n      this.lastContext = depth;\n    }\n  },\n\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function(name) {\n    this.push(this.nameLookup('depth' + this.lastContext, name, 'context'));\n  },\n\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function() {\n    this.pushStackLiteral('depth' + this.lastContext);\n  },\n\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function() {\n    this.context.aliases.functionType = '\"function\"';\n\n    this.replaceStack(function(current) {\n      return \"typeof \" + current + \" === functionType ? \" + current + \".apply(depth0) : \" + current;\n    });\n  },\n\n  // [lookup]\n  //\n  // On stack, before: value, ...\n  // On stack, after: value[name], ...\n  //\n  // Replace the value on the stack with the result of looking\n  // up `name` on `value`\n  lookup: function(name) {\n    this.replaceStack(function(current) {\n      return current + \" == null || \" + current + \" === false ? \" + current + \" : \" + this.nameLookup(current, name, 'context');\n    });\n  },\n\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data[id], ...\n  //\n  // Push the result of looking up `id` on the current data\n  lookupData: function(id) {\n    this.push('data');\n  },\n\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function(string, type) {\n    this.pushStackLiteral('depth' + this.lastContext);\n\n    this.pushString(type);\n\n    if (typeof string === 'string') {\n      this.pushString(string);\n    } else {\n      this.pushStackLiteral(string);\n    }\n  },\n\n  emptyHash: function() {\n    this.pushStackLiteral('{}');\n\n    if (this.options.stringParams) {\n      this.register('hashTypes', '{}');\n      this.register('hashContexts', '{}');\n    }\n  },\n  pushHash: function() {\n    this.hash = {values: [], types: [], contexts: []};\n  },\n  popHash: function() {\n    var hash = this.hash;\n    this.hash = undefined;\n\n    if (this.options.stringParams) {\n      this.register('hashContexts', '{' + hash.contexts.join(',') + '}');\n      this.register('hashTypes', '{' + hash.types.join(',') + '}');\n    }\n    this.push('{\\n    ' + hash.values.join(',\\n    ') + '\\n  }');\n  },\n\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n\n  // [push]\n  //\n  // On stack, before: ...\n  // On stack, after: expr, ...\n  //\n  // Push an expression onto the stack\n  push: function(expr) {\n    this.inlineStack.push(expr);\n    return expr;\n  },\n\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function(value) {\n    this.pushStackLiteral(value);\n  },\n\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function(paramSize, name) {\n    this.context.aliases.helperMissing = 'helpers.helperMissing';\n\n    var helper = this.lastHelper = this.setupHelper(paramSize, name, true);\n    var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');\n\n    this.push(helper.name + ' || ' + nonHelper);\n    this.replaceStack(function(name) {\n      return name + ' ? ' + name + '.call(' +\n          helper.callParams + \") \" + \": helperMissing.call(\" +\n          helper.helperMissingParams + \")\";\n    });\n  },\n\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function(paramSize, name) {\n    var helper = this.setupHelper(paramSize, name);\n    this.push(helper.name + \".call(\" + helper.callParams + \")\");\n  },\n\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function(name, helperCall) {\n    this.context.aliases.functionType = '\"function\"';\n\n    this.pushStackLiteral('{}');    // Hash value\n    var helper = this.setupHelper(0, name, helperCall);\n\n    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n\n    var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');\n    var nextStack = this.nextStack();\n\n    this.source.push('if (' + nextStack + ' = ' + helperName + ') { ' + nextStack + ' = ' + nextStack + '.call(' + helper.callParams + '); }');\n    this.source.push('else { ' + nextStack + ' = ' + nonHelper + '; ' + nextStack + ' = typeof ' + nextStack + ' === functionType ? ' + nextStack + '.apply(depth0) : ' + nextStack + '; }');\n  },\n\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function(name) {\n    var params = [this.nameLookup('partials', name, 'partial'), \"'\" + name + \"'\", this.popStack(), \"helpers\", \"partials\"];\n\n    if (this.options.data) {\n      params.push(\"data\");\n    }\n\n    this.context.aliases.self = \"this\";\n    this.push(\"self.invokePartial(\" + params.join(\", \") + \")\");\n  },\n\n  // [assignToHash]\n  //\n  // On stack, before: value, hash, ...\n  // On stack, after: hash, ...\n  //\n  // Pops a value and hash off the stack, assigns `hash[key] = value`\n  // and pushes the hash back onto the stack.\n  assignToHash: function(key) {\n    var value = this.popStack(),\n        context,\n        type;\n\n    if (this.options.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    var hash = this.hash;\n    if (context) {\n      hash.contexts.push(\"'\" + key + \"': \" + context);\n    }\n    if (type) {\n      hash.types.push(\"'\" + key + \"': \" + type);\n    }\n    hash.values.push(\"'\" + key + \"': (\" + value + \")\");\n  },\n\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n\n  compileChildren: function(environment, options) {\n    var children = environment.children, child, compiler;\n\n    for(var i=0, l=children.length; i<l; i++) {\n      child = children[i];\n      compiler = new this.compiler();\n\n      var index = this.matchExistingProgram(child);\n\n      if (index == null) {\n        this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children\n        index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(child, options, this.context);\n        this.context.environments[index] = child;\n      } else {\n        child.index = index;\n        child.name = 'program' + index;\n      }\n    }\n  },\n  matchExistingProgram: function(child) {\n    for (var i = 0, len = this.context.environments.length; i < len; i++) {\n      var environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return i;\n      }\n    }\n  },\n\n  programExpression: function(guid) {\n    this.context.aliases.self = \"this\";\n\n    if(guid == null) {\n      return \"self.noop\";\n    }\n\n    var child = this.environment.children[guid],\n        depths = child.depths.list, depth;\n\n    var programParams = [child.index, child.name, \"data\"];\n\n    for(var i=0, l = depths.length; i<l; i++) {\n      depth = depths[i];\n\n      if(depth === 1) { programParams.push(\"depth0\"); }\n      else { programParams.push(\"depth\" + (depth - 1)); }\n    }\n\n    return (depths.length === 0 ? \"self.program(\" : \"self.programWithDepth(\") + programParams.join(\", \") + \")\";\n  },\n\n  register: function(name, val) {\n    this.useRegister(name);\n    this.source.push(name + \" = \" + val + \";\");\n  },\n\n  useRegister: function(name) {\n    if(!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n\n  pushStackLiteral: function(item) {\n    return this.push(new Literal(item));\n  },\n\n  pushStack: function(item) {\n    this.flushInline();\n\n    var stack = this.incrStack();\n    if (item) {\n      this.source.push(stack + \" = \" + item + \";\");\n    }\n    this.compileStack.push(stack);\n    return stack;\n  },\n\n  replaceStack: function(callback) {\n    var prefix = '',\n        inline = this.isInline(),\n        stack;\n\n    // If we are currently inline then we want to merge the inline statement into the\n    // replacement statement via ','\n    if (inline) {\n      var top = this.popStack(true);\n\n      if (top instanceof Literal) {\n        // Literals do not need to be inlined\n        stack = top.value;\n      } else {\n        // Get or create the current stack name for use by the inline\n        var name = this.stackSlot ? this.topStackName() : this.incrStack();\n\n        prefix = '(' + this.push(name) + ' = ' + top + '),';\n        stack = this.topStack();\n      }\n    } else {\n      stack = this.topStack();\n    }\n\n    var item = callback.call(this, stack);\n\n    if (inline) {\n      if (this.inlineStack.length || this.compileStack.length) {\n        this.popStack();\n      }\n      this.push('(' + prefix + item + ')');\n    } else {\n      // Prevent modification of the context depth variable. Through replaceStack\n      if (!/^stack/.test(stack)) {\n        stack = this.nextStack();\n      }\n\n      this.source.push(stack + \" = (\" + prefix + item + \");\");\n    }\n    return stack;\n  },\n\n  nextStack: function() {\n    return this.pushStack();\n  },\n\n  incrStack: function() {\n    this.stackSlot++;\n    if(this.stackSlot > this.stackVars.length) { this.stackVars.push(\"stack\" + this.stackSlot); }\n    return this.topStackName();\n  },\n  topStackName: function() {\n    return \"stack\" + this.stackSlot;\n  },\n  flushInline: function() {\n    var inlineStack = this.inlineStack;\n    if (inlineStack.length) {\n      this.inlineStack = [];\n      for (var i = 0, len = inlineStack.length; i < len; i++) {\n        var entry = inlineStack[i];\n        if (entry instanceof Literal) {\n          this.compileStack.push(entry);\n        } else {\n          this.pushStack(entry);\n        }\n      }\n    }\n  },\n  isInline: function() {\n    return this.inlineStack.length;\n  },\n\n  popStack: function(wrapped) {\n    var inline = this.isInline(),\n        item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && (item instanceof Literal)) {\n      return item.value;\n    } else {\n      if (!inline) {\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n\n  topStack: function(wrapped) {\n    var stack = (this.isInline() ? this.inlineStack : this.compileStack),\n        item = stack[stack.length - 1];\n\n    if (!wrapped && (item instanceof Literal)) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n\n  quotedString: function(str) {\n    return '\"' + str\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\u2028/g, '\\\\u2028')   // Per Ecma-262 7.3 + 7.8.4\n      .replace(/\\u2029/g, '\\\\u2029') + '\"';\n  },\n\n  setupHelper: function(paramSize, name, missingParams) {\n    var params = [];\n    this.setupParams(paramSize, params, missingParams);\n    var foundHelper = this.nameLookup('helpers', name, 'helper');\n\n    return {\n      params: params,\n      name: foundHelper,\n      callParams: [\"depth0\"].concat(params).join(\", \"),\n      helperMissingParams: missingParams && [\"depth0\", this.quotedString(name)].concat(params).join(\", \")\n    };\n  },\n\n  // the params and contexts arguments are passed in arrays\n  // to fill in\n  setupParams: function(paramSize, params, useRegister) {\n    var options = [], contexts = [], types = [], param, inverse, program;\n\n    options.push(\"hash:\" + this.popStack());\n\n    inverse = this.popStack();\n    program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      if (!program) {\n        this.context.aliases.self = \"this\";\n        program = \"self.noop\";\n      }\n\n      if (!inverse) {\n       this.context.aliases.self = \"this\";\n        inverse = \"self.noop\";\n      }\n\n      options.push(\"inverse:\" + inverse);\n      options.push(\"fn:\" + program);\n    }\n\n    for(var i=0; i<paramSize; i++) {\n      param = this.popStack();\n      params.push(param);\n\n      if(this.options.stringParams) {\n        types.push(this.popStack());\n        contexts.push(this.popStack());\n      }\n    }\n\n    if (this.options.stringParams) {\n      options.push(\"contexts:[\" + contexts.join(\",\") + \"]\");\n      options.push(\"types:[\" + types.join(\",\") + \"]\");\n      options.push(\"hashContexts:hashContexts\");\n      options.push(\"hashTypes:hashTypes\");\n    }\n\n    if(this.options.data) {\n      options.push(\"data:data\");\n    }\n\n    options = \"{\" + options.join(\",\") + \"}\";\n    if (useRegister) {\n      this.register('options', options);\n      params.push('options');\n    } else {\n      params.push(options);\n    }\n    return params.join(\", \");\n  }\n};\n\nvar reservedWords = (\n  \"break else new var\" +\n  \" case finally return void\" +\n  \" catch for switch while\" +\n  \" continue function this with\" +\n  \" default if throw\" +\n  \" delete in try\" +\n  \" do instanceof typeof\" +\n  \" abstract enum int short\" +\n  \" boolean export interface static\" +\n  \" byte extends long super\" +\n  \" char final native synchronized\" +\n  \" class float package throws\" +\n  \" const goto private transient\" +\n  \" debugger implements protected volatile\" +\n  \" double import public let yield\"\n).split(\" \");\n\nvar compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n\nfor(var i=0, l=reservedWords.length; i<l; i++) {\n  compilerWords[reservedWords[i]] = true;\n}\n\nJavaScriptCompiler.isValidJavaScriptVariableName = function(name) {\n  if(!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(name)) {\n    return true;\n  }\n  return false;\n};\n\nHandlebars.precompile = function(input, options) {\n  if (input == null || (typeof input !== 'string' && input.constructor !== Handlebars.AST.ProgramNode)) {\n    throw new Handlebars.Exception(\"You must pass a string or Handlebars AST to Handlebars.precompile. You passed \" + input);\n  }\n\n  options = options || {};\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  var ast = Handlebars.parse(input);\n  var environment = new Compiler().compile(ast, options);\n  return new JavaScriptCompiler().compile(environment, options);\n};\n\nHandlebars.compile = function(input, options) {\n  if (input == null || (typeof input !== 'string' && input.constructor !== Handlebars.AST.ProgramNode)) {\n    throw new Handlebars.Exception(\"You must pass a string or Handlebars AST to Handlebars.compile. You passed \" + input);\n  }\n\n  options = options || {};\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  var compiled;\n  function compile() {\n    var ast = Handlebars.parse(input);\n    var environment = new Compiler().compile(ast, options);\n    var templateSpec = new JavaScriptCompiler().compile(environment, options, undefined, true);\n    return Handlebars.template(templateSpec);\n  }\n\n  // Template is only compiled on first use and cached after that point.\n  return function(context, options) {\n    if (!compiled) {\n      compiled = compile();\n    }\n    return compiled.call(this, context, options);\n  };\n};\n\n;\n// lib/handlebars/runtime.js\n\nHandlebars.VM = {\n  template: function(templateSpec) {\n    // Just add water\n    var container = {\n      escapeExpression: Handlebars.Utils.escapeExpression,\n      invokePartial: Handlebars.VM.invokePartial,\n      programs: [],\n      program: function(i, fn, data) {\n        var programWrapper = this.programs[i];\n        if(data) {\n          programWrapper = Handlebars.VM.program(i, fn, data);\n        } else if (!programWrapper) {\n          programWrapper = this.programs[i] = Handlebars.VM.program(i, fn);\n        }\n        return programWrapper;\n      },\n      merge: function(param, common) {\n        var ret = param || common;\n\n        if (param && common) {\n          ret = {};\n          Handlebars.Utils.extend(ret, common);\n          Handlebars.Utils.extend(ret, param);\n        }\n        return ret;\n      },\n      programWithDepth: Handlebars.VM.programWithDepth,\n      noop: Handlebars.VM.noop,\n      compilerInfo: null\n    };\n\n    return function(context, options) {\n      options = options || {};\n      var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);\n\n      var compilerInfo = container.compilerInfo || [],\n          compilerRevision = compilerInfo[0] || 1,\n          currentRevision = Handlebars.COMPILER_REVISION;\n\n      if (compilerRevision !== currentRevision) {\n        if (compilerRevision < currentRevision) {\n          var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision],\n              compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];\n          throw \"Template was precompiled with an older version of Handlebars than the current runtime. \"+\n                \"Please update your precompiler to a newer version (\"+runtimeVersions+\") or downgrade your runtime to an older version (\"+compilerVersions+\").\";\n        } else {\n          // Use the embedded version info since the runtime doesn't know about this revision yet\n          throw \"Template was precompiled with a newer version of Handlebars than the current runtime. \"+\n                \"Please update your runtime to a newer version (\"+compilerInfo[1]+\").\";\n        }\n      }\n\n      return result;\n    };\n  },\n\n  programWithDepth: function(i, fn, data /*, $depth */) {\n    var args = Array.prototype.slice.call(arguments, 3);\n\n    var program = function(context, options) {\n      options = options || {};\n\n      return fn.apply(this, [context, options.data || data].concat(args));\n    };\n    program.program = i;\n    program.depth = args.length;\n    return program;\n  },\n  program: function(i, fn, data) {\n    var program = function(context, options) {\n      options = options || {};\n\n      return fn(context, options.data || data);\n    };\n    program.program = i;\n    program.depth = 0;\n    return program;\n  },\n  noop: function() { return \"\"; },\n  invokePartial: function(partial, name, context, helpers, partials, data) {\n    var options = { helpers: helpers, partials: partials, data: data };\n\n    if(partial === undefined) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be found\");\n    } else if(partial instanceof Function) {\n      return partial(context, options);\n    } else if (!Handlebars.compile) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be compiled when running in runtime-only mode\");\n    } else {\n      partials[name] = Handlebars.compile(partial, {data: data !== undefined});\n      return partials[name](context, options);\n    }\n  }\n};\n\nHandlebars.template = Handlebars.VM.template;\n;\n// lib/handlebars/browser-suffix.js\n})(Handlebars);\n;\n","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/swagger-ui/lib/highlight.7.3.pack.js":"var hljs=new function(){function l(o){return o.replace(/&/gm,\"&amp;\").replace(/</gm,\"&lt;\").replace(/>/gm,\"&gt;\")}function b(p){for(var o=p.firstChild;o;o=o.nextSibling){if(o.nodeName==\"CODE\"){return o}if(!(o.nodeType==3&&o.nodeValue.match(/\\s+/))){break}}}function h(p,o){return Array.prototype.map.call(p.childNodes,function(q){if(q.nodeType==3){return o?q.nodeValue.replace(/\\n/g,\"\"):q.nodeValue}if(q.nodeName==\"BR\"){return\"\\n\"}return h(q,o)}).join(\"\")}function a(q){var p=(q.className+\" \"+q.parentNode.className).split(/\\s+/);p=p.map(function(r){return r.replace(/^language-/,\"\")});for(var o=0;o<p.length;o++){if(e[p[o]]||p[o]==\"no-highlight\"){return p[o]}}}function c(q){var o=[];(function p(r,s){for(var t=r.firstChild;t;t=t.nextSibling){if(t.nodeType==3){s+=t.nodeValue.length}else{if(t.nodeName==\"BR\"){s+=1}else{if(t.nodeType==1){o.push({event:\"start\",offset:s,node:t});s=p(t,s);o.push({event:\"stop\",offset:s,node:t})}}}}return s})(q,0);return o}function j(x,v,w){var p=0;var y=\"\";var r=[];function t(){if(x.length&&v.length){if(x[0].offset!=v[0].offset){return(x[0].offset<v[0].offset)?x:v}else{return v[0].event==\"start\"?x:v}}else{return x.length?x:v}}function s(A){function z(B){return\" \"+B.nodeName+'=\"'+l(B.value)+'\"'}return\"<\"+A.nodeName+Array.prototype.map.call(A.attributes,z).join(\"\")+\">\"}while(x.length||v.length){var u=t().splice(0,1)[0];y+=l(w.substr(p,u.offset-p));p=u.offset;if(u.event==\"start\"){y+=s(u.node);r.push(u.node)}else{if(u.event==\"stop\"){var o,q=r.length;do{q--;o=r[q];y+=(\"</\"+o.nodeName.toLowerCase()+\">\")}while(o!=u.node);r.splice(q,1);while(q<r.length){y+=s(r[q]);q++}}}}return y+l(w.substr(p))}function f(q){function o(s,r){return RegExp(s,\"m\"+(q.cI?\"i\":\"\")+(r?\"g\":\"\"))}function p(y,w){if(y.compiled){return}y.compiled=true;var s=[];if(y.k){var r={};function z(A,t){t.split(\" \").forEach(function(B){var C=B.split(\"|\");r[C[0]]=[A,C[1]?Number(C[1]):1];s.push(C[0])})}y.lR=o(y.l||hljs.IR,true);if(typeof y.k==\"string\"){z(\"keyword\",y.k)}else{for(var x in y.k){if(!y.k.hasOwnProperty(x)){continue}z(x,y.k[x])}}y.k=r}if(w){if(y.bWK){y.b=\"\\\\b(\"+s.join(\"|\")+\")\\\\s\"}y.bR=o(y.b?y.b:\"\\\\B|\\\\b\");if(!y.e&&!y.eW){y.e=\"\\\\B|\\\\b\"}if(y.e){y.eR=o(y.e)}y.tE=y.e||\"\";if(y.eW&&w.tE){y.tE+=(y.e?\"|\":\"\")+w.tE}}if(y.i){y.iR=o(y.i)}if(y.r===undefined){y.r=1}if(!y.c){y.c=[]}for(var v=0;v<y.c.length;v++){if(y.c[v]==\"self\"){y.c[v]=y}p(y.c[v],y)}if(y.starts){p(y.starts,w)}var u=[];for(var v=0;v<y.c.length;v++){u.push(y.c[v].b)}if(y.tE){u.push(y.tE)}if(y.i){u.push(y.i)}y.t=u.length?o(u.join(\"|\"),true):{exec:function(t){return null}}}p(q)}function d(D,E){function o(r,M){for(var L=0;L<M.c.length;L++){var K=M.c[L].bR.exec(r);if(K&&K.index==0){return M.c[L]}}}function s(K,r){if(K.e&&K.eR.test(r)){return K}if(K.eW){return s(K.parent,r)}}function t(r,K){return K.i&&K.iR.test(r)}function y(L,r){var K=F.cI?r[0].toLowerCase():r[0];return L.k.hasOwnProperty(K)&&L.k[K]}function G(){var K=l(w);if(!A.k){return K}var r=\"\";var N=0;A.lR.lastIndex=0;var L=A.lR.exec(K);while(L){r+=K.substr(N,L.index-N);var M=y(A,L);if(M){v+=M[1];r+='<span class=\"'+M[0]+'\">'+L[0]+\"</span>\"}else{r+=L[0]}N=A.lR.lastIndex;L=A.lR.exec(K)}return r+K.substr(N)}function z(){if(A.sL&&!e[A.sL]){return l(w)}var r=A.sL?d(A.sL,w):g(w);if(A.r>0){v+=r.keyword_count;B+=r.r}return'<span class=\"'+r.language+'\">'+r.value+\"</span>\"}function J(){return A.sL!==undefined?z():G()}function I(L,r){var K=L.cN?'<span class=\"'+L.cN+'\">':\"\";if(L.rB){x+=K;w=\"\"}else{if(L.eB){x+=l(r)+K;w=\"\"}else{x+=K;w=r}}A=Object.create(L,{parent:{value:A}});B+=L.r}function C(K,r){w+=K;if(r===undefined){x+=J();return 0}var L=o(r,A);if(L){x+=J();I(L,r);return L.rB?0:r.length}var M=s(A,r);if(M){if(!(M.rE||M.eE)){w+=r}x+=J();do{if(A.cN){x+=\"</span>\"}A=A.parent}while(A!=M.parent);if(M.eE){x+=l(r)}w=\"\";if(M.starts){I(M.starts,\"\")}return M.rE?0:r.length}if(t(r,A)){throw\"Illegal\"}w+=r;return r.length||1}var F=e[D];f(F);var A=F;var w=\"\";var B=0;var v=0;var x=\"\";try{var u,q,p=0;while(true){A.t.lastIndex=p;u=A.t.exec(E);if(!u){break}q=C(E.substr(p,u.index-p),u[0]);p=u.index+q}C(E.substr(p));return{r:B,keyword_count:v,value:x,language:D}}catch(H){if(H==\"Illegal\"){return{r:0,keyword_count:0,value:l(E)}}else{throw H}}}function g(s){var o={keyword_count:0,r:0,value:l(s)};var q=o;for(var p in e){if(!e.hasOwnProperty(p)){continue}var r=d(p,s);r.language=p;if(r.keyword_count+r.r>q.keyword_count+q.r){q=r}if(r.keyword_count+r.r>o.keyword_count+o.r){q=o;o=r}}if(q.language){o.second_best=q}return o}function i(q,p,o){if(p){q=q.replace(/^((<[^>]+>|\\t)+)/gm,function(r,v,u,t){return v.replace(/\\t/g,p)})}if(o){q=q.replace(/\\n/g,\"<br>\")}return q}function m(r,u,p){var v=h(r,p);var t=a(r);if(t==\"no-highlight\"){return}var w=t?d(t,v):g(v);t=w.language;var o=c(r);if(o.length){var q=document.createElement(\"pre\");q.innerHTML=w.value;w.value=j(o,c(q),v)}w.value=i(w.value,u,p);var s=r.className;if(!s.match(\"(\\\\s|^)(language-)?\"+t+\"(\\\\s|$)\")){s=s?(s+\" \"+t):t}r.innerHTML=w.value;r.className=s;r.result={language:t,kw:w.keyword_count,re:w.r};if(w.second_best){r.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function n(){if(n.called){return}n.called=true;Array.prototype.map.call(document.getElementsByTagName(\"pre\"),b).filter(Boolean).forEach(function(o){m(o,hljs.tabReplace)})}function k(){window.addEventListener(\"DOMContentLoaded\",n,false);window.addEventListener(\"load\",n,false)}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=m;this.initHighlighting=n;this.initHighlightingOnLoad=k;this.IR=\"[a-zA-Z][a-zA-Z0-9_]*\";this.UIR=\"[a-zA-Z_][a-zA-Z0-9_]*\";this.NR=\"\\\\b\\\\d+(\\\\.\\\\d+)?\";this.CNR=\"(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)\";this.BNR=\"\\\\b(0b[01]+)\";this.RSR=\"!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|\\\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~\";this.BE={b:\"\\\\\\\\[\\\\s\\\\S]\",r:0};this.ASM={cN:\"string\",b:\"'\",e:\"'\",i:\"\\\\n\",c:[this.BE],r:0};this.QSM={cN:\"string\",b:'\"',e:'\"',i:\"\\\\n\",c:[this.BE],r:0};this.CLCM={cN:\"comment\",b:\"//\",e:\"$\"};this.CBLCLM={cN:\"comment\",b:\"/\\\\*\",e:\"\\\\*/\"};this.HCM={cN:\"comment\",b:\"#\",e:\"$\"};this.NM={cN:\"number\",b:this.NR,r:0};this.CNM={cN:\"number\",b:this.CNR,r:0};this.BNM={cN:\"number\",b:this.BNR,r:0};this.inherit=function(q,r){var o={};for(var p in q){o[p]=q[p]}if(r){for(var p in r){o[p]=r[p]}}return o}}();hljs.LANGUAGES.xml=function(a){var c=\"[A-Za-z0-9\\\\._:-]+\";var b={eW:true,c:[{cN:\"attribute\",b:c,r:0},{b:'=\"',rB:true,e:'\"',c:[{cN:\"value\",b:'\"',eW:true}]},{b:\"='\",rB:true,e:\"'\",c:[{cN:\"value\",b:\"'\",eW:true}]},{b:\"=\",c:[{cN:\"value\",b:\"[^\\\\s/>]+\"}]}]};return{cI:true,c:[{cN:\"pi\",b:\"<\\\\?\",e:\"\\\\?>\",r:10},{cN:\"doctype\",b:\"<!DOCTYPE\",e:\">\",r:10,c:[{b:\"\\\\[\",e:\"\\\\]\"}]},{cN:\"comment\",b:\"<!--\",e:\"-->\",r:10},{cN:\"cdata\",b:\"<\\\\!\\\\[CDATA\\\\[\",e:\"\\\\]\\\\]>\",r:10},{cN:\"tag\",b:\"<style(?=\\\\s|>|$)\",e:\">\",k:{title:\"style\"},c:[b],starts:{e:\"</style>\",rE:true,sL:\"css\"}},{cN:\"tag\",b:\"<script(?=\\\\s|>|$)\",e:\">\",k:{title:\"script\"},c:[b],starts:{e:\"<\\/script>\",rE:true,sL:\"javascript\"}},{b:\"<%\",e:\"%>\",sL:\"vbscript\"},{cN:\"tag\",b:\"</?\",e:\"/?>\",c:[{cN:\"title\",b:\"[^ />]+\"},b]}]}}(hljs);hljs.LANGUAGES.json=function(a){var e={literal:\"true false null\"};var d=[a.QSM,a.CNM];var c={cN:\"value\",e:\",\",eW:true,eE:true,c:d,k:e};var b={b:\"{\",e:\"}\",c:[{cN:\"attribute\",b:'\\\\s*\"',e:'\"\\\\s*:\\\\s*',eB:true,eE:true,c:[a.BE],i:\"\\\\n\",starts:c}],i:\"\\\\S\"};var f={b:\"\\\\[\",e:\"\\\\]\",c:[a.inherit(c,{cN:null})],i:\"\\\\S\"};d.splice(d.length,0,b,f);return{c:d,k:e,i:\"\\\\S\"}}(hljs);","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/swagger-ui/lib/shred.bundle.js":"var require = function (file, cwd) {\n    var resolved = require.resolve(file, cwd || '/');\n    var mod = require.modules[resolved];\n    if (!mod) throw new Error(\n        'Failed to resolve module ' + file + ', tried ' + resolved\n    );\n    var res = mod._cached ? mod._cached : mod();\n    return res;\n}\n\nrequire.paths = [];\nrequire.modules = {};\nrequire.extensions = [\".js\",\".coffee\"];\n\nrequire._core = {\n    'assert': true,\n    'events': true,\n    'fs': true,\n    'path': true,\n    'vm': true\n};\n\nrequire.resolve = (function () {\n    return function (x, cwd) {\n        if (!cwd) cwd = '/';\n        \n        if (require._core[x]) return x;\n        var path = require.modules.path();\n        var y = cwd || '.';\n        \n        if (x.match(/^(?:\\.\\.?\\/|\\/)/)) {\n            var m = loadAsFileSync(path.resolve(y, x))\n                || loadAsDirectorySync(path.resolve(y, x));\n            if (m) return m;\n        }\n        \n        var n = loadNodeModulesSync(x, y);\n        if (n) return n;\n        \n        throw new Error(\"Cannot find module '\" + x + \"'\");\n        \n        function loadAsFileSync (x) {\n            if (require.modules[x]) {\n                return x;\n            }\n            \n            for (var i = 0; i < require.extensions.length; i++) {\n                var ext = require.extensions[i];\n                if (require.modules[x + ext]) return x + ext;\n            }\n        }\n        \n        function loadAsDirectorySync (x) {\n            x = x.replace(/\\/+$/, '');\n            var pkgfile = x + '/package.json';\n            if (require.modules[pkgfile]) {\n                var pkg = require.modules[pkgfile]();\n                var b = pkg.browserify;\n                if (typeof b === 'object' && b.main) {\n                    var m = loadAsFileSync(path.resolve(x, b.main));\n                    if (m) return m;\n                }\n                else if (typeof b === 'string') {\n                    var m = loadAsFileSync(path.resolve(x, b));\n                    if (m) return m;\n                }\n                else if (pkg.main) {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                }\n            }\n            \n            return loadAsFileSync(x + '/index');\n        }\n        \n        function loadNodeModulesSync (x, start) {\n            var dirs = nodeModulesPathsSync(start);\n            for (var i = 0; i < dirs.length; i++) {\n                var dir = dirs[i];\n                var m = loadAsFileSync(dir + '/' + x);\n                if (m) return m;\n                var n = loadAsDirectorySync(dir + '/' + x);\n                if (n) return n;\n            }\n            \n            var m = loadAsFileSync(x);\n            if (m) return m;\n        }\n        \n        function nodeModulesPathsSync (start) {\n            var parts;\n            if (start === '/') parts = [ '' ];\n            else parts = path.normalize(start).split('/');\n            \n            var dirs = [];\n            for (var i = parts.length - 1; i >= 0; i--) {\n                if (parts[i] === 'node_modules') continue;\n                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';\n                dirs.push(dir);\n            }\n            \n            return dirs;\n        }\n    };\n})();\n\nrequire.alias = function (from, to) {\n    var path = require.modules.path();\n    var res = null;\n    try {\n        res = require.resolve(from + '/package.json', '/');\n    }\n    catch (err) {\n        res = require.resolve(from, '/');\n    }\n    var basedir = path.dirname(res);\n    \n    var keys = (Object.keys || function (obj) {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    })(require.modules);\n    \n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (key.slice(0, basedir.length + 1) === basedir + '/') {\n            var f = key.slice(basedir.length);\n            require.modules[to + f] = require.modules[basedir + f];\n        }\n        else if (key === basedir) {\n            require.modules[to] = require.modules[basedir];\n        }\n    }\n};\n\nrequire.define = function (filename, fn) {\n    var dirname = require._core[filename]\n        ? ''\n        : require.modules.path().dirname(filename)\n    ;\n    \n    var require_ = function (file) {\n        return require(file, dirname)\n    };\n    require_.resolve = function (name) {\n        return require.resolve(name, dirname);\n    };\n    require_.modules = require.modules;\n    require_.define = require.define;\n    var module_ = { exports : {} };\n    \n    require.modules[filename] = function () {\n        require.modules[filename]._cached = module_.exports;\n        fn.call(\n            module_.exports,\n            require_,\n            module_,\n            module_.exports,\n            dirname,\n            filename\n        );\n        require.modules[filename]._cached = module_.exports;\n        return module_.exports;\n    };\n};\n\nif (typeof process === 'undefined') process = {};\n\nif (!process.nextTick) process.nextTick = (function () {\n    var queue = [];\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n    \n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n    }\n    \n    return function (fn) {\n        if (canPost) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        }\n        else setTimeout(fn, 0);\n    };\n})();\n\nif (!process.title) process.title = 'browser';\n\nif (!process.binding) process.binding = function (name) {\n    if (name === 'evals') return require('vm')\n    else throw new Error('No such module')\n};\n\nif (!process.cwd) process.cwd = function () { return '.' };\n\nrequire.define(\"path\", function (require, module, exports, __dirname, __filename) {\n    function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n});\n\nrequire.define(\"/shred.js\", function (require, module, exports, __dirname, __filename) {\n    // Shred is an HTTP client library intended to simplify the use of Node's\n// built-in HTTP library. In particular, we wanted to make it easier to interact\n// with HTTP-based APIs.\n// \n// See the [examples](./examples.html) for more details.\n\n// Ax is a nice logging library we wrote. You can use any logger, providing it\n// has `info`, `warn`, `debug`, and `error` methods that take a string.\nvar Ax = require(\"ax\")\n  , CookieJarLib = require( \"cookiejar\" )\n  , CookieJar = CookieJarLib.CookieJar\n;\n\n// Shred takes some options, including a logger and request defaults.\n\nvar Shred = function(options) {\n  options = (options||{});\n  this.agent = options.agent;\n  this.defaults = options.defaults||{};\n  this.log = options.logger||(new Ax({ level: \"info\" }));\n  this._sharedCookieJar = new CookieJar();\n  this.logCurl = options.logCurl || false;\n};\n\n// Most of the real work is done in the request and reponse classes.\n \nShred.Request = require(\"./shred/request\");\nShred.Response = require(\"./shred/response\");\n\n// The `request` method kicks off a new request, instantiating a new `Request`\n// object and passing along whatever default options we were given.\n\nShred.prototype = {\n  request: function(options) {\n    options.logger = this.log;\n    options.logCurl = options.logCurl || this.logCurl;\n    options.cookieJar = ( 'cookieJar' in options ) ? options.cookieJar : this._sharedCookieJar; // let them set cookieJar = null\n    options.agent = options.agent || this.agent;\n    // fill in default options\n    for (var key in this.defaults) {\n      if (this.defaults.hasOwnProperty(key) && !options[key]) {\n        options[key] = this.defaults[key]\n      }\n    }\n    return new Shred.Request(options);\n  }\n};\n\n// Define a bunch of convenience methods so that you don't have to include\n// a `method` property in your request options.\n\n\"get put post delete\".split(\" \").forEach(function(method) {\n  Shred.prototype[method] = function(options) {\n    options.method = method;\n    return this.request(options);\n  };\n});\n\n\nmodule.exports = Shred;\n\n});\n\nrequire.define(\"/node_modules/ax/package.json\", function (require, module, exports, __dirname, __filename) {\n    module.exports = {\"main\":\"./lib/ax.js\"}\n});\n\nrequire.define(\"/node_modules/ax/lib/ax.js\", function (require, module, exports, __dirname, __filename) {\n    var inspect = require(\"util\").inspect\n  , fs = require(\"fs\")\n;\n\n\n// this is a quick-and-dirty logger. there are other nicer loggers out there\n// but the ones i found were also somewhat involved. this one has a Ruby\n// logger type interface\n//\n// we can easily replace this, provide the info, debug, etc. methods are the\n// same. or, we can change Haiku to use a more standard node.js interface\n\nvar format = function(level,message) {\n  var debug = (level==\"debug\"||level==\"error\");\n  if (!message) { return message.toString(); }\n  if (typeof(message) == \"object\") {\n    if (message instanceof Error && debug) {\n      return message.stack;\n    } else {\n      return inspect(message);\n    }\n  } else {\n    return message.toString();\n  }\n};\n\nvar noOp = function(message) { return this; }\nvar makeLogger = function(level,fn) {\n  return function(message) { \n    this.stream.write(this.format(level, message)+\"\\n\");\n    return this;\n  }\n};\n\nvar Logger = function(options) {\n  var logger = this;\n  var options = options||{};\n\n  // Default options\n  options.level = options.level || \"info\";\n  options.timestamp = options.timestamp || true;\n  options.prefix = options.prefix || \"\";\n  logger.options = options;\n\n  // Allows a prefix to be added to the message.\n  //\n  //    var logger = new Ax({ module: 'Haiku' })\n  //    logger.warn('this is going to be awesome!');\n  //    //=> Haiku: this is going to be awesome!\n  //\n  if (logger.options.module){\n    logger.options.prefix = logger.options.module;\n  }\n\n  // Write to stderr or a file\n  if (logger.options.file){\n    logger.stream = fs.createWriteStream(logger.options.file, {\"flags\": \"a\"});\n  } else {\n      if(process.title === \"node\")\n    logger.stream = process.stderr;\n      else if(process.title === \"browser\")\n    logger.stream = function () {\n      // Work around weird console context issue: http://code.google.com/p/chromium/issues/detail?id=48662\n      return console[logger.options.level].apply(console, arguments);\n    };\n  }\n\n  switch(logger.options.level){\n    case 'debug':\n      ['debug', 'info', 'warn'].forEach(function (level) {\n        logger[level] = Logger.writer(level);\n      });\n    case 'info':\n      ['info', 'warn'].forEach(function (level) {\n        logger[level] = Logger.writer(level);\n      });\n    case 'warn':\n      logger.warn = Logger.writer('warn');\n  }\n}\n\n// Used to define logger methods\nLogger.writer = function(level){\n  return function(message){\n    var logger = this;\n\n    if(process.title === \"node\")\n  logger.stream.write(logger.format(level, message) + '\\n');\n    else if(process.title === \"browser\")\n  logger.stream(logger.format(level, message) + '\\n');\n\n  };\n}\n\n\nLogger.prototype = {\n  info: function(){},\n  debug: function(){},\n  warn: function(){},\n  error: Logger.writer('error'),\n  format: function(level, message){\n    if (! message) return '';\n\n    var logger = this\n      , prefix = logger.options.prefix\n      , timestamp = logger.options.timestamp ? \" \" + (new Date().toISOString()) : \"\"\n    ;\n\n    return (prefix + timestamp + \": \" + message);\n  }\n};\n\nmodule.exports = Logger;\n\n});\n\nrequire.define(\"util\", function (require, module, exports, __dirname, __filename) {\n    // todo\n\n});\n\nrequire.define(\"fs\", function (require, module, exports, __dirname, __filename) {\n    // nothing to see here... no file methods for the browser\n\n});\n\nrequire.define(\"/node_modules/cookiejar/package.json\", function (require, module, exports, __dirname, __filename) {\n    module.exports = {\"main\":\"cookiejar.js\"}\n});\n\nrequire.define(\"/node_modules/cookiejar/cookiejar.js\", function (require, module, exports, __dirname, __filename) {\n    exports.CookieAccessInfo=CookieAccessInfo=function CookieAccessInfo(domain,path,secure,script) {\n    if(this instanceof CookieAccessInfo) {\n      this.domain=domain||undefined;\n      this.path=path||\"/\";\n      this.secure=!!secure;\n      this.script=!!script;\n      return this;\n    }\n    else {\n        return new CookieAccessInfo(domain,path,secure,script)    \n    }\n}\n\nexports.Cookie=Cookie=function Cookie(cookiestr) {\n  if(cookiestr instanceof Cookie) {\n    return cookiestr;\n  }\n    else {\n        if(this instanceof Cookie) {\n          this.name = null;\n          this.value = null;\n          this.expiration_date = Infinity;\n          this.path = \"/\";\n          this.domain = null;\n          this.secure = false; //how to define?\n          this.noscript = false; //httponly\n          if(cookiestr) {\n            this.parse(cookiestr)\n          }\n          return this;\n        }\n        return new Cookie(cookiestr)\n    }\n}\n\nCookie.prototype.toString = function toString() {\n  var str=[this.name+\"=\"+this.value];\n  if(this.expiration_date !== Infinity) {\n    str.push(\"expires=\"+(new Date(this.expiration_date)).toGMTString());\n  }\n  if(this.domain) {\n    str.push(\"domain=\"+this.domain);\n  }\n  if(this.path) {\n    str.push(\"path=\"+this.path);\n  }\n  if(this.secure) {\n    str.push(\"secure\");\n  }\n  if(this.noscript) {\n    str.push(\"httponly\");\n  }\n  return str.join(\"; \");\n}\n\nCookie.prototype.toValueString = function toValueString() {\n  return this.name+\"=\"+this.value;\n}\n\nvar cookie_str_splitter=/[:](?=\\s*[a-zA-Z0-9_\\-]+\\s*[=])/g\nCookie.prototype.parse = function parse(str) {\n  if(this instanceof Cookie) {\n      var parts=str.split(\";\")\n      , pair=parts[0].match(/([^=]+)=((?:.|\\n)*)/)\n      , key=pair[1]\n      , value=pair[2];\n      this.name = key;\n      this.value = value;\n    \n      for(var i=1;i<parts.length;i++) {\n        pair=parts[i].match(/([^=]+)(?:=((?:.|\\n)*))?/)\n        , key=pair[1].trim().toLowerCase()\n        , value=pair[2];\n        switch(key) {\n          case \"httponly\":\n            this.noscript = true;\n          break;\n          case \"expires\":\n            this.expiration_date = value\n              ? Number(Date.parse(value))\n              : Infinity;\n          break;\n          case \"path\":\n            this.path = value\n              ? value.trim()\n              : \"\";\n          break;\n          case \"domain\":\n            this.domain = value\n              ? value.trim()\n              : \"\";\n          break;\n          case \"secure\":\n            this.secure = true;\n          break\n        }\n      }\n    \n      return this;\n  }\n    return new Cookie().parse(str)\n}\n\nCookie.prototype.matches = function matches(access_info) {\n  if(this.noscript && access_info.script\n  || this.secure && !access_info.secure\n  || !this.collidesWith(access_info)) {\n    return false\n  }\n  return true;\n}\n\nCookie.prototype.collidesWith = function collidesWith(access_info) {\n  if((this.path && !access_info.path) || (this.domain && !access_info.domain)) {\n    return false\n  }\n  if(this.path && access_info.path.indexOf(this.path) !== 0) {\n    return false;\n  }\n  if (this.domain===access_info.domain) {\n    return true;\n  }\n  else if(this.domain && this.domain.charAt(0)===\".\")\n  {\n    var wildcard=access_info.domain.indexOf(this.domain.slice(1))\n    if(wildcard===-1 || wildcard!==access_info.domain.length-this.domain.length+1) {\n      return false;\n    }\n  }\n  else if(this.domain){\n    return false\n  }\n  return true;\n}\n\nexports.CookieJar=CookieJar=function CookieJar() {\n  if(this instanceof CookieJar) {\n      var cookies = {} //name: [Cookie]\n    \n      this.setCookie = function setCookie(cookie) {\n        cookie = Cookie(cookie);\n        //Delete the cookie if the set is past the current time\n        var remove = cookie.expiration_date <= Date.now();\n        if(cookie.name in cookies) {\n          var cookies_list = cookies[cookie.name];\n          for(var i=0;i<cookies_list.length;i++) {\n            var collidable_cookie = cookies_list[i];\n            if(collidable_cookie.collidesWith(cookie)) {\n              if(remove) {\n                cookies_list.splice(i,1);\n                if(cookies_list.length===0) {\n                  delete cookies[cookie.name]\n                }\n                return false;\n              }\n              else {\n                return cookies_list[i]=cookie;\n              }\n            }\n          }\n          if(remove) {\n            return false;\n          }\n          cookies_list.push(cookie);\n          return cookie;\n        }\n        else if(remove){\n          return false;\n        }\n        else {\n          return cookies[cookie.name]=[cookie];\n        }\n      }\n      //returns a cookie\n      this.getCookie = function getCookie(cookie_name,access_info) {\n        var cookies_list = cookies[cookie_name];\n        for(var i=0;i<cookies_list.length;i++) {\n          var cookie = cookies_list[i];\n          if(cookie.expiration_date <= Date.now()) {\n            if(cookies_list.length===0) {\n              delete cookies[cookie.name]\n            }\n            continue;\n          }\n          if(cookie.matches(access_info)) {\n            return cookie;\n          }\n        }\n      }\n      //returns a list of cookies\n      this.getCookies = function getCookies(access_info) {\n        var matches=[];\n        for(var cookie_name in cookies) {\n          var cookie=this.getCookie(cookie_name,access_info);\n          if (cookie) {\n            matches.push(cookie);\n          }\n        }\n        matches.toString=function toString(){return matches.join(\":\");}\n            matches.toValueString=function() {return matches.map(function(c){return c.toValueString();}).join(';');}\n        return matches;\n      }\n    \n      return this;\n  }\n    return new CookieJar()\n}\n\n\n//returns list of cookies that were set correctly\nCookieJar.prototype.setCookies = function setCookies(cookies) {\n  cookies=Array.isArray(cookies)\n    ?cookies\n    :cookies.split(cookie_str_splitter);\n  var successful=[]\n  for(var i=0;i<cookies.length;i++) {\n    var cookie = Cookie(cookies[i]);\n    if(this.setCookie(cookie)) {\n      successful.push(cookie);\n    }\n  }\n  return successful;\n}\n\n});\n\nrequire.define(\"/shred/request.js\", function (require, module, exports, __dirname, __filename) {\n    // The request object encapsulates a request, creating a Node.js HTTP request and\n// then handling the response.\n\nvar HTTP = require(\"http\")\n  , HTTPS = require(\"https\")\n  , parseUri = require(\"./parseUri\")\n  , Emitter = require('events').EventEmitter\n  , sprintf = require(\"sprintf\").sprintf\n  , Response = require(\"./response\")\n  , HeaderMixins = require(\"./mixins/headers\")\n  , Content = require(\"./content\")\n;\n\nvar STATUS_CODES = HTTP.STATUS_CODES || {\n    100 : 'Continue',\n    101 : 'Switching Protocols',\n    102 : 'Processing', // RFC 2518, obsoleted by RFC 4918\n    200 : 'OK',\n    201 : 'Created',\n    202 : 'Accepted',\n    203 : 'Non-Authoritative Information',\n    204 : 'No Content',\n    205 : 'Reset Content',\n    206 : 'Partial Content',\n    207 : 'Multi-Status', // RFC 4918\n    300 : 'Multiple Choices',\n    301 : 'Moved Permanently',\n    302 : 'Moved Temporarily',\n    303 : 'See Other',\n    304 : 'Not Modified',\n    305 : 'Use Proxy',\n    307 : 'Temporary Redirect',\n    400 : 'Bad Request',\n    401 : 'Unauthorized',\n    402 : 'Payment Required',\n    403 : 'Forbidden',\n    404 : 'Not Found',\n    405 : 'Method Not Allowed',\n    406 : 'Not Acceptable',\n    407 : 'Proxy Authentication Required',\n    408 : 'Request Time-out',\n    409 : 'Conflict',\n    410 : 'Gone',\n    411 : 'Length Required',\n    412 : 'Precondition Failed',\n    413 : 'Request Entity Too Large',\n    414 : 'Request-URI Too Large',\n    415 : 'Unsupported Media Type',\n    416 : 'Requested Range Not Satisfiable',\n    417 : 'Expectation Failed',\n    418 : 'I\\'m a teapot', // RFC 2324\n    422 : 'Unprocessable Entity', // RFC 4918\n    423 : 'Locked', // RFC 4918\n    424 : 'Failed Dependency', // RFC 4918\n    425 : 'Unordered Collection', // RFC 4918\n    426 : 'Upgrade Required', // RFC 2817\n    500 : 'Internal Server Error',\n    501 : 'Not Implemented',\n    502 : 'Bad Gateway',\n    503 : 'Service Unavailable',\n    504 : 'Gateway Time-out',\n    505 : 'HTTP Version not supported',\n    506 : 'Variant Also Negotiates', // RFC 2295\n    507 : 'Insufficient Storage', // RFC 4918\n    509 : 'Bandwidth Limit Exceeded',\n    510 : 'Not Extended' // RFC 2774\n};\n\n// The Shred object itself constructs the `Request` object. You should rarely\n// need to do this directly.\n\nvar Request = function(options) {\n  this.log = options.logger;\n  this.cookieJar = options.cookieJar;\n  this.encoding = options.encoding;\n  this.logCurl = options.logCurl;\n  processOptions(this,options||{});\n  createRequest(this);\n};\n\n// A `Request` has a number of properties, many of which help with details like\n// URL parsing or defaulting the port for the request.\n\nObject.defineProperties(Request.prototype, {\n\n// - **url**. You can set the `url` property with a valid URL string and all the\n//   URL-related properties (host, port, etc.) will be automatically set on the\n//   request object.\n\n  url: {\n    get: function() {\n      if (!this.scheme) { return null; }\n      return sprintf(\"%s://%s:%s%s\",\n          this.scheme, this.host, this.port,\n          (this.proxy ? \"/\" : this.path) +\n          (this.query ? (\"?\" + this.query) : \"\"));\n    },\n    set: function(_url) {\n      _url = parseUri(_url);\n      this.scheme = _url.protocol;\n      this.host = _url.host;\n      this.port = _url.port;\n      this.path = _url.path;\n      this.query = _url.query;\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **headers**. Returns a hash representing the request headers. You can't set\n//   this directly, only get it. You can add or modify headers by using the\n//   `setHeader` or `setHeaders` method. This ensures that the headers are\n//   normalized - that is, you don't accidentally send `Content-Type` and\n//   `content-type` headers. Keep in mind that if you modify the returned hash,\n//   it will *not* modify the request headers.\n\n  headers: {\n    get: function() {\n      return this.getHeaders();\n    },\n    enumerable: true\n  },\n\n// - **port**. Unless you set the `port` explicitly or include it in the URL, it\n//   will default based on the scheme.\n\n  port: {\n    get: function() {\n      if (!this._port) {\n        switch(this.scheme) {\n          case \"https\": return this._port = 443;\n          case \"http\":\n          default: return this._port = 80;\n        }\n      }\n      return this._port;\n    },\n    set: function(value) { this._port = value; return this; },\n    enumerable: true\n  },\n\n// - **method**. The request method - `get`, `put`, `post`, etc. that will be\n//   used to make the request. Defaults to `get`.\n\n  method: {\n    get: function() {\n      return this._method = (this._method||\"GET\");\n    },\n    set: function(value) {\n      this._method = value; return this;\n    },\n    enumerable: true\n  },\n\n// - **query**. Can be set either with a query string or a hash (object). Get\n//   will always return a properly escaped query string or null if there is no\n//   query component for the request.\n\n  query: {\n    get: function() {return this._query;},\n    set: function(value) {\n      var stringify = function (hash) {\n        var query = \"\";\n        for (var key in hash) {\n          query += encodeURIComponent(key) + '=' + encodeURIComponent(hash[key]) + '&';\n        }\n        // Remove the last '&'\n        query = query.slice(0, -1);\n        return query;\n      }\n\n      if (value) {\n        if (typeof value === 'object') {\n          value = stringify(value);\n        }\n        this._query = value;\n      } else {\n        this._query = \"\";\n      }\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **parameters**. This will return the query parameters in the form of a hash\n//   (object).\n\n  parameters: {\n    get: function() { return QueryString.parse(this._query||\"\"); },\n    enumerable: true\n  },\n\n// - **content**. (Aliased as `body`.) Set this to add a content entity to the\n//   request. Attempts to use the `content-type` header to determine what to do\n//   with the content value. Get this to get back a [`Content`\n//   object](./content.html).\n\n  body: {\n    get: function() { return this._body; },\n    set: function(value) {\n      this._body = new Content({\n        data: value,\n        type: this.getHeader(\"Content-Type\")\n      });\n      this.setHeader(\"Content-Type\",this.content.type);\n      this.setHeader(\"Content-Length\",this.content.length);\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **timeout**. Used to determine how long to wait for a response. Does not\n//   distinguish between connect timeouts versus request timeouts. Set either in\n//   milliseconds or with an object with temporal attributes (hours, minutes,\n//   seconds) and convert it into milliseconds. Get will always return\n//   milliseconds.\n\n  timeout: {\n    get: function() { return this._timeout; }, // in milliseconds\n    set: function(timeout) {\n      var request = this\n        , milliseconds = 0;\n      ;\n      if (!timeout) return this;\n      if (typeof timeout===\"number\") { milliseconds = timeout; }\n      else {\n        milliseconds = (timeout.milliseconds||0) +\n          (1000 * ((timeout.seconds||0) +\n              (60 * ((timeout.minutes||0) +\n                (60 * (timeout.hours||0))))));\n      }\n      this._timeout = milliseconds;\n      return this;\n    },\n    enumerable: true\n  }\n});\n\n// Alias `body` property to `content`. Since the [content object](./content.html)\n// has a `body` attribute, it's preferable to use `content` since you can then\n// access the raw content data using `content.body`.\n\nObject.defineProperty(Request.prototype,\"content\",\n    Object.getOwnPropertyDescriptor(Request.prototype, \"body\"));\n\n// The `Request` object can be pretty overwhelming to view using the built-in\n// Node.js inspect method. We want to make it a bit more manageable. This\n// probably goes [too far in the other\n// direction](https://github.com/spire-io/shred/issues/2).\n\nRequest.prototype.inspect = function () {\n  var request = this;\n  var headers = this.format_headers();\n  var summary = [\"<Shred Request> \", request.method.toUpperCase(),\n      request.url].join(\" \")\n  return [ summary, \"- Headers:\", headers].join(\"\\n\");\n};\n\nRequest.prototype.format_headers = function () {\n  var array = []\n  var headers = this._headers\n  for (var key in headers) {\n    if (headers.hasOwnProperty(key)) {\n      var value = headers[key]\n      array.push(\"\\t\" + key + \": \" + value);\n    }\n  }\n  return array.join(\"\\n\");\n};\n\n// Allow chainable 'on's:  shred.get({ ... }).on( ... ).  You can pass in a\n// single function, a pair (event, function), or a hash:\n// { event: function, event: function }\nRequest.prototype.on = function (eventOrHash, listener) {\n  var emitter = this.emitter;\n  // Pass in a single argument as a function then make it the default response handler\n  if (arguments.length === 1 && typeof(eventOrHash) === 'function') {\n    emitter.on('response', eventOrHash);\n  } else if (arguments.length === 1 && typeof(eventOrHash) === 'object') {\n    for (var key in eventOrHash) {\n      if (eventOrHash.hasOwnProperty(key)) {\n        emitter.on(key, eventOrHash[key]);\n      }\n    }\n  } else {\n    emitter.on(eventOrHash, listener);\n  }\n  return this;\n};\n\n// Add in the header methods. Again, these ensure we don't get the same header\n// multiple times with different case conventions.\nHeaderMixins.gettersAndSetters(Request);\n\n// `processOptions` is called from the constructor to handle all the work\n// associated with making sure we do our best to ensure we have a valid request.\n\nvar processOptions = function(request,options) {\n\n  request.log.debug(\"Processing request options ..\");\n\n  // We'll use `request.emitter` to manage the `on` event handlers.\n  request.emitter = (new Emitter);\n\n  request.agent = options.agent;\n\n  // Set up the handlers ...\n  if (options.on) {\n    for (var key in options.on) {\n      if (options.on.hasOwnProperty(key)) {\n        request.emitter.on(key, options.on[key]);\n      }\n    }\n  }\n\n  // Make sure we were give a URL or a host\n  if (!options.url && !options.host) {\n    request.emitter.emit(\"request_error\",\n        new Error(\"No url or url options (host, port, etc.)\"));\n    return;\n  }\n\n  // Allow for the [use of a proxy](http://www.jmarshall.com/easy/http/#proxies).\n\n  if (options.url) {\n    if (options.proxy) {\n      request.url = options.proxy;\n      request.path = options.url;\n    } else {\n      request.url = options.url;\n    }\n  }\n\n  // Set the remaining options.\n  request.query = options.query||options.parameters||request.query ;\n  request.method = options.method;\n  request.setHeader(\"user-agent\",options.agent||\"Shred\");\n  request.setHeaders(options.headers);\n\n  if (request.cookieJar) {\n    var cookies = request.cookieJar.getCookies( CookieAccessInfo( request.host, request.path ) );\n    if (cookies.length) {\n      var cookieString = request.getHeader('cookie')||'';\n      for (var cookieIndex = 0; cookieIndex < cookies.length; ++cookieIndex) {\n          if ( cookieString.length && cookieString[ cookieString.length - 1 ] != ';' )\n          {\n              cookieString += ';';\n          }\n          cookieString += cookies[ cookieIndex ].name + '=' + cookies[ cookieIndex ].value + ';';\n      }\n      request.setHeader(\"cookie\", cookieString);\n    }\n  }\n  \n  // The content entity can be set either using the `body` or `content` attributes.\n  if (options.body||options.content) {\n    request.content = options.body||options.content;\n  }\n  request.timeout = options.timeout;\n\n};\n\n// `createRequest` is also called by the constructor, after `processOptions`.\n// This actually makes the request and processes the response, so `createRequest`\n// is a bit of a misnomer.\n\nvar createRequest = function(request) {\n  var timeout ;\n\n  request.log.debug(\"Creating request ..\");\n  request.log.debug(request);\n\n  var reqParams = {\n    host: request.host,\n    port: request.port,\n    method: request.method,\n    path: request.path + (request.query ? '?'+request.query : \"\"),\n    headers: request.getHeaders(),\n    // Node's HTTP/S modules will ignore this, but we are using the\n    // browserify-http module in the browser for both HTTP and HTTPS, and this\n    // is how you differentiate the two.\n    scheme: request.scheme,\n    // Use a provided agent.  'Undefined' is the default, which uses a global\n    // agent.\n    agent: request.agent\n  };\n\n  if (request.logCurl) {\n    logCurl(request);\n  }\n\n  var http = request.scheme == \"http\" ? HTTP : HTTPS;\n\n  // Set up the real request using the selected library. The request won't be\n  // sent until we call `.end()`.\n  request._raw = http.request(reqParams, function(response) {\n    request.log.debug(\"Received response ..\");\n\n    // We haven't timed out and we have a response, so make sure we clear the\n    // timeout so it doesn't fire while we're processing the response.\n    clearTimeout(timeout);\n\n    // Construct a Shred `Response` object from the response. This will stream\n    // the response, thus the need for the callback. We can access the response\n    // entity safely once we're in the callback.\n    response = new Response(response, request, function(response) {\n\n      // Set up some event magic. The precedence is given first to\n      // status-specific handlers, then to responses for a given event, and then\n      // finally to the more general `response` handler. In the last case, we\n      // need to first make sure we're not dealing with a a redirect.\n      var emit = function(event) {\n        var emitter = request.emitter;\n        var textStatus = STATUS_CODES[response.status] ? STATUS_CODES[response.status].toLowerCase() : null;\n        if (emitter.listeners(response.status).length > 0 || emitter.listeners(textStatus).length > 0) {\n          emitter.emit(response.status, response);\n          emitter.emit(textStatus, response);\n        } else {\n          if (emitter.listeners(event).length>0) {\n            emitter.emit(event, response);\n          } else if (!response.isRedirect) {\n            emitter.emit(\"response\", response);\n            //console.warn(\"Request has no event listener for status code \" + response.status);\n          }\n        }\n      };\n\n      // Next, check for a redirect. We simply repeat the request with the URL\n      // given in the `Location` header. We fire a `redirect` event.\n      if (response.isRedirect) {\n        request.log.debug(\"Redirecting to \"\n            + response.getHeader(\"Location\"));\n        request.url = response.getHeader(\"Location\");\n        emit(\"redirect\");\n        createRequest(request);\n\n      // Okay, it's not a redirect. Is it an error of some kind?\n      } else if (response.isError) {\n        emit(\"error\");\n      } else {\n      // It looks like we're good shape. Trigger the `success` event.\n        emit(\"success\");\n      }\n    });\n  });\n\n  // We're still setting up the request. Next, we're going to handle error cases\n  // where we have no response. We don't emit an error event because that event\n  // takes a response. We don't response handlers to have to check for a null\n  // value. However, we [should introduce a different event\n  // type](https://github.com/spire-io/shred/issues/3) for this type of error.\n  request._raw.on(\"error\", function(error) {\n    request.emitter.emit(\"request_error\", error);\n  });\n\n  request._raw.on(\"socket\", function(socket) {\n    request.emitter.emit(\"socket\", socket);\n  });\n\n  // TCP timeouts should also trigger the \"response_error\" event.\n  request._raw.on('socket', function () {\n    request._raw.socket.on('timeout', function () {\n      // This should trigger the \"error\" event on the raw request, which will\n      // trigger the \"response_error\" on the shred request.\n      request._raw.abort();\n    });\n  });\n\n\n  // We're almost there. Next, we need to write the request entity to the\n  // underlying request object.\n  if (request.content) {\n    request.log.debug(\"Streaming body: '\" +\n        request.content.data.slice(0,59) + \"' ... \");\n    request._raw.write(request.content.data);\n  }\n\n  // Finally, we need to set up the timeout. We do this last so that we don't\n  // start the clock ticking until the last possible moment.\n  if (request.timeout) {\n    timeout = setTimeout(function() {\n      request.log.debug(\"Timeout fired, aborting request ...\");\n      request._raw.abort();\n      request.emitter.emit(\"timeout\", request);\n    },request.timeout);\n  }\n\n  // The `.end()` method will cause the request to fire. Technically, it might\n  // have already sent the headers and body.\n  request.log.debug(\"Sending request ...\");\n  request._raw.end();\n};\n\n// Logs the curl command for the request.\nvar logCurl = function (req) {\n  var headers = req.getHeaders();\n  var headerString = \"\";\n\n  for (var key in headers) {\n    headerString += '-H \"' + key + \": \" + headers[key] + '\" ';\n  }\n\n  var bodyString = \"\"\n\n  if (req.content) {\n    bodyString += \"-d '\" + req.content.body + \"' \";\n  }\n\n  var query = req.query ? '?' + req.query : \"\";\n\n  console.log(\"curl \" +\n    \"-X \" + req.method.toUpperCase() + \" \" +\n    req.scheme + \"://\" + req.host + \":\" + req.port + req.path + query + \" \" +\n    headerString +\n    bodyString\n  );\n};\n\n\nmodule.exports = Request;\n\n});\n\nrequire.define(\"http\", function (require, module, exports, __dirname, __filename) {\n    // todo\n\n});\n\nrequire.define(\"https\", function (require, module, exports, __dirname, __filename) {\n    // todo\n\n});\n\nrequire.define(\"/shred/parseUri.js\", function (require, module, exports, __dirname, __filename) {\n    // parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\n\nfunction parseUri (str) {\n  var o   = parseUri.options,\n    m   = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str),\n    uri = {},\n    i   = 14;\n\n  while (i--) uri[o.key[i]] = m[i] || \"\";\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) uri[o.q.name][$1] = $2;\n  });\n\n  return uri;\n};\n\nparseUri.options = {\n  strictMode: false,\n  key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n  q:   {\n    name:   \"queryKey\",\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n  },\n  parser: {\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\n\nmodule.exports = parseUri;\n\n});\n\nrequire.define(\"events\", function (require, module, exports, __dirname, __filename) {\n    if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n});\n\nrequire.define(\"/node_modules/sprintf/package.json\", function (require, module, exports, __dirname, __filename) {\n    module.exports = {\"main\":\"./lib/sprintf\"}\n});\n\nrequire.define(\"/node_modules/sprintf/lib/sprintf.js\", function (require, module, exports, __dirname, __filename) {\n    /**\nsprintf() for JavaScript 0.7-beta1\nhttp://www.diveintojavascript.com/projects/javascript-sprintf\n\nCopyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of sprintf() for JavaScript nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nChangelog:\n2010.11.07 - 0.7-beta1-node\n  - converted it to a node.js compatible module\n\n2010.09.06 - 0.7-beta1\n  - features: vsprintf, support for named placeholders\n  - enhancements: format cache, reduced global namespace pollution\n\n2010.05.22 - 0.6:\n - reverted to 0.4 and fixed the bug regarding the sign of the number 0\n Note:\n Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)\n who warned me about a bug in 0.5, I discovered that the last update was\n a regress. I appologize for that.\n\n2010.05.09 - 0.5:\n - bug fix: 0 is now preceeded with a + sign\n - bug fix: the sign was not at the right position on padded results (Kamal Abdali)\n - switched from GPL to BSD license\n\n2007.10.21 - 0.4:\n - unit test and patch (David Baird)\n\n2007.09.17 - 0.3:\n - bug fix: no longer throws exception on empty paramenters (Hans Pufal)\n\n2007.09.11 - 0.2:\n - feature: added argument swapping\n\n2007.04.03 - 0.1:\n - initial release\n**/\n\nvar sprintf = (function() {\n  function get_type(variable) {\n    return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n  }\n  function str_repeat(input, multiplier) {\n    for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}\n    return output.join('');\n  }\n\n  var str_format = function() {\n    if (!str_format.cache.hasOwnProperty(arguments[0])) {\n      str_format.cache[arguments[0]] = str_format.parse(arguments[0]);\n    }\n    return str_format.format.call(null, str_format.cache[arguments[0]], arguments);\n  };\n\n  str_format.format = function(parse_tree, argv) {\n    var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n    for (i = 0; i < tree_length; i++) {\n      node_type = get_type(parse_tree[i]);\n      if (node_type === 'string') {\n        output.push(parse_tree[i]);\n      }\n      else if (node_type === 'array') {\n        match = parse_tree[i]; // convenience purposes only\n        if (match[2]) { // keyword argument\n          arg = argv[cursor];\n          for (k = 0; k < match[2].length; k++) {\n            if (!arg.hasOwnProperty(match[2][k])) {\n              throw(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]));\n            }\n            arg = arg[match[2][k]];\n          }\n        }\n        else if (match[1]) { // positional argument (explicit)\n          arg = argv[match[1]];\n        }\n        else { // positional argument (implicit)\n          arg = argv[cursor++];\n        }\n\n        if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {\n          throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));\n        }\n        switch (match[8]) {\n          case 'b': arg = arg.toString(2); break;\n          case 'c': arg = String.fromCharCode(arg); break;\n          case 'd': arg = parseInt(arg, 10); break;\n          case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n          case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n          case 'o': arg = arg.toString(8); break;\n          case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n          case 'u': arg = Math.abs(arg); break;\n          case 'x': arg = arg.toString(16); break;\n          case 'X': arg = arg.toString(16).toUpperCase(); break;\n        }\n        arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);\n        pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n        pad_length = match[6] - String(arg).length;\n        pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n        output.push(match[5] ? arg + pad : pad + arg);\n      }\n    }\n    return output.join('');\n  };\n\n  str_format.cache = {};\n\n  str_format.parse = function(fmt) {\n    var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n    while (_fmt) {\n      if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n        parse_tree.push(match[0]);\n      }\n      else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n        parse_tree.push('%');\n      }\n      else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n        if (match[2]) {\n          arg_names |= 1;\n          var field_list = [], replacement_field = match[2], field_match = [];\n          if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n            field_list.push(field_match[1]);\n            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n              if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                field_list.push(field_match[1]);\n              }\n              else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                field_list.push(field_match[1]);\n              }\n              else {\n                throw('[sprintf] huh?');\n              }\n            }\n          }\n          else {\n            throw('[sprintf] huh?');\n          }\n          match[2] = field_list;\n        }\n        else {\n          arg_names |= 2;\n        }\n        if (arg_names === 3) {\n          throw('[sprintf] mixing positional and named placeholders is not (yet) supported');\n        }\n        parse_tree.push(match);\n      }\n      else {\n        throw('[sprintf] huh?');\n      }\n      _fmt = _fmt.substring(match[0].length);\n    }\n    return parse_tree;\n  };\n\n  return str_format;\n})();\n\nvar vsprintf = function(fmt, argv) {\n  argv.unshift(fmt);\n  return sprintf.apply(null, argv);\n};\n\nexports.sprintf = sprintf;\nexports.vsprintf = vsprintf;\n});\n\nrequire.define(\"/shred/response.js\", function (require, module, exports, __dirname, __filename) {\n    // The `Response object` encapsulates a Node.js HTTP response.\n\nvar Content = require(\"./content\")\n  , HeaderMixins = require(\"./mixins/headers\")\n  , CookieJarLib = require( \"cookiejar\" )\n  , Cookie = CookieJarLib.Cookie\n;\n\n// Browser doesn't have zlib.\nvar zlib = null;\ntry {\n  zlib = require('zlib');\n} catch (e) {\n  console.warn(\"no zlib library\");\n}\n\n// Iconv doesn't work in browser\nvar Iconv = null;\ntry {\n  Iconv = require('iconv-lite');\n} catch (e) {\n  console.warn(\"no iconv library\");\n}\n\n// Construct a `Response` object. You should never have to do this directly. The\n// `Request` object handles this, getting the raw response object and passing it\n// in here, along with the request. The callback allows us to stream the response\n// and then use the callback to let the request know when it's ready.\nvar Response = function(raw, request, callback) { \n  var response = this;\n  this._raw = raw;\n\n  // The `._setHeaders` method is \"private\"; you can't otherwise set headers on\n  // the response.\n  this._setHeaders.call(this,raw.headers);\n  \n  // store any cookies\n  if (request.cookieJar && this.getHeader('set-cookie')) {\n    var cookieStrings = this.getHeader('set-cookie');\n    var cookieObjs = []\n      , cookie;\n\n    for (var i = 0; i < cookieStrings.length; i++) {\n      var cookieString = cookieStrings[i];\n      if (!cookieString) {\n        continue;\n      }\n\n      if (!cookieString.match(/domain\\=/i)) {\n        cookieString += '; domain=' + request.host;\n      }\n\n      if (!cookieString.match(/path\\=/i)) {\n        cookieString += '; path=' + request.path;\n      }\n\n      try {\n        cookie = new Cookie(cookieString);\n        if (cookie) {\n          cookieObjs.push(cookie);\n        }\n      } catch (e) {\n        console.warn(\"Tried to set bad cookie: \" + cookieString);\n      }\n    }\n\n    request.cookieJar.setCookies(cookieObjs);\n  }\n\n  this.request = request;\n  this.client = request.client;\n  this.log = this.request.log;\n\n  // Stream the response content entity and fire the callback when we're done.\n  // Store the incoming data in a array of Buffers which we concatinate into one\n  // buffer at the end.  We need to use buffers instead of strings here in order\n  // to preserve binary data.\n  var chunkBuffers = [];\n  var dataLength = 0;\n  raw.on(\"data\", function(chunk) {\n    chunkBuffers.push(chunk);\n    dataLength += chunk.length;\n  });\n  raw.on(\"end\", function() {\n    var body;\n    if (typeof Buffer === 'undefined') {\n      // Just concatinate into a string\n      body = chunkBuffers.join('');\n    } else {\n      // Initialize new buffer and add the chunks one-at-a-time.\n      body = new Buffer(dataLength);\n      for (var i = 0, pos = 0; i < chunkBuffers.length; i++) {\n        chunkBuffers[i].copy(body, pos);\n        pos += chunkBuffers[i].length;\n      }\n    }\n\n    var setBodyAndFinish = function (body) {\n      response._body = new Content({ \n        body: body,\n        type: response.getHeader(\"Content-Type\")\n      });\n      callback(response);\n    }\n\n    if (zlib && response.getHeader(\"Content-Encoding\") === 'gzip'){\n      zlib.gunzip(body, function (err, gunzippedBody) {\n        if (Iconv && response.request.encoding){\n          body = Iconv.fromEncoding(gunzippedBody,response.request.encoding);\n        } else {\n          body = gunzippedBody.toString();\n        }\n        setBodyAndFinish(body);\n      })\n    }\n    else{\n       if (response.request.encoding){\n            body = Iconv.fromEncoding(body,response.request.encoding);\n        }        \n      setBodyAndFinish(body);\n    }\n  });\n};\n\n// The `Response` object can be pretty overwhelming to view using the built-in\n// Node.js inspect method. We want to make it a bit more manageable. This\n// probably goes [too far in the other\n// direction](https://github.com/spire-io/shred/issues/2).\n\nResponse.prototype = {\n  inspect: function() {\n    var response = this;\n    var headers = this.format_headers();\n    var summary = [\"<Shred Response> \", response.status].join(\" \")\n    return [ summary, \"- Headers:\", headers].join(\"\\n\");\n  },\n  format_headers: function () {\n    var array = []\n    var headers = this._headers\n    for (var key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        var value = headers[key]\n        array.push(\"\\t\" + key + \": \" + value);\n      }\n    }\n    return array.join(\"\\n\");\n  }\n};\n\n// `Response` object properties, all of which are read-only:\nObject.defineProperties(Response.prototype, {\n  \n// - **status**. The HTTP status code for the response. \n  status: {\n    get: function() { return this._raw.statusCode; },\n    enumerable: true\n  },\n\n// - **content**. The HTTP content entity, if any. Provided as a [content\n//   object](./content.html), which will attempt to convert the entity based upon\n//   the `content-type` header. The converted value is available as\n//   `content.data`. The original raw content entity is available as\n//   `content.body`.\n  body: {\n    get: function() { return this._body; }\n  },\n  content: {\n    get: function() { return this.body; },\n    enumerable: true\n  },\n\n// - **isRedirect**. Is the response a redirect? These are responses with 3xx\n//   status and a `Location` header.\n  isRedirect: {\n    get: function() {\n      return (this.status>299\n          &&this.status<400\n          &&this.getHeader(\"Location\"));\n    },\n    enumerable: true\n  },\n\n// - **isError**. Is the response an error? These are responses with status of\n//   400 or greater.\n  isError: {\n    get: function() {\n      return (this.status === 0 || this.status > 399)\n    },\n    enumerable: true\n  }\n});\n\n// Add in the [getters for accessing the normalized headers](./headers.js).\nHeaderMixins.getters(Response);\nHeaderMixins.privateSetters(Response);\n\n// Work around Mozilla bug #608735 [https://bugzil.la/608735], which causes\n// getAllResponseHeaders() to return {} if the response is a CORS request.\n// xhr.getHeader still works correctly.\nvar getHeader = Response.prototype.getHeader;\nResponse.prototype.getHeader = function (name) {\n  return (getHeader.call(this,name) ||\n    (typeof this._raw.getHeader === 'function' && this._raw.getHeader(name)));\n};\n\nmodule.exports = Response;\n\n});\n\nrequire.define(\"/shred/content.js\", function (require, module, exports, __dirname, __filename) {\n    \n// The purpose of the `Content` object is to abstract away the data conversions\n// to and from raw content entities as strings. For example, you want to be able\n// to pass in a Javascript object and have it be automatically converted into a\n// JSON string if the `content-type` is set to a JSON-based media type.\n// Conversely, you want to be able to transparently get back a Javascript object\n// in the response if the `content-type` is a JSON-based media-type.\n\n// One limitation of the current implementation is that it [assumes the `charset` is UTF-8](https://github.com/spire-io/shred/issues/5).\n\n// The `Content` constructor takes an options object, which *must* have either a\n// `body` or `data` property and *may* have a `type` property indicating the\n// media type. If there is no `type` attribute, a default will be inferred.\nvar Content = function(options) {\n  this.body = options.body;\n  this.data = options.data;\n  this.type = options.type;\n};\n\nContent.prototype = {\n  // Treat `toString()` as asking for the `content.body`. That is, the raw content entity.\n  //\n  //     toString: function() { return this.body; }\n  //\n  // Commented out, but I've forgotten why. :/\n};\n\n\n// `Content` objects have the following attributes:\nObject.defineProperties(Content.prototype,{\n  \n// - **type**. Typically accessed as `content.type`, reflects the `content-type`\n//   header associated with the request or response. If not passed as an options\n//   to the constructor or set explicitly, it will infer the type the `data`\n//   attribute, if possible, and, failing that, will default to `text/plain`.\n  type: {\n    get: function() {\n      if (this._type) {\n        return this._type;\n      } else {\n        if (this._data) {\n          switch(typeof this._data) {\n            case \"string\": return \"text/plain\";\n            case \"object\": return \"application/json\";\n          }\n        }\n      }\n      return \"text/plain\";\n    },\n    set: function(value) {\n      this._type = value;\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **data**. Typically accessed as `content.data`, reflects the content entity\n//   converted into Javascript data. This can be a string, if the `type` is, say,\n//   `text/plain`, but can also be a Javascript object. The conversion applied is\n//   based on the `processor` attribute. The `data` attribute can also be set\n//   directly, in which case the conversion will be done the other way, to infer\n//   the `body` attribute.\n  data: {\n    get: function() {\n      if (this._body) {\n        return this.processor.parser(this._body);\n      } else {\n        return this._data;\n      }\n    },\n    set: function(data) {\n      if (this._body&&data) Errors.setDataWithBody(this);\n      this._data = data;\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **body**. Typically accessed as `content.body`, reflects the content entity\n//   as a UTF-8 string. It is the mirror of the `data` attribute. If you set the\n//   `data` attribute, the `body` attribute will be inferred and vice-versa. If\n//   you attempt to set both, an exception is raised.\n  body: {\n    get: function() {\n      if (this._data) {\n        return this.processor.stringify(this._data);\n      } else {\n        return this.processor.stringify(this._body);\n      }\n    },\n    set: function(body) {\n      if (this._data&&body) Errors.setBodyWithData(this);\n      this._body = body;\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **processor**. The functions that will be used to convert to/from `data` and\n//   `body` attributes. You can add processors. The two that are built-in are for\n//   `text/plain`, which is basically an identity transformation and\n//   `application/json` and other JSON-based media types (including custom media\n//   types with `+json`). You can add your own processors. See below.\n  processor: {\n    get: function() {\n      var processor = Content.processors[this.type];\n      if (processor) {\n        return processor;\n      } else {\n        // Return the first processor that matches any part of the\n        // content type. ex: application/vnd.foobar.baz+json will match json.\n        var main = this.type.split(\";\")[0];\n        var parts = main.split(/\\+|\\//);\n        for (var i=0, l=parts.length; i < l; i++) {\n          processor = Content.processors[parts[i]]\n        }\n        return processor || {parser:identity,stringify:toString};\n      }\n    },\n    enumerable: true\n  },\n\n// - **length**. Typically accessed as `content.length`, returns the length in\n//   bytes of the raw content entity.\n  length: {\n    get: function() {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(this.body);\n      }\n      return this.body.length;\n    }\n  }\n});\n\nContent.processors = {};\n\n// The `registerProcessor` function allows you to add your own processors to\n// convert content entities. Each processor consists of a Javascript object with\n// two properties:\n// - **parser**. The function used to parse a raw content entity and convert it\n//   into a Javascript data type.\n// - **stringify**. The function used to convert a Javascript data type into a\n//   raw content entity.\nContent.registerProcessor = function(types,processor) {\n  \n// You can pass an array of types that will trigger this processor, or just one.\n// We determine the array via duck-typing here.\n  if (types.forEach) {\n    types.forEach(function(type) {\n      Content.processors[type] = processor;\n    });\n  } else {\n    // If you didn't pass an array, we just use what you pass in.\n    Content.processors[types] = processor;\n  }\n};\n\n// Register the identity processor, which is used for text-based media types.\nvar identity = function(x) { return x; }\n  , toString = function(x) { return x.toString(); }\nContent.registerProcessor(\n  [\"text/html\",\"text/plain\",\"text\"],\n  { parser: identity, stringify: toString });\n\n// Register the JSON processor, which is used for JSON-based media types.\nContent.registerProcessor(\n  [\"application/json; charset=utf-8\",\"application/json\",\"json\"],\n  {\n    parser: function(string) {\n      return JSON.parse(string);\n    },\n    stringify: function(data) {\n      return JSON.stringify(data); }});\n\n// Error functions are defined separately here in an attempt to make the code\n// easier to read.\nvar Errors = {\n  setDataWithBody: function(object) {\n    throw new Error(\"Attempt to set data attribute of a content object \" +\n        \"when the body attributes was already set.\");\n  },\n  setBodyWithData: function(object) {\n    throw new Error(\"Attempt to set body attribute of a content object \" +\n        \"when the data attributes was already set.\");\n  }\n}\nmodule.exports = Content;\n\n});\n\nrequire.define(\"/shred/mixins/headers.js\", function (require, module, exports, __dirname, __filename) {\n    // The header mixins allow you to add HTTP header support to any object. This\n// might seem pointless: why not simply use a hash? The main reason is that, per\n// the [HTTP spec](http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2),\n// headers are case-insensitive. So, for example, `content-type` is the same as\n// `CONTENT-TYPE` which is the same as `Content-Type`. Since there is no way to\n// overload the index operator in Javascript, using a hash to represent the\n// headers means it's possible to have two conflicting values for a single\n// header.\n// \n// The solution to this is to provide explicit methods to set or get headers.\n// This also has the benefit of allowing us to introduce additional variations,\n// including snake case, which we automatically convert to what Matthew King has\n// dubbed \"corset case\" - the hyphen-separated names with initial caps:\n// `Content-Type`. We use corset-case just in case we're dealing with servers\n// that haven't properly implemented the spec.\n\n// Convert headers to corset-case. **Example:** `CONTENT-TYPE` will be converted\n// to `Content-Type`.\n\nvar corsetCase = function(string) {\n  return string;//.toLowerCase()\n      //.replace(\"_\",\"-\")\n      // .replace(/(^|-)(\\w)/g, \n          // function(s) { return s.toUpperCase(); });\n};\n\n// We suspect that `initializeHeaders` was once more complicated ...\nvar initializeHeaders = function(object) {\n  return {};\n};\n\n// Access the `_headers` property using lazy initialization. **Warning:** If you\n// mix this into an object that is using the `_headers` property already, you're\n// going to have trouble.\nvar $H = function(object) {\n  return object._headers||(object._headers=initializeHeaders(object));\n};\n\n// Hide the implementations as private functions, separate from how we expose them.\n\n// The \"real\" `getHeader` function: get the header after normalizing the name.\nvar getHeader = function(object,name) {\n  return $H(object)[corsetCase(name)];\n};\n\n// The \"real\" `getHeader` function: get one or more headers, or all of them\n// if you don't ask for any specifics. \nvar getHeaders = function(object,names) {\n  var keys = (names && names.length>0) ? names : Object.keys($H(object));\n  var hash = keys.reduce(function(hash,key) {\n    hash[key] = getHeader(object,key);\n    return hash;\n  },{});\n  // Freeze the resulting hash so you don't mistakenly think you're modifying\n  // the real headers.\n  Object.freeze(hash);\n  return hash;\n};\n\n// The \"real\" `setHeader` function: set a header, after normalizing the name.\nvar setHeader = function(object,name,value) {\n  $H(object)[corsetCase(name)] = value;\n  return object;\n};\n\n// The \"real\" `setHeaders` function: set multiple headers based on a hash.\nvar setHeaders = function(object,hash) {\n  for( var key in hash ) { setHeader(object,key,hash[key]); };\n  return this;\n};\n\n// Here's where we actually bind the functionality to an object. These mixins work by\n// exposing mixin functions. Each function mixes in a specific batch of features.\nmodule.exports = {\n  \n  // Add getters.\n  getters: function(constructor) {\n    constructor.prototype.getHeader = function(name) { return getHeader(this,name); };\n    constructor.prototype.getHeaders = function() { return getHeaders(this,arguments); };\n  },\n  // Add setters but as \"private\" methods.\n  privateSetters: function(constructor) {\n    constructor.prototype._setHeader = function(key,value) { return setHeader(this,key,value); };\n    constructor.prototype._setHeaders = function(hash) { return setHeaders(this,hash); };\n  },\n  // Add setters.\n  setters: function(constructor) {\n    constructor.prototype.setHeader = function(key,value) { return setHeader(this,key,value); };\n    constructor.prototype.setHeaders = function(hash) { return setHeaders(this,hash); };\n  },\n  // Add both getters and setters.\n  gettersAndSetters: function(constructor) {\n    constructor.prototype.getHeader = function(name) { return getHeader(this,name); };\n    constructor.prototype.getHeaders = function() { return getHeaders(this,arguments); };\n    constructor.prototype.setHeader = function(key,value) { return setHeader(this,key,value); };\n    constructor.prototype.setHeaders = function(hash) { return setHeaders(this,hash); };\n  },\n};\n\n});\n\nrequire.define(\"/node_modules/iconv-lite/package.json\", function (require, module, exports, __dirname, __filename) {\n    module.exports = {}\n});\n\nrequire.define(\"/node_modules/iconv-lite/index.js\", function (require, module, exports, __dirname, __filename) {\n    // Module exports\nvar iconv = module.exports = {\n    toEncoding: function(str, encoding) {\n        return iconv.getCodec(encoding).toEncoding(str);\n    },\n    fromEncoding: function(buf, encoding) {\n        return iconv.getCodec(encoding).fromEncoding(buf);\n    },\n    \n    defaultCharUnicode: '�',\n    defaultCharSingleByte: '?',\n    \n    // Get correct codec for given encoding.\n    getCodec: function(encoding) {\n        var enc = encoding || \"utf8\";\n        var codecOptions = undefined;\n        while (1) {\n            if (getType(enc) === \"String\")\n                enc = enc.replace(/[- ]/g, \"\").toLowerCase();\n            var codec = iconv.encodings[enc];\n            var type = getType(codec);\n            if (type === \"String\") {\n                // Link to other encoding.\n                codecOptions = {originalEncoding: enc};\n                enc = codec;\n            }\n            else if (type === \"Object\" && codec.type != undefined) {\n                // Options for other encoding.\n                codecOptions = codec;\n                enc = codec.type;\n            } \n            else if (type === \"Function\")\n                // Codec itself.\n                return codec(codecOptions);\n            else\n                throw new Error(\"Encoding not recognized: '\" + encoding + \"' (searched as: '\"+enc+\"')\");\n        }\n    },\n    \n    // Define basic encodings\n    encodings: {\n        internal: function(options) {\n            return {\n                toEncoding: function(str) {\n                    return new Buffer(ensureString(str), options.originalEncoding);\n                },\n                fromEncoding: function(buf) {\n                    return ensureBuffer(buf).toString(options.originalEncoding);\n                }\n            };\n        },\n        utf8: \"internal\",\n        ucs2: \"internal\",\n        binary: \"internal\",\n        ascii: \"internal\",\n        base64: \"internal\",\n        \n        // Codepage single-byte encodings.\n        singlebyte: function(options) {\n            // Prepare chars if needed\n            if (!options.chars || (options.chars.length !== 128 && options.chars.length !== 256))\n                throw new Error(\"Encoding '\"+options.type+\"' has incorrect 'chars' (must be of len 128 or 256)\");\n            \n            if (options.chars.length === 128)\n                options.chars = asciiString + options.chars;\n            \n            if (!options.charsBuf) {\n                options.charsBuf = new Buffer(options.chars, 'ucs2');\n            }\n            \n            if (!options.revCharsBuf) {\n                options.revCharsBuf = new Buffer(65536);\n                var defChar = iconv.defaultCharSingleByte.charCodeAt(0);\n                for (var i = 0; i < options.revCharsBuf.length; i++)\n                    options.revCharsBuf[i] = defChar;\n                for (var i = 0; i < options.chars.length; i++)\n                    options.revCharsBuf[options.chars.charCodeAt(i)] = i;\n            }\n            \n            return {\n                toEncoding: function(str) {\n                    str = ensureString(str);\n                    \n                    var buf = new Buffer(str.length);\n                    var revCharsBuf = options.revCharsBuf;\n                    for (var i = 0; i < str.length; i++)\n                        buf[i] = revCharsBuf[str.charCodeAt(i)];\n                    \n                    return buf;\n                },\n                fromEncoding: function(buf) {\n                    buf = ensureBuffer(buf);\n                    \n                    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n                    var charsBuf = options.charsBuf;\n                    var newBuf = new Buffer(buf.length*2);\n                    var idx1 = 0, idx2 = 0;\n                    for (var i = 0, _len = buf.length; i < _len; i++) {\n                        idx1 = buf[i]*2; idx2 = i*2;\n                        newBuf[idx2] = charsBuf[idx1];\n                        newBuf[idx2+1] = charsBuf[idx1+1];\n                    }\n                    return newBuf.toString('ucs2');\n                }\n            };\n        },\n\n        // Codepage double-byte encodings.\n        table: function(options) {\n            var table = options.table, key, revCharsTable = options.revCharsTable;\n            if (!table) {\n                throw new Error(\"Encoding '\" + options.type +\"' has incorect 'table' option\");\n            }\n            if(!revCharsTable) {\n                revCharsTable = options.revCharsTable = {};\n                for (key in table) {\n                    revCharsTable[table[key]] = parseInt(key);\n                }\n            }\n            \n            return {\n                toEncoding: function(str) {\n                    str = ensureString(str);\n                    var strLen = str.length;\n                    var bufLen = strLen;\n                    for (var i = 0; i < strLen; i++)\n                        if (str.charCodeAt(i) >> 7)\n                            bufLen++;\n\n                    var newBuf = new Buffer(bufLen), gbkcode, unicode, \n                        defaultChar = revCharsTable[iconv.defaultCharUnicode.charCodeAt(0)];\n\n                    for (var i = 0, j = 0; i < strLen; i++) {\n                        unicode = str.charCodeAt(i);\n                        if (unicode >> 7) {\n                            gbkcode = revCharsTable[unicode] || defaultChar;\n                            newBuf[j++] = gbkcode >> 8; //high byte;\n                            newBuf[j++] = gbkcode & 0xFF; //low byte\n                        } else {//ascii\n                            newBuf[j++] = unicode;\n                        }\n                    }\n                    return newBuf;\n                },\n                fromEncoding: function(buf) {\n                    buf = ensureBuffer(buf);\n                    var bufLen = buf.length, strLen = 0;\n                    for (var i = 0; i < bufLen; i++) {\n                        strLen++;\n                        if (buf[i] & 0x80) //the high bit is 1, so this byte is gbkcode's high byte.skip next byte\n                            i++;\n                    }\n                    var newBuf = new Buffer(strLen*2), unicode, gbkcode,\n                        defaultChar = iconv.defaultCharUnicode.charCodeAt(0);\n                    \n                    for (var i = 0, j = 0; i < bufLen; i++, j+=2) {\n                        gbkcode = buf[i];\n                        if (gbkcode & 0x80) {\n                            gbkcode = (gbkcode << 8) + buf[++i];\n                            unicode = table[gbkcode] || defaultChar;\n                        } else {\n                            unicode = gbkcode;\n                        }\n                        newBuf[j] = unicode & 0xFF; //low byte\n                        newBuf[j+1] = unicode >> 8; //high byte\n                    }\n                    return newBuf.toString('ucs2');\n                }\n            }\n        }\n    }\n};\n\n// Add aliases to convert functions\niconv.encode = iconv.toEncoding;\niconv.decode = iconv.fromEncoding;\n\n// Load other encodings from files in /encodings dir.\nvar encodingsDir = __dirname+\"/encodings/\",\n    fs = require('fs');\nfs.readdirSync(encodingsDir).forEach(function(file) {\n    if(fs.statSync(encodingsDir + file).isDirectory()) return;\n    var encodings = require(encodingsDir + file)\n    for (var key in encodings)\n        iconv.encodings[key] = encodings[key]\n});\n\n// Utilities\nvar asciiString = '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f'+\n              ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f';\n\nvar ensureBuffer = function(buf) {\n    buf = buf || new Buffer(0);\n    return (buf instanceof Buffer) ? buf : new Buffer(buf.toString(), \"utf8\");\n}\n\nvar ensureString = function(str) {\n    str = str || \"\";\n    return (str instanceof String) ? str : str.toString((str instanceof Buffer) ? 'utf8' : undefined);\n}\n\nvar getType = function(obj) {\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\n\n\n});\n\nrequire.define(\"/node_modules/http-browserify/package.json\", function (require, module, exports, __dirname, __filename) {\n    module.exports = {\"main\":\"index.js\",\"browserify\":\"browser.js\"}\n});\n\nrequire.define(\"/node_modules/http-browserify/browser.js\", function (require, module, exports, __dirname, __filename) {\n    var http = module.exports;\nvar EventEmitter = require('events').EventEmitter;\nvar Request = require('./lib/request');\n\nhttp.request = function (params, cb) {\n    if (!params) params = {};\n    if (!params.host) params.host = window.location.host.split(':')[0];\n    if (!params.port) params.port = window.location.port;\n    \n    var req = new Request(new xhrHttp, params);\n    if (cb) req.on('response', cb);\n    return req;\n};\n\nhttp.get = function (params, cb) {\n    params.method = 'GET';\n    var req = http.request(params, cb);\n    req.end();\n    return req;\n};\n\nvar xhrHttp = (function () {\n    if (typeof window === 'undefined') {\n        throw new Error('no window object present');\n    }\n    else if (window.XMLHttpRequest) {\n        return window.XMLHttpRequest;\n    }\n    else if (window.ActiveXObject) {\n        var axs = [\n            'Msxml2.XMLHTTP.6.0',\n            'Msxml2.XMLHTTP.3.0',\n            'Microsoft.XMLHTTP'\n        ];\n        for (var i = 0; i < axs.length; i++) {\n            try {\n                var ax = new(window.ActiveXObject)(axs[i]);\n                return function () {\n                    if (ax) {\n                        var ax_ = ax;\n                        ax = null;\n                        return ax_;\n                    }\n                    else {\n                        return new(window.ActiveXObject)(axs[i]);\n                    }\n                };\n            }\n            catch (e) {}\n        }\n        throw new Error('ajax not supported in this browser')\n    }\n    else {\n        throw new Error('ajax not supported in this browser');\n    }\n})();\n\nhttp.STATUS_CODES = {\n    100 : 'Continue',\n    101 : 'Switching Protocols',\n    102 : 'Processing', // RFC 2518, obsoleted by RFC 4918\n    200 : 'OK',\n    201 : 'Created',\n    202 : 'Accepted',\n    203 : 'Non-Authoritative Information',\n    204 : 'No Content',\n    205 : 'Reset Content',\n    206 : 'Partial Content',\n    207 : 'Multi-Status', // RFC 4918\n    300 : 'Multiple Choices',\n    301 : 'Moved Permanently',\n    302 : 'Moved Temporarily',\n    303 : 'See Other',\n    304 : 'Not Modified',\n    305 : 'Use Proxy',\n    307 : 'Temporary Redirect',\n    400 : 'Bad Request',\n    401 : 'Unauthorized',\n    402 : 'Payment Required',\n    403 : 'Forbidden',\n    404 : 'Not Found',\n    405 : 'Method Not Allowed',\n    406 : 'Not Acceptable',\n    407 : 'Proxy Authentication Required',\n    408 : 'Request Time-out',\n    409 : 'Conflict',\n    410 : 'Gone',\n    411 : 'Length Required',\n    412 : 'Precondition Failed',\n    413 : 'Request Entity Too Large',\n    414 : 'Request-URI Too Large',\n    415 : 'Unsupported Media Type',\n    416 : 'Requested Range Not Satisfiable',\n    417 : 'Expectation Failed',\n    418 : 'I\\'m a teapot', // RFC 2324\n    422 : 'Unprocessable Entity', // RFC 4918\n    423 : 'Locked', // RFC 4918\n    424 : 'Failed Dependency', // RFC 4918\n    425 : 'Unordered Collection', // RFC 4918\n    426 : 'Upgrade Required', // RFC 2817\n    500 : 'Internal Server Error',\n    501 : 'Not Implemented',\n    502 : 'Bad Gateway',\n    503 : 'Service Unavailable',\n    504 : 'Gateway Time-out',\n    505 : 'HTTP Version not supported',\n    506 : 'Variant Also Negotiates', // RFC 2295\n    507 : 'Insufficient Storage', // RFC 4918\n    509 : 'Bandwidth Limit Exceeded',\n    510 : 'Not Extended' // RFC 2774\n};\n\n});\n\nrequire.define(\"/node_modules/http-browserify/lib/request.js\", function (require, module, exports, __dirname, __filename) {\n    var EventEmitter = require('events').EventEmitter;\nvar Response = require('./response');\nvar isSafeHeader = require('./isSafeHeader');\n\nvar Request = module.exports = function (xhr, params) {\n    var self = this;\n    self.xhr = xhr;\n    self.body = '';\n    \n    var uri = params.host + ':' + params.port + (params.path || '/');\n    \n    xhr.open(\n        params.method || 'GET',\n        (params.scheme || 'http') + '://' + uri,\n        true\n    );\n    \n    if (params.headers) {\n        Object.keys(params.headers).forEach(function (key) {\n            if (!isSafeHeader(key)) return;\n            var value = params.headers[key];\n            if (Array.isArray(value)) {\n                value.forEach(function (v) {\n                    xhr.setRequestHeader(key, v);\n                });\n            }\n            else xhr.setRequestHeader(key, value)\n        });\n    }\n    \n    var res = new Response(xhr);\n    res.on('ready', function () {\n        self.emit('response', res);\n    });\n    \n    xhr.onreadystatechange = function () {\n        res.handle(xhr);\n    };\n};\n\nRequest.prototype = new EventEmitter;\n\nRequest.prototype.setHeader = function (key, value) {\n    if ((Array.isArray && Array.isArray(value))\n    || value instanceof Array) {\n        for (var i = 0; i < value.length; i++) {\n            this.xhr.setRequestHeader(key, value[i]);\n        }\n    }\n    else {\n        this.xhr.setRequestHeader(key, value);\n    }\n};\n\nRequest.prototype.write = function (s) {\n    this.body += s;\n};\n\nRequest.prototype.end = function (s) {\n    if (s !== undefined) this.write(s);\n    this.xhr.send(this.body);\n};\n\n});\n\nrequire.define(\"/node_modules/http-browserify/lib/response.js\", function (require, module, exports, __dirname, __filename) {\n    var EventEmitter = require('events').EventEmitter;\nvar isSafeHeader = require('./isSafeHeader');\n\nvar Response = module.exports = function (xhr) {\n    this.xhr = xhr;\n    this.offset = 0;\n};\n\nResponse.prototype = new EventEmitter;\n\nvar capable = {\n    streaming : true,\n    status2 : true\n};\n\nfunction parseHeaders (xhr) {\n    var lines = xhr.getAllResponseHeaders().split(/\\r?\\n/);\n    var headers = {};\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        if (line === '') continue;\n        \n        var m = line.match(/^([^:]+):\\s*(.*)/);\n        if (m) {\n            var key = m[1].toLowerCase(), value = m[2];\n            \n            if (headers[key] !== undefined) {\n                if ((Array.isArray && Array.isArray(headers[key]))\n                || headers[key] instanceof Array) {\n                    headers[key].push(value);\n                }\n                else {\n                    headers[key] = [ headers[key], value ];\n                }\n            }\n            else {\n                headers[key] = value;\n            }\n        }\n        else {\n            headers[line] = true;\n        }\n    }\n    return headers;\n}\n\nResponse.prototype.getHeader = function (key) {\n    var header = this.headers ? this.headers[key.toLowerCase()] : null;\n    if (header) return header;\n\n    // Work around Mozilla bug #608735 [https://bugzil.la/608735], which causes\n    // getAllResponseHeaders() to return {} if the response is a CORS request.\n    // xhr.getHeader still works correctly.\n    if (isSafeHeader(key)) {\n      return this.xhr.getResponseHeader(key);\n    }\n    return null;\n};\n\nResponse.prototype.handle = function () {\n    var xhr = this.xhr;\n    if (xhr.readyState === 2 && capable.status2) {\n        try {\n            this.statusCode = xhr.status;\n            this.headers = parseHeaders(xhr);\n        }\n        catch (err) {\n            capable.status2 = false;\n        }\n        \n        if (capable.status2) {\n            this.emit('ready');\n        }\n    }\n    else if (capable.streaming && xhr.readyState === 3) {\n        try {\n            if (!this.statusCode) {\n                this.statusCode = xhr.status;\n                this.headers = parseHeaders(xhr);\n                this.emit('ready');\n            }\n        }\n        catch (err) {}\n        \n        try {\n            this.write();\n        }\n        catch (err) {\n            capable.streaming = false;\n        }\n    }\n    else if (xhr.readyState === 4) {\n        if (!this.statusCode) {\n            this.statusCode = xhr.status;\n            this.emit('ready');\n        }\n        this.write();\n        \n        if (xhr.error) {\n            this.emit('error', xhr.responseText);\n        }\n        else this.emit('end');\n    }\n};\n\nResponse.prototype.write = function () {\n    var xhr = this.xhr;\n    if (xhr.responseText.length > this.offset) {\n        this.emit('data', xhr.responseText.slice(this.offset));\n        this.offset = xhr.responseText.length;\n    }\n};\n\n});\n\nrequire.define(\"/node_modules/http-browserify/lib/isSafeHeader.js\", function (require, module, exports, __dirname, __filename) {\n    // Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html\nvar unsafeHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"cookie\",\n    \"cookie2\",\n    \"content-transfer-encoding\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"set-cookie\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"user-agent\",\n    \"via\"\n];\n\nmodule.exports = function (headerName) {\n    if (!headerName) return false;\n    return (unsafeHeaders.indexOf(headerName.toLowerCase()) === -1)\n};\n\n});\n\nrequire.alias(\"http-browserify\", \"/node_modules/http\");\n\nrequire.alias(\"http-browserify\", \"/node_modules/https\");","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/swagger-ui/lib/swagger-client.js":"// swagger-client.js\n// version 2.1.0-alpha.2\n/**\n * Array Model\n **/\nvar ArrayModel = function(definition) {\n  this.name = \"name\";\n  this.definition = definition || {};\n  this.properties = [];\n  this.type;\n  this.ref;\n\n  var requiredFields = definition.enum || [];\n  var items = definition.items;\n  if(items) {\n    var type = items.type;\n    if(items.type) {\n      this.type = typeFromJsonSchema(type.type, type.format);\n    }\n    else {\n      this.ref = items['$ref'];\n    }\n  }\n}\n\nArrayModel.prototype.createJSONSample = function(modelsToIgnore) {\n  var result;\n  modelsToIgnore = (modelsToIgnore||{})\n  if(this.type) {\n    result = type;\n  }\n  else if (this.ref) {\n    var name = simpleRef(this.ref);\n    result = models[name].createJSONSample();\n  }\n  return [ result ];\n};\n\nArrayModel.prototype.getSampleValue = function(modelsToIgnore) {\n  var result;\n  modelsToIgnore = (modelsToIgnore || {})\n  if(this.type) {\n    result = type;\n  }\n  else if (this.ref) {\n    var name = simpleRef(this.ref);\n    result = models[name].getSampleValue(modelsToIgnore);\n  }\n  return [ result ];\n}\n\nArrayModel.prototype.getMockSignature = function(modelsToIgnore) {\n  var propertiesStr = [];\n\n  if(this.ref) {\n    return models[simpleRef(this.ref)].getMockSignature();\n  }\n};\n\n/**\n * SwaggerAuthorizations applys the correct authorization to an operation being executed\n */\nvar SwaggerAuthorizations = function() {\n  this.authz = {};\n};\n\nSwaggerAuthorizations.prototype.add = function(name, auth) {\n  this.authz[name] = auth;\n  return auth;\n};\n\nSwaggerAuthorizations.prototype.remove = function(name) {\n  return delete this.authz[name];\n};\n\nSwaggerAuthorizations.prototype.apply = function(obj, authorizations) {\n  var status = null;\n  var key;\n\n  // if the \"authorizations\" key is undefined, or has an empty array, add all keys\n  if(typeof authorizations === 'undefined' || Object.keys(authorizations).length == 0) {\n    for (key in this.authz) {\n      value = this.authz[key];\n      result = value.apply(obj, authorizations);\n      if (result === true)\n        status = true;\n    }\n  }\n  else {\n    if(Array.isArray(authorizations)) {\n      var i;\n      for(i = 0; i < authorizations.length; i++) {\n        var auth = authorizations[i];\n        log(auth);\n        for (key in this.authz) {\n          var value = this.authz[key];\n          if(typeof value !== 'undefined') {\n            result = value.apply(obj, authorizations);\n            if (result === true)\n              status = true;\n          }\n        }\n      }\n    }\n  }\n\n  return status;\n};\n\n/**\n * ApiKeyAuthorization allows a query param or header to be injected\n */\nvar ApiKeyAuthorization = function(name, value, type) {\n  this.name = name;\n  this.value = value;\n  this.type = type;\n};\n\nApiKeyAuthorization.prototype.apply = function(obj, authorizations) {\n  if (this.type === \"query\") {\n    if (obj.url.indexOf('?') > 0)\n      obj.url = obj.url + \"&\" + this.name + \"=\" + this.value;\n    else\n      obj.url = obj.url + \"?\" + this.name + \"=\" + this.value;\n    return true;\n  } else if (this.type === \"header\") {\n    obj.headers[this.name] = this.value;\n    return true;\n  }\n};\n\nvar CookieAuthorization = function(cookie) {\n  this.cookie = cookie;\n}\n\nCookieAuthorization.prototype.apply = function(obj, authorizations) {\n  obj.cookieJar = obj.cookieJar || CookieJar();\n  obj.cookieJar.setCookie(this.cookie);\n  return true;\n}\n\n/**\n * Password Authorization is a basic auth implementation\n */\nvar PasswordAuthorization = function(name, username, password) {\n  this.name = name;\n  this.username = username;\n  this.password = password;\n  this._btoa = null;\n  if (typeof window !== 'undefined')\n    this._btoa = btoa;\n  else\n    this._btoa = require(\"btoa\");\n};\n\nPasswordAuthorization.prototype.apply = function(obj, authorizations) {\n  var base64encoder = this._btoa;\n  obj.headers[\"Authorization\"] = \"Basic \" + base64encoder(this.username + \":\" + this.password);\n  return true;\n};var __bind = function(fn, me){\n  return function(){\n    return fn.apply(me, arguments);\n  };\n};\n\nfail = function(message) {\n  log(message);\n}\n\nlog = function(){\n  log.history = log.history || [];\n  log.history.push(arguments);\n  if(this.console){\n    console.log( Array.prototype.slice.call(arguments)[0] );\n  }\n};\n\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function(obj, start) {\n    for (var i = (start || 0), j = this.length; i < j; i++) {\n      if (this[i] === obj) { return i; }\n    }\n    return -1;\n  }\n}\n\nif (!('filter' in Array.prototype)) {\n  Array.prototype.filter= function(filter, that /*opt*/) {\n    var other= [], v;\n    for (var i=0, n= this.length; i<n; i++)\n      if (i in this && filter.call(that, v= this[i], i, this))\n        other.push(v);\n    return other;\n  };\n}\n\nif (!('map' in Array.prototype)) {\n  Array.prototype.map= function(mapper, that /*opt*/) {\n    var other= new Array(this.length);\n    for (var i= 0, n= this.length; i<n; i++)\n      if (i in this)\n        other[i]= mapper.call(that, this[i], i, this);\n    return other;\n  };\n}\n\nObject.keys = Object.keys || (function () {\n  var hasOwnProperty = Object.prototype.hasOwnProperty,\n    hasDontEnumBug = !{toString:null}.propertyIsEnumerable(\"toString\"),\n    DontEnums = [\n      'toString',\n      'toLocaleString',\n      'valueOf',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'constructor'\n    ],\n  DontEnumsLength = DontEnums.length;\n\n  return function (o) {\n    if (typeof o != \"object\" && typeof o != \"function\" || o === null)\n      throw new TypeError(\"Object.keys called on a non-object\");\n\n    var result = [];\n    for (var name in o) {\n      if (hasOwnProperty.call(o, name))\n        result.push(name);\n    }\n\n    if (hasDontEnumBug) {\n      for (var i = 0; i < DontEnumsLength; i++) {\n        if (hasOwnProperty.call(o, DontEnums[i]))\n          result.push(DontEnums[i]);\n      }\n    }\n\n    return result;\n  };\n})();\n/**\n * PrimitiveModel\n **/\nvar PrimitiveModel = function(definition) {\n  this.name = \"name\";\n  this.definition = definition || {};\n  this.properties = [];\n  this.type;\n\n  var requiredFields = definition.enum || [];\n  this.type = typeFromJsonSchema(definition.type, definition.format);\n}\n\nPrimitiveModel.prototype.createJSONSample = function(modelsToIgnore) {\n  var result = this.type;\n  return result;\n};\n\nPrimitiveModel.prototype.getSampleValue = function() {\n  var result = this.type;\n  return null;\n}\n\nPrimitiveModel.prototype.getMockSignature = function(modelsToIgnore) {\n  var propertiesStr = [];\n  var i;\n  for (i = 0; i < this.properties.length; i++) {\n    var prop = this.properties[i];\n    propertiesStr.push(prop.toString());\n  }\n\n  var strong = '<span class=\"strong\">';\n  var stronger = '<span class=\"stronger\">';\n  var strongClose = '</span>';\n  var classOpen = strong + this.name + ' {' + strongClose;\n  var classClose = strong + '}' + strongClose;\n  var returnVal = classOpen + '<div>' + propertiesStr.join(',</div><div>') + '</div>' + classClose;\n\n  if (!modelsToIgnore)\n    modelsToIgnore = {};\n  modelsToIgnore[this.name] = this;\n  var i;\n  for (i = 0; i < this.properties.length; i++) {\n    var prop = this.properties[i];\n    var ref = prop['$ref'];\n    var model = models[ref];\n    if (model && typeof modelsToIgnore[ref] === 'undefined') {\n      returnVal = returnVal + ('<br>' + model.getMockSignature(modelsToIgnore));\n    }\n  }\n  return returnVal;\n};var SwaggerClient = function(url, options) {\n  this.isBuilt = false;\n  this.url = null;\n  this.debug = false;\n  this.basePath = null;\n  this.authorizations = null;\n  this.authorizationScheme = null;\n  this.isValid = false;\n  this.info = null;\n  this.useJQuery = false;\n  this.models = models;\n\n  options = (options||{});\n  if (url)\n    if (url.url) options = url;\n    else this.url = url;\n  else options = url;\n\n  if (options.url != null)\n    this.url = options.url;\n\n  if (options.success != null)\n    this.success = options.success;\n\n  if (typeof options.useJQuery === 'boolean')\n    this.useJQuery = options.useJQuery;\n\n  this.failure = options.failure != null ? options.failure : function() {};\n  this.progress = options.progress != null ? options.progress : function() {};\n  this.spec = options.spec;\n\n  if (options.success != null)\n    this.build();\n}\n\nSwaggerClient.prototype.build = function() {\n  var self = this;\n  this.progress('fetching resource list: ' + this.url);\n  var obj = {\n    useJQuery: this.useJQuery,\n    url: this.url,\n    method: \"get\",\n    headers: {\n      accept: \"application/json, */*\"\n    },\n    on: {\n      error: function(response) {\n        if (self.url.substring(0, 4) !== 'http')\n          return self.fail('Please specify the protocol for ' + self.url);\n        else if (response.status === 0)\n          return self.fail('Can\\'t read from server.  It may not have the appropriate access-control-origin settings.');\n        else if (response.status === 404)\n          return self.fail('Can\\'t read swagger JSON from ' + self.url);\n        else\n          return self.fail(response.status + ' : ' + response.statusText + ' ' + self.url);\n      },\n      response: function(resp) {\n        var responseObj = resp.obj || JSON.parse(resp.data);\n        self.swaggerVersion = responseObj.swaggerVersion;\n\n        if(responseObj.swagger && parseInt(responseObj.swagger) === 2) {\n          self.swaggerVersion = responseObj.swagger;\n          self.buildFromSpec(responseObj);\n          self.isValid = true;\n        }\n        else {\n          self.isValid = false;\n          self.failure();\n        }\n      }\n    }\n  };\n  if(this.spec) {\n    var self = this;\n    setTimeout(function() { self.buildFromSpec(self.spec); }, 10);\n  }\n  else {\n    var e = (typeof window !== 'undefined' ? window : exports);\n    var status = e.authorizations.apply(obj);\n    new SwaggerHttp().execute(obj);\n  }\n\n  return this;\n};\n\nSwaggerClient.prototype.buildFromSpec = function(response) {\n  if(this.isBuilt) return this;\n\n  this.info = response.info || {};\n  this.title = response.title || '';\n  this.host = response.host || '';\n  this.schemes = response.schemes || [];\n  this.scheme;\n  this.basePath = response.basePath || '';\n  this.apis = {};\n  this.apisArray = [];\n  this.consumes = response.consumes;\n  this.produces = response.produces;\n  this.securityDefinitions = response.securityDefinitions;\n\n  // legacy support\n  this.authSchemes = response.securityDefinitions;\n\n  var location = this.parseUri(this.url);\n  if(typeof this.schemes === 'undefined' || this.schemes.length === 0) {\n    this.scheme = location.scheme;\n  }\n  else {\n    this.scheme = this.schemes[0];\n  }\n\n  if(typeof this.host === 'undefined' || this.host === '') {\n    this.host = location.host;\n    if (location.port) {\n      this.host = this.host + ':' + location.port;\n    }\n  }\n\n  this.definitions = response.definitions;\n  var key;\n  for(key in this.definitions) {\n    var model = new Model(key, this.definitions[key]);\n    if(model) {\n      models[key] = model;\n    }\n  }\n\n  // get paths, create functions for each operationId\n  var path;\n  var operations = [];\n  for(path in response.paths) {\n    if(typeof response.paths[path] === 'object') {\n      var httpMethod;\n      for(httpMethod in response.paths[path]) {\n        var operation = response.paths[path][httpMethod];\n        var tags = operation.tags;\n        if(typeof tags === 'undefined') {\n          operation.tags = [ 'default' ];\n          tags = operation.tags;\n        }\n        var operationId = this.idFromOp(path, httpMethod, operation);\n        var operationObject = new Operation (\n          this,\n          operationId,\n          httpMethod,\n          path,\n          operation,\n          this.definitions\n        );\n        // bind this operation's execute command to the api\n        if(tags.length > 0) {\n          var i;\n          for(i = 0; i < tags.length; i++) {\n            var tag = this.tagFromLabel(tags[i]);\n            var operationGroup = this[tag];\n            if(typeof operationGroup === 'undefined') {\n              this[tag] = [];\n              operationGroup = this[tag];\n              operationGroup.label = tag;\n              operationGroup.apis = [];\n              this[tag].help = this.help.bind(operationGroup);\n              this.apisArray.push(new OperationGroup(tag, operationObject));\n            }\n            operationGroup[operationId] = operationObject.execute.bind(operationObject);\n            operationGroup[operationId].help = operationObject.help.bind(operationObject);\n            operationGroup.apis.push(operationObject);\n\n            // legacy UI feature\n            var j;\n            var api;\n            for(j = 0; j < this.apisArray.length; j++) {\n              if(this.apisArray[j].tag === tag) {\n                api = this.apisArray[j];\n              }\n            }\n            if(api) {\n              api.operationsArray.push(operationObject);\n            }\n          }\n        }\n        else {\n          log('no group to bind to');\n        }\n      }\n    }\n  }\n  this.isBuilt = true;\n  if (this.success)\n    this.success();\n  return this;\n}\n\nSwaggerClient.prototype.parseUri = function(uri) {\n  var urlParseRE = /^(((([^:\\/#\\?]+:)?(?:(\\/\\/)((?:(([^:@\\/#\\?]+)(?:\\:([^:@\\/#\\?]+))?)@)?(([^:\\/#\\?\\]\\[]+|\\[[^\\/\\]@#?]+\\])(?:\\:([0-9]+))?))?)?)?((\\/?(?:[^\\/\\?#]+\\/+)*)([^\\?#]*)))?(\\?[^#]+)?)(#.*)?/;\n  var parts = urlParseRE.exec(uri);\n  return {\n    scheme: parts[4].replace(':',''),\n    host: parts[11],\n    port: parts[12],\n    path: parts[15]\n  };\n}\n\nSwaggerClient.prototype.help = function() {\n  var i;\n  log('operations for the \"' + this.label + '\" tag');\n  for(i = 0; i < this.apis.length; i++) {\n    var api = this.apis[i];\n    log('  * ' + api.nickname + ': ' + api.operation.summary);\n  }\n}\n\nSwaggerClient.prototype.tagFromLabel = function(label) {\n  return label;\n}\n\nSwaggerClient.prototype.idFromOp = function(path, httpMethod, op) {\n  if(typeof op.operationId !== 'undefined') {\n    return (op.operationId);\n  }\n  else {\n    return path.substring(1).replace(/\\//g, \"_\").replace(/\\{/g, \"\").replace(/\\}/g, \"\") + \"_\" + httpMethod;\n  }\n}\n\nSwaggerClient.prototype.fail = function(message) {\n  this.failure(message);\n  throw message;\n};\n\nvar OperationGroup = function(tag, operation) {\n  this.tag = tag;\n  this.path = tag;\n  this.name = tag;\n  this.operation = operation;\n  this.operationsArray = [];\n\n  this.description = operation.description || \"\";\n}\n\nvar Operation = function(parent, operationId, httpMethod, path, args, definitions) {\n  var errors = [];\n  this.operation = args;\n  this.deprecated = args.deprecated;\n  this.consumes = args.consumes;\n  this.produces = args.produces;\n  this.parent = parent;\n  this.host = parent.host;\n  this.schemes = parent.schemes;\n  this.scheme = parent.scheme || 'http';\n  this.basePath = parent.basePath;\n  this.nickname = (operationId||errors.push('Operations must have a nickname.'));\n  this.method = (httpMethod||errors.push('Operation ' + operationId + ' is missing method.'));\n  this.path = (path||errors.push('Operation ' + nickname + ' is missing path.'));\n  this.parameters = args != null ? (args.parameters||[]) : {};\n  this.summary = args.summary || '';\n  this.responses = (args.responses||{});\n  this.type = null;\n  this.security = args.security;\n  this.authorizations = args.security;\n  this.description = args.description;\n\n  var i;\n  for(i = 0; i < this.parameters.length; i++) {\n    var param = this.parameters[i];\n    if(param.type === 'array') {\n      param.isList = true;\n      param.allowMultiple = true;\n    }\n    var innerType = this.getType(param);\n    if(innerType.toString().toLowerCase() === 'boolean') {\n      param.allowableValues = {};\n      param.isList = true;\n      param.enum = [\"true\", \"false\"];\n    }\n    if(typeof param.enum !== 'undefined') {\n      var id;\n      param.allowableValues = {};\n      param.allowableValues.values = [];\n      param.allowableValues.descriptiveValues = [];\n      for(id = 0; id < param.enum.length; id++) {\n        var value = param.enum[id];\n        var isDefault = (value === param.default) ? true : false;\n        param.allowableValues.values.push(value);\n        param.allowableValues.descriptiveValues.push({value : value, isDefault: isDefault});\n      }\n    }\n    if(param.type === 'array' && typeof param.allowableValues === 'undefined') {\n      // can't show as a list if no values to select from\n      delete param.isList;\n      delete param.allowMultiple;\n    }\n    param.signature = this.getSignature(innerType, models);\n    param.sampleJSON = this.getSampleJSON(innerType, models);\n    param.responseClassSignature = param.signature;\n  }\n\n  var response;\n  var model;\n  var responses = this.responses;\n\n  if(responses['200']) {\n    response = responses['200'];\n    defaultResponseCode = '200';\n  }\n  else if(responses['201']) {\n    response = responses['201'];\n    defaultResponseCode = '201';\n  }\n  else if(responses['202']) {\n    response = responses['202'];\n    defaultResponseCode = '202';\n  }\n  else if(responses['203']) {\n    response = responses['203'];\n    defaultResponseCode = '203';\n  }\n  else if(responses['204']) {\n    response = responses['204'];\n    defaultResponseCode = '204';\n  }\n  else if(responses['205']) {\n    response = responses['205'];\n    defaultResponseCode = '205';\n  }\n  else if(responses['206']) {\n    response = responses['206'];\n    defaultResponseCode = '206';\n  }\n  else if(responses['default']) {\n    response = responses['default'];\n    defaultResponseCode = 'default';\n  }\n\n  if(response && response.schema) {\n    var resolvedModel = this.resolveModel(response.schema, definitions);\n    if(resolvedModel) {\n      this.type = resolvedModel.name;\n      this.responseSampleJSON = JSON.stringify(resolvedModel.getSampleValue(), null, 2);\n      this.responseClassSignature = resolvedModel.getMockSignature();\n      delete responses[defaultResponseCode];\n    }\n    else {\n      this.type = response.schema.type;\n    }\n  }\n\n  if (errors.length > 0)\n    this.resource.api.fail(errors);\n\n  return this;\n}\n\nOperationGroup.prototype.sort = function(sorter) {\n\n}\n\nOperation.prototype.getType = function (param) {\n  var type = param.type;\n  var format = param.format;\n  var isArray = false;\n  var str;\n  if(type === 'integer' && format === 'int32')\n    str = 'integer';\n  else if(type === 'integer' && format === 'int64')\n    str = 'long';\n  else if(type === 'integer' && typeof format === 'undefined')\n    str = 'long';\n  else if(type === 'string' && format === 'date-time')\n    str = 'date-time';\n  else if(type === 'string' && format === 'date')\n    str = 'date';\n  else if(type === 'number' && format === 'float')\n    str = 'float';\n  else if(type === 'number' && format === 'double')\n    str = 'double';\n  else if(type === 'number' && typeof format === 'undefined')\n    str = 'double';\n  else if(type === 'boolean')\n    str = 'boolean';\n  else if(type === 'string')\n    str = 'string';\n  else if(type === 'array') {\n    isArray = true;\n    if(param.items)\n      str = this.getType(param.items);\n  }\n  if(param['$ref'])\n    str = param['$ref'];\n\n  var schema = param.schema;\n  if(schema) {\n    var ref = schema['$ref'];\n    if(ref) {\n      ref = simpleRef(ref);\n      if(isArray)\n        return [ ref ];\n      else\n        return ref;\n    }\n    else\n      return this.getType(schema);\n  }\n  if(isArray)\n    return [ str ];\n  else\n    return str;\n}\n\nOperation.prototype.resolveModel = function (schema, definitions) {\n  if(typeof schema['$ref'] !== 'undefined') {\n    var ref = schema['$ref'];\n    if(ref.indexOf('#/definitions/') == 0)\n      ref = ref.substring('#/definitions/'.length);\n    if(definitions[ref])\n      return new Model(ref, definitions[ref]);\n  }\n  if(schema.type === 'array')\n    return new ArrayModel(schema);\n  else\n    return null;\n}\n\nOperation.prototype.help = function() {\n  log(this.nickname + ': ' + this.operation.summary);\n  for(var i = 0; i < this.parameters.length; i++) {\n    var param = this.parameters[i];\n    log('  * ' + param.name + ': ' + param.description);\n  }\n}\n\nOperation.prototype.getSignature = function(type, models) {\n  var isPrimitive, listType;\n\n  if(type instanceof Array) {\n    listType = true;\n    type = type[0];\n  }\n\n  if(type === 'string')\n    isPrimitive = true\n  else\n    isPrimitive = ((listType != null) && models[listType]) || (models[type] != null) ? false : true;\n  if (isPrimitive) {\n    return type;\n  } else {\n    if (listType != null)\n      return models[type].getMockSignature();\n    else\n      return models[type].getMockSignature();\n  }\n};\n\n/**\n * gets sample response for a single operation\n **/\nOperation.prototype.getSampleJSON = function(type, models) {\n  var isPrimitive, listType, sampleJson;\n\n  listType = (type instanceof Array);\n  isPrimitive = (models[type] != null) ? false : true;\n  sampleJson = isPrimitive ? void 0 : models[type].createJSONSample();\n\n  if (sampleJson) {\n    sampleJson = listType ? [sampleJson] : sampleJson;\n    if(typeof sampleJson == 'string')\n      return sampleJson;\n    else if(typeof sampleJson === 'object') {\n      var t = sampleJson;\n      if(sampleJson instanceof Array && sampleJson.length > 0) {\n        t = sampleJson[0];\n      }\n      if(t.nodeName) {\n        var xmlString = new XMLSerializer().serializeToString(t);\n        return this.formatXml(xmlString);\n      }\n      else\n        return JSON.stringify(sampleJson, null, 2);\n    }\n    else\n      return sampleJson;\n  }\n};\n\n/**\n * legacy binding\n **/\nOperation.prototype[\"do\"] = function(args, opts, callback, error, parent) {\n  return this.execute(args, opts, callback, error, parent);\n}\n\n/**\n * executes an operation\n **/\nOperation.prototype.execute = function(arg1, arg2, arg3, arg4, parent) {\n  var args = (arg1||{});\n  var opts = {}, success, error;\n  if(typeof arg2 === 'object') {\n    opts = arg2;\n    success = arg3;\n    error = arg4;\n  }\n  if(typeof arg2 === 'function') {\n    success = arg2;\n    error = arg3;\n  }\n\n  var formParams = {};\n  var headers = {};\n  var requestUrl = this.path;\n\n  success = (success||log)\n  error = (error||log)\n\n  var requiredParams = [];\n  var missingParams = [];\n  // check required params, track the ones that are missing\n  var i;\n  for(i = 0; i < this.parameters.length; i++) {\n    var param = this.parameters[i];\n    if(param.required === true) {\n      requiredParams.push(param.name);\n      if(typeof args[param.name] === 'undefined')\n        missingParams = param.name;\n    }\n  }\n\n  if(missingParams.length > 0) {\n    var message = 'missing required params: ' + missingParams;\n    fail(message);\n    return;\n  }\n\n  // set content type negotiation\n  var consumes = this.consumes || this.parent.consumes || [ 'application/json' ];\n  var produces = this.produces || this.parent.produces || [ 'application/json' ];\n\n  headers = this.setContentTypes(args, opts);\n\n  // grab params from the args, build the querystring along the way\n  var querystring = \"\";\n  for(var i = 0; i < this.parameters.length; i++) {\n    var param = this.parameters[i];\n    if(typeof args[param.name] !== 'undefined') {\n      if(param.in === 'path') {\n        var reg = new RegExp('\\{' + param.name + '[^\\}]*\\}', 'gi');\n        requestUrl = requestUrl.replace(reg, this.encodePathParam(args[param.name]));\n      }\n      else if (param.in === 'query') {\n        if(querystring === '')\n          querystring += '?';\n        else\n          querystring += '&';\n        if(typeof param.collectionFormat !== 'undefined') {\n          var qp = args[param.name];\n          if(Array.isArray(qp))\n            querystring += this.encodeCollection(param.collectionFormat, param.name, qp);\n          else\n            querystring += this.encodeQueryParam(param.name) + '=' + this.encodeQueryParam(args[param.name]);\n        }\n        else\n          querystring += this.encodeQueryParam(param.name) + '=' + this.encodeQueryParam(args[param.name]);\n      }\n      else if (param.in === 'header')\n        headers[param.name] = args[param.name];\n      else if (param.in === 'formData')\n        formParams[param.name] = args[param.name];\n      else if (param.in === 'body')\n        args.body = args[param.name];\n    }\n  }\n  // handle form params\n  if(headers['Content-Type'] === 'application/x-www-form-urlencoded') {\n    var encoded = \"\";\n    var key;\n    for(key in formParams) {\n      value = formParams[key];\n      if(typeof value !== 'undefined'){\n        if(encoded !== \"\")\n          encoded += \"&\";\n        encoded += encodeURIComponent(key) + '=' + encodeURIComponent(value);\n      }\n    }\n    // todo append?\n    args.body = encoded;\n  }\n  var url = this.scheme + '://' + this.host + this.basePath + requestUrl + querystring;\n\n  var obj = {\n    url: url,\n    method: this.method,\n    body: args.body,\n    useJQuery: this.useJQuery,\n    headers: headers,\n    on: {\n      response: function(response) {\n        return success(response, parent);\n      },\n      error: function(response) {\n        return error(response, parent);\n      }\n    }\n  };\n  var status = e.authorizations.apply(obj, this.operation.security);\n  new SwaggerHttp().execute(obj);\n}\n\nOperation.prototype.setContentTypes = function(args, opts) {\n  // default type\n  var accepts = 'application/json';\n  var consumes = 'application/json';\n\n  var allDefinedParams = this.parameters;\n  var definedFormParams = [];\n  var definedFileParams = [];\n  var body = args.body;\n  var headers = {};\n\n  // get params from the operation and set them in definedFileParams, definedFormParams, headers\n  var i;\n  for(i = 0; i < allDefinedParams.length; i++) {\n    var param = allDefinedParams[i];\n    if(param.in === 'formData')\n      definedFormParams.push(param);\n    else if(param.in === 'file')\n      definedFileParams.push(param);\n    else if(param.in === 'header' && this.headers) {\n      var key = param.name;\n      var headerValue = this.headers[param.name];\n      if(typeof this.headers[param.name] !== 'undefined')\n        headers[key] = headerValue;\n    }\n  }\n\n  // if there's a body, need to set the accepts header via requestContentType\n  if (body && (this.type === 'post' || this.type === 'put' || this.type === 'patch' || this.type === 'delete')) {\n    if (opts.requestContentType)\n      consumes = opts.requestContentType;\n  } else {\n    // if any form params, content type must be set\n    if(definedFormParams.length > 0) {\n      if(definedFileParams.length > 0)\n        consumes = 'multipart/form-data';\n      else\n        consumes = 'application/x-www-form-urlencoded';\n    }\n    else if (this.type == 'DELETE')\n      body = '{}';\n    else if (this.type != 'DELETE')\n      accepts = null;\n  }\n\n  if (consumes && this.consumes) {\n    if (this.consumes.indexOf(consumes) === -1) {\n      log('server doesn\\'t consume ' + consumes + ', try ' + JSON.stringify(this.consumes));\n      consumes = this.operation.consumes[0];\n    }\n  }\n\n  if (opts.responseContentType) {\n    accepts = opts.responseContentType;\n  } else {\n    accepts = 'application/json';\n  }\n  if (accepts && this.produces) {\n    if (this.produces.indexOf(accepts) === -1) {\n      log('server can\\'t produce ' + accepts);\n      accepts = this.produces[0];\n    }\n  }\n\n  if ((consumes && body !== '') || (consumes === 'application/x-www-form-urlencoded'))\n    headers['Content-Type'] = consumes;\n  if (accepts)\n    headers['Accept'] = accepts;\n  return headers;\n}\n\nOperation.prototype.encodeCollection = function(type, name, value) {\n  var encoded = '';\n  var i;\n  if(type === 'default' || type === 'multi') {\n    for(i = 0; i < value.length; i++) {\n      if(i > 0) encoded += '&'\n      encoded += this.encodeQueryParam(name) + '=' + this.encodeQueryParam(value[i]);\n    }\n  }\n  else {\n    var separator = '';\n    if(type === 'csv')\n      separator = ',';\n    else if(type === 'ssv')\n      separator = '%20';\n    else if(type === 'tsv')\n      separator = '\\\\t';\n    else if(type === 'pipes')\n      separator = '|';\n    if(separator !== '') {\n      for(i = 0; i < value.length; i++) {\n        if(i == 0)\n          encoded = this.encodeQueryParam(name) + '=' + this.encodeQueryParam(value[i]);\n        else\n          encoded += separator + this.encodeQueryParam(value[i]);\n      }\n    }\n  }\n  // TODO: support the different encoding schemes here\n  return encoded;\n}\n\n/**\n * TODO this encoding needs to be changed \n **/\nOperation.prototype.encodeQueryParam = function(arg) {\n  return escape(arg);\n}\n\n/**\n * TODO revisit, might not want to leave '/'\n **/\nOperation.prototype.encodePathParam = function(pathParam) {\n  var encParts, part, parts, _i, _len;\n  pathParam = pathParam.toString();\n  if (pathParam.indexOf('/') === -1) {\n    return encodeURIComponent(pathParam);\n  } else {\n    parts = pathParam.split('/');\n    encParts = [];\n    for (_i = 0, _len = parts.length; _i < _len; _i++) {\n      part = parts[_i];\n      encParts.push(encodeURIComponent(part));\n    }\n    return encParts.join('/');\n  }\n};\n\nvar Model = function(name, definition) {\n  this.name = name;\n  this.definition = definition || {};\n  this.properties = [];\n  var requiredFields = definition.required || [];\n\n  var key;\n  var props = definition.properties;\n  if(props) {\n    for(key in props) {\n      var required = false;\n      var property = props[key];\n      if(requiredFields.indexOf(key) >= 0)\n        required = true;\n      this.properties.push(new Property(key, property, required));\n    }    \n  }\n}\n\nModel.prototype.createJSONSample = function(modelsToIgnore) {\n  var result = {};\n  modelsToIgnore = (modelsToIgnore||{})\n  modelsToIgnore[this.name] = this;\n  var i;\n  for (i = 0; i < this.properties.length; i++) {\n    prop = this.properties[i];\n    result[prop.name] = prop.getSampleValue(modelsToIgnore);\n  }\n  delete modelsToIgnore[this.name];\n  return result;\n};\n\nModel.prototype.getSampleValue = function(modelsToIgnore) {\n  var i;\n  var obj = {};\n  for(i = 0; i < this.properties.length; i++ ) {\n    var property = this.properties[i];\n    obj[property.name] = property.sampleValue(false, modelsToIgnore);\n  }\n  return obj;\n}\n\nModel.prototype.getMockSignature = function(modelsToIgnore) {\n  var propertiesStr = [];\n  var i;\n  for (i = 0; i < this.properties.length; i++) {\n    var prop = this.properties[i];\n    propertiesStr.push(prop.toString());\n  }\n\n  var strong = '<span class=\"strong\">';\n  var stronger = '<span class=\"stronger\">';\n  var strongClose = '</span>';\n  var classOpen = strong + this.name + ' {' + strongClose;\n  var classClose = strong + '}' + strongClose;\n  var returnVal = classOpen + '<div>' + propertiesStr.join(',</div><div>') + '</div>' + classClose;\n  if (!modelsToIgnore)\n    modelsToIgnore = {};\n\n  modelsToIgnore[this.name] = this;\n  var i;\n  for (i = 0; i < this.properties.length; i++) {\n    var prop = this.properties[i];\n    var ref = prop['$ref'];\n    var model = models[ref];\n    if (model && typeof modelsToIgnore[model.name] === 'undefined') {\n      returnVal = returnVal + ('<br>' + model.getMockSignature(modelsToIgnore));\n    }\n  }\n  return returnVal;\n};\n\nvar Property = function(name, obj, required) {\n  this.schema = obj;\n  this.required = required;\n  if(obj['$ref']) {\n    var refType = obj['$ref'];\n    refType = refType.indexOf('#/definitions') === -1 ? refType : refType.substring('#/definitions').length;\n    this['$ref'] = refType;\n  }\n  else if (obj.type === 'array') {\n    if(obj.items['$ref'])\n      this['$ref'] = obj.items['$ref'];\n    else\n      obj = obj.items;\n  }\n  this.name = name;\n  this.description = obj.description;\n  this.obj = obj;\n  this.optional = true;\n  this.default = obj.default || null;\n  this.example = obj.example || null;\n}\n\nProperty.prototype.getSampleValue = function (modelsToIgnore) {\n  return this.sampleValue(false, modelsToIgnore);\n}\n\nProperty.prototype.isArray = function () {\n  var schema = this.schema;\n  if(schema.type === 'array')\n    return true;\n  else\n    return false;\n}\n\nProperty.prototype.sampleValue = function(isArray, ignoredModels) {\n  isArray = (isArray || this.isArray());\n  ignoredModels = (ignoredModels || {});\n  var type = getStringSignature(this.obj);\n  var output;\n\n  if(this['$ref']) {\n    var refModel = models[this['$ref']];\n    if(refModel && typeof ignoredModels[type] === 'undefined') {\n      ignoredModels[type] = this;\n      output = refModel.getSampleValue(ignoredModels);\n    }\n    else\n      type = refModel;\n  }\n  else if(this.example)\n    output = this.example;\n  else if(this.default)\n    output = this.default;\n  else if(type === 'date-time')\n    output = new Date().toISOString();\n  else if(type === 'string')\n    output = 'string';\n  else if(type === 'integer')\n    output = 0;\n  else if(type === 'long')\n    output = 0;\n  else if(type === 'float')\n    output = 0.0;\n  else if(type === 'double')\n    output = 0.0;\n  else if(type === 'boolean')\n    output = true;\n  else\n    output = {};\n  ignoredModels[type] = output;\n  if(isArray)\n    return [output];\n  else\n    return output;\n}\n\ngetStringSignature = function(obj) {\n  var str = '';\n  if(obj.type === 'array') {\n    obj = (obj.items || obj['$ref'] || {});\n    str += 'Array[';\n  }\n  if(obj.type === 'integer' && obj.format === 'int32')\n    str += 'integer';\n  else if(obj.type === 'integer' && obj.format === 'int64')\n    str += 'long';\n  else if(obj.type === 'integer' && typeof obj.format === 'undefined')\n    str += 'long';\n  else if(obj.type === 'string' && obj.format === 'date-time')\n    str += 'date-time';\n  else if(obj.type === 'string' && obj.format === 'date')\n    str += 'date';\n  else if(obj.type === 'number' && obj.format === 'float')\n    str += 'float';\n  else if(obj.type === 'number' && obj.format === 'double')\n    str += 'double';\n  else if(obj.type === 'number' && typeof obj.format === 'undefined')\n    str += 'double';\n  else if(obj.type === 'boolean')\n    str += 'boolean';\n  else\n    str += obj.type || obj['$ref'];\n  if(obj.type === 'array')\n    str += ']';\n  return str;\n}\n\nsimpleRef = function(name) {\n  if(name.indexOf(\"#/definitions/\") === 0)\n    return name.substring('#/definitions/'.length)\n  else\n    return name;\n}\n\nProperty.prototype.toString = function() {\n  var str = getStringSignature(this.obj);\n  if(str !== '') {\n    str = '<span class=\"propName ' + this.required + '\">' + this.name + '</span> (<span class=\"propType\">' + str + '</span>';\n    if(!this.required)\n      str += ', <span class=\"propOptKey\">optional</span>';\n    str += ')';\n  }\n  else \n    str = this.name + ' (' + JSON.stringify(this.obj) + ')';\n\n  if(typeof this.description !== 'undefined')\n    str += ': ' + this.description;\n  return str;\n}\n\ntypeFromJsonSchema = function(type, format) {\n  var str;\n  if(type === 'integer' && format === 'int32')\n    str = 'integer';\n  else if(type === 'integer' && format === 'int64')\n    str = 'long';\n  else if(type === 'integer' && typeof format === 'undefined')\n    str = 'long';\n  else if(type === 'string' && format === 'date-time')\n    str = 'date-time';\n  else if(type === 'string' && format === 'date')\n    str = 'date';\n  else if(type === 'number' && format === 'float')\n    str = 'float';\n  else if(type === 'number' && format === 'double')\n    str = 'double';\n  else if(type === 'number' && typeof format === 'undefined')\n    str = 'double';\n  else if(type === 'boolean')\n    str = 'boolean';\n  else if(type === 'string')\n    str = 'string';\n\n  return str;\n}\n\nvar e = (typeof window !== 'undefined' ? window : exports);\n\nvar sampleModels = {};\nvar cookies = {};\nvar models = {};\n\ne.authorizations = new SwaggerAuthorizations();\ne.ApiKeyAuthorization = ApiKeyAuthorization;\ne.PasswordAuthorization = PasswordAuthorization;\ne.CookieAuthorization = CookieAuthorization;\ne.SwaggerClient = SwaggerClient;\n\n/**\n * SwaggerHttp is a wrapper for executing requests\n */\nvar SwaggerHttp = function() {};\n\nSwaggerHttp.prototype.execute = function(obj) {\n  if(obj && (typeof obj.useJQuery === 'boolean'))\n    this.useJQuery = obj.useJQuery;\n  else\n    this.useJQuery = this.isIE8();\n\n  if(this.useJQuery)\n    return new JQueryHttpClient().execute(obj);\n  else\n    return new ShredHttpClient().execute(obj);\n}\n\nSwaggerHttp.prototype.isIE8 = function() {\n  var detectedIE = false;\n  if (typeof navigator !== 'undefined' && navigator.userAgent) {\n    nav = navigator.userAgent.toLowerCase();\n    if (nav.indexOf('msie') !== -1) {\n      var version = parseInt(nav.split('msie')[1]);\n      if (version <= 8) {\n        detectedIE = true;\n      }\n    }\n  }\n  return detectedIE;\n};\n\n/*\n * JQueryHttpClient lets a browser take advantage of JQuery's cross-browser magic.\n * NOTE: when jQuery is available it will export both '$' and 'jQuery' to the global space.\n *       Since we are using closures here we need to alias it for internal use.\n */\nvar JQueryHttpClient = function(options) {\n  \"use strict\";\n  if(!jQuery){\n    var jQuery = window.jQuery;\n  }\n}\n\nJQueryHttpClient.prototype.execute = function(obj) {\n  var cb = obj.on;\n  var request = obj;\n\n  obj.type = obj.method;\n  obj.cache = false;\n\n  obj.beforeSend = function(xhr) {\n    var key, results;\n    if (obj.headers) {\n      results = [];\n      var key;\n      for (key in obj.headers) {\n        if (key.toLowerCase() === \"content-type\") {\n          results.push(obj.contentType = obj.headers[key]);\n        } else if (key.toLowerCase() === \"accept\") {\n          results.push(obj.accepts = obj.headers[key]);\n        } else {\n          results.push(xhr.setRequestHeader(key, obj.headers[key]));\n        }\n      }\n      return results;\n    }\n  };\n\n  obj.data = obj.body;\n  obj.complete = function(response, textStatus, opts) {\n    var headers = {},\n        headerArray = response.getAllResponseHeaders().split(\"\\n\");\n\n    for(var i = 0; i < headerArray.length; i++) {\n      var toSplit = headerArray[i].trim();\n      if(toSplit.length === 0)\n        continue;\n      var separator = toSplit.indexOf(\":\");\n      if(separator === -1) {\n        // Name but no value in the header\n        headers[toSplit] = null;\n        continue;\n      }\n      var name = toSplit.substring(0, separator).trim(),\n          value = toSplit.substring(separator + 1).trim();\n      headers[name] = value;\n    }\n\n    var out = {\n      url: request.url,\n      method: request.method,\n      status: response.status,\n      data: response.responseText,\n      headers: headers\n    };\n\n    var contentType = (headers[\"content-type\"]||headers[\"Content-Type\"]||null)\n\n    if(contentType != null) {\n      if(contentType.indexOf(\"application/json\") == 0 || contentType.indexOf(\"+json\") > 0) {\n        if(response.responseText && response.responseText !== \"\")\n          out.obj = JSON.parse(response.responseText);\n        else\n          out.obj = {}\n      }\n    }\n\n    if(response.status >= 200 && response.status < 300)\n      cb.response(out);\n    else if(response.status === 0 || (response.status >= 400 && response.status < 599))\n      cb.error(out);\n    else\n      return cb.response(out);\n  };\n\n  jQuery.support.cors = true;\n  return jQuery.ajax(obj);\n}\n\n/*\n * ShredHttpClient is a light-weight, node or browser HTTP client\n */\nvar ShredHttpClient = function(options) {\n  this.options = (options||{});\n  this.isInitialized = false;\n\n  var identity, toString;\n\n  if (typeof window !== 'undefined') {\n    this.Shred = require(\"./shred\");\n    this.content = require(\"./shred/content\");\n  }\n  else\n    this.Shred = require(\"shred\");\n  this.shred = new this.Shred(options);\n}\n\nShredHttpClient.prototype.initShred = function () {\n  this.isInitialized = true;\n  this.registerProcessors(this.shred);\n}\n\nShredHttpClient.prototype.registerProcessors = function(shred) {\n  var identity = function(x) {\n    return x;\n  };\n  var toString = function(x) {\n    return x.toString();\n  };\n\n  if (typeof window !== 'undefined') {\n    this.content.registerProcessor([\"application/json; charset=utf-8\", \"application/json\", \"json\"], {\n      parser: identity,\n      stringify: toString\n    });\n  } else {\n    this.Shred.registerProcessor([\"application/json; charset=utf-8\", \"application/json\", \"json\"], {\n      parser: identity,\n      stringify: toString\n    });\n  }\n}\n\nShredHttpClient.prototype.execute = function(obj) {\n  if(!this.isInitialized)\n    this.initShred();\n\n  var cb = obj.on, res;\n\n  var transform = function(response) {\n    var out = {\n      headers: response._headers,\n      url: response.request.url,\n      method: response.request.method,\n      status: response.status,\n      data: response.content.data\n    };\n\n    var contentType = (response._headers[\"content-type\"]||response._headers[\"Content-Type\"]||null)\n\n    if(contentType != null) {\n      if(contentType.indexOf(\"application/json\") == 0 || contentType.indexOf(\"+json\") > 0) {\n        if(response.content.data && response.content.data !== \"\")\n          try{\n            out.obj = JSON.parse(response.content.data);\n          }\n          catch (e) {\n            // unable to parse\n          }\n        else\n          out.obj = {}\n      }\n    }\n    return out;\n  };\n\n  res = {\n    error: function(response) {\n      if (obj)\n        return cb.error(transform(response));\n    },\n    redirect: function(response) {\n      if (obj)\n        return cb.redirect(transform(response));\n    },\n    307: function(response) {\n      if (obj)\n        return cb.redirect(transform(response));\n    },\n    response: function(response) {\n      if (obj)\n        return cb.response(transform(response));\n    }\n  };\n  if (obj) {\n    obj.on = res;\n  }\n  return this.shred.request(obj);\n};","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/swagger-ui/lib/swagger-oauth.js":"var appName;\nvar popupMask;\nvar popupDialog;\nvar clientId;\nvar realm;\n\nfunction handleLogin() {\n  var scopes = [];\n\n  var auths = window.swaggerUi.api.authSchemes || window.swaggerUi.api.securityDefinitions;\n  if(auths) {\n    var key;\n    var defs = auths;\n    for(key in defs) {\n      log(key);\n      var auth = defs[key];\n      if(auth.type === 'oauth2' && auth.scopes) {\n        var scope;\n        if(Array.isArray(auth.scopes)) {\n          // 1.2 support\n          var i;\n          for(i = 0; i < auth.scopes.length; i++) {\n            scopes.push(auth.scopes[i]);\n          }\n        }\n        else {\n          // 2.0 support\n          for(scope in auth.scopes) {\n            scopes.push({scope: scope, description: auth.scopes[scope]});\n          }\n        }\n      }\n    }\n  }\n\n  if(window.swaggerUi.api\n    && window.swaggerUi.api.info) {\n    appName = window.swaggerUi.api.info.title;\n  }\n\n  if(popupDialog.length > 0)\n    popupDialog = popupDialog.last();\n  else {\n    popupDialog = $(\n      [\n        '<div class=\"api-popup-dialog\">',\n        '<div class=\"api-popup-title\">Select OAuth2.0 Scopes</div>',\n        '<div class=\"api-popup-content\">',\n          '<p>Scopes are used to grant an application different levels of access to data on behalf of the end user. Each API may declare one or more scopes.',\n            '<a href=\"#\">Learn how to use</a>',\n          '</p>',\n          '<p><strong>' + appName + '</strong> API requires the following scopes. Select which ones you want to grant to Swagger UI.</p>',\n          '<ul class=\"api-popup-scopes\">',\n          '</ul>',\n          '<p class=\"error-msg\"></p>',\n          '<div class=\"api-popup-actions\"><button class=\"api-popup-authbtn api-button green\" type=\"button\">Authorize</button><button class=\"api-popup-cancel api-button gray\" type=\"button\">Cancel</button></div>',\n        '</div>',\n        '</div>'].join(''));\n    $(document.body).append(popupDialog);\n\n    popup = popupDialog.find('ul.api-popup-scopes').empty();\n    for (i = 0; i < scopes.length; i ++) {\n      scope = scopes[i];\n      str = '<li><input type=\"checkbox\" id=\"scope_' + i + '\" scope=\"' + scope.scope + '\"/>' + '<label for=\"scope_' + i + '\">' + scope.scope;\n      if (scope.description) {\n        str += '<br/><span class=\"api-scope-desc\">' + scope.description + '</span>';\n      }\n      str += '</label></li>';\n      popup.append(str);\n    }\n  }\n\n  var $win = $(window),\n    dw = $win.width(),\n    dh = $win.height(),\n    st = $win.scrollTop(),\n    dlgWd = popupDialog.outerWidth(),\n    dlgHt = popupDialog.outerHeight(),\n    top = (dh -dlgHt)/2 + st,\n    left = (dw - dlgWd)/2;\n\n  popupDialog.css({\n    top: (top < 0? 0 : top) + 'px',\n    left: (left < 0? 0 : left) + 'px'\n  });\n\n  popupDialog.find('button.api-popup-cancel').click(function() {\n    popupMask.hide();\n    popupDialog.hide();\n  });\n  popupDialog.find('button.api-popup-authbtn').click(function() {\n    popupMask.hide();\n    popupDialog.hide();\n\n    var authSchemes = window.swaggerUi.api.authSchemes;\n    var host = window.location;\n    var pathname = location.pathname.substring(0, location.pathname.lastIndexOf(\"/\"));\n    var redirectUrl = host.protocol + '//' + host.host + pathname + \"/o2c.html\";\n    var url = null;\n\n    for (var key in authSchemes) {\n      if (authSchemes.hasOwnProperty(key)) {\n        if(authSchemes[key].type === 'oauth2' && authSchemes[key].flow === 'implicit') {\n          var dets = authSchemes[key];\n          url = dets.tokenUrl + \"?response_type=token\";\n          window.swaggerUi.tokenName = dets.tokenName || \"access_token\";          \n        }\n        else if(authSchemes[key].grantTypes) {\n          // 1.2 support\n          var o = authSchemes[key].grantTypes;\n          for(var t in o) {\n            if(o.hasOwnProperty(t) && t === 'implicit') {\n              var dets = o[t];\n              var ep = dets.loginEndpoint.url;\n              url = dets.loginEndpoint.url + \"?response_type=token\";\n              window.swaggerUi.tokenName = dets.tokenName;\n            }\n          }\n        }\n      }\n    }\n    var scopes = []\n    var o = $('.api-popup-scopes').find('input:checked');\n\n    for(k =0; k < o.length; k++) {\n      scopes.push($(o[k]).attr(\"scope\"));\n    }\n\n    window.enabledScopes=scopes;\n\n    url += '&redirect_uri=' + encodeURIComponent(redirectUrl);\n    url += '&realm=' + encodeURIComponent(realm);\n    url += '&client_id=' + encodeURIComponent(clientId);\n    url += '&scope=' + encodeURIComponent(scopes);\n\n    window.open(url);\n  });\n\n  popupMask.show();\n  popupDialog.show();\n  return;\n}\n\n\nfunction handleLogout() {\n  for(key in window.authorizations.authz){\n    window.authorizations.remove(key)\n  }\n  window.enabledScopes = null;\n  $('.api-ic.ic-on').addClass('ic-off');\n  $('.api-ic.ic-on').removeClass('ic-on');\n\n  // set the info box\n  $('.api-ic.ic-warning').addClass('ic-error');\n  $('.api-ic.ic-warning').removeClass('ic-warning');\n}\n\nfunction initOAuth(opts) {\n  var o = (opts||{});\n  var errors = [];\n\n  appName = (o.appName||errors.push(\"missing appName\"));\n  popupMask = (o.popupMask||$('#api-common-mask'));\n  popupDialog = (o.popupDialog||$('.api-popup-dialog'));\n  clientId = (o.clientId||errors.push(\"missing client id\"));\n  realm = (o.realm||errors.push(\"missing realm\"));\n\n  if(errors.length > 0){\n    log(\"auth unable initialize oauth: \" + errors);\n    return;\n  }\n\n  $('pre code').each(function(i, e) {hljs.highlightBlock(e)});\n  $('.api-ic').click(function(s) {\n    if($(s.target).hasClass('ic-off'))\n      handleLogin();\n    else {\n      handleLogout();\n    }\n    false;\n  });\n}\n\nfunction onOAuthComplete(token) {\n  if(token) {\n    if(token.error) {\n      var checkbox = $('input[type=checkbox],.secured')\n      checkbox.each(function(pos){\n        checkbox[pos].checked = false;\n      });\n      alert(token.error);\n    }\n    else {\n      var b = token[window.swaggerUi.tokenName];\n      if(b){\n        // if all roles are satisfied\n        var o = null;\n        $.each($('.auth #api_information_panel'), function(k, v) {\n          var children = v;\n          if(children && children.childNodes) {\n            var requiredScopes = [];\n            $.each((children.childNodes), function (k1, v1){\n              var inner = v1.innerHTML;\n              if(inner)\n                requiredScopes.push(inner);\n            });\n            var diff = [];\n            for(var i=0; i < requiredScopes.length; i++) {\n              var s = requiredScopes[i];\n              if(window.enabledScopes && window.enabledScopes.indexOf(s) == -1) {\n                diff.push(s);\n              }\n            }\n            if(diff.length > 0){\n              o = v.parentNode;\n              $(o.parentNode).find('.api-ic.ic-on').addClass('ic-off');\n              $(o.parentNode).find('.api-ic.ic-on').removeClass('ic-on');\n\n              // sorry, not all scopes are satisfied\n              $(o).find('.api-ic').addClass('ic-warning');\n              $(o).find('.api-ic').removeClass('ic-error');\n            }\n            else {\n              o = v.parentNode;\n              $(o.parentNode).find('.api-ic.ic-off').addClass('ic-on');\n              $(o.parentNode).find('.api-ic.ic-off').removeClass('ic-off');\n\n              // all scopes are satisfied\n              $(o).find('.api-ic').addClass('ic-info');\n              $(o).find('.api-ic').removeClass('ic-warning');\n              $(o).find('.api-ic').removeClass('ic-error');          \n            }\n          }\n        });\n        window.authorizations.add(\"oauth2\", new ApiKeyAuthorization(\"Authorization\", \"Bearer \" + b, \"header\"));\n      }\n    }\n  }\n}","/home/travis/build/npmtest/node-npmtest-swagger-node-express/node_modules/swagger-node-express/swagger-ui/lib/shred/content.js":"\n// The purpose of the `Content` object is to abstract away the data conversions\n// to and from raw content entities as strings. For example, you want to be able\n// to pass in a Javascript object and have it be automatically converted into a\n// JSON string if the `content-type` is set to a JSON-based media type.\n// Conversely, you want to be able to transparently get back a Javascript object\n// in the response if the `content-type` is a JSON-based media-type.\n\n// One limitation of the current implementation is that it [assumes the `charset` is UTF-8](https://github.com/spire-io/shred/issues/5).\n\n// The `Content` constructor takes an options object, which *must* have either a\n// `body` or `data` property and *may* have a `type` property indicating the\n// media type. If there is no `type` attribute, a default will be inferred.\nvar Content = function(options) {\n  this.body = options.body;\n  this.data = options.data;\n  this.type = options.type;\n};\n\nContent.prototype = {\n  // Treat `toString()` as asking for the `content.body`. That is, the raw content entity.\n  //\n  //     toString: function() { return this.body; }\n  //\n  // Commented out, but I've forgotten why. :/\n};\n\n\n// `Content` objects have the following attributes:\nObject.defineProperties(Content.prototype,{\n  \n// - **type**. Typically accessed as `content.type`, reflects the `content-type`\n//   header associated with the request or response. If not passed as an options\n//   to the constructor or set explicitly, it will infer the type the `data`\n//   attribute, if possible, and, failing that, will default to `text/plain`.\n  type: {\n    get: function() {\n      if (this._type) {\n        return this._type;\n      } else {\n        if (this._data) {\n          switch(typeof this._data) {\n            case \"string\": return \"text/plain\";\n            case \"object\": return \"application/json\";\n          }\n        }\n      }\n      return \"text/plain\";\n    },\n    set: function(value) {\n      this._type = value;\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **data**. Typically accessed as `content.data`, reflects the content entity\n//   converted into Javascript data. This can be a string, if the `type` is, say,\n//   `text/plain`, but can also be a Javascript object. The conversion applied is\n//   based on the `processor` attribute. The `data` attribute can also be set\n//   directly, in which case the conversion will be done the other way, to infer\n//   the `body` attribute.\n  data: {\n    get: function() {\n      if (this._body) {\n        return this.processor.parser(this._body);\n      } else {\n        return this._data;\n      }\n    },\n    set: function(data) {\n      if (this._body&&data) Errors.setDataWithBody(this);\n      this._data = data;\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **body**. Typically accessed as `content.body`, reflects the content entity\n//   as a UTF-8 string. It is the mirror of the `data` attribute. If you set the\n//   `data` attribute, the `body` attribute will be inferred and vice-versa. If\n//   you attempt to set both, an exception is raised.\n  body: {\n    get: function() {\n      if (this._data) {\n        return this.processor.stringify(this._data);\n      } else {\n        return this._body.toString();\n      }\n    },\n    set: function(body) {\n      if (this._data&&body) Errors.setBodyWithData(this);\n      this._body = body;\n      return this;\n    },\n    enumerable: true\n  },\n\n// - **processor**. The functions that will be used to convert to/from `data` and\n//   `body` attributes. You can add processors. The two that are built-in are for\n//   `text/plain`, which is basically an identity transformation and\n//   `application/json` and other JSON-based media types (including custom media\n//   types with `+json`). You can add your own processors. See below.\n  processor: {\n    get: function() {\n      var processor = Content.processors[this.type];\n      if (processor) {\n        return processor;\n      } else {\n        // Return the first processor that matches any part of the\n        // content type. ex: application/vnd.foobar.baz+json will match json.\n        var main = this.type.split(\";\")[0];\n        var parts = main.split(/\\+|\\//);\n        for (var i=0, l=parts.length; i < l; i++) {\n          processor = Content.processors[parts[i]]\n        }\n        return processor || {parser:identity,stringify:toString};\n      }\n    },\n    enumerable: true\n  },\n\n// - **length**. Typically accessed as `content.length`, returns the length in\n//   bytes of the raw content entity.\n  length: {\n    get: function() {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(this.body);\n      }\n      return this.body.length;\n    }\n  }\n});\n\nContent.processors = {};\n\n// The `registerProcessor` function allows you to add your own processors to\n// convert content entities. Each processor consists of a Javascript object with\n// two properties:\n// - **parser**. The function used to parse a raw content entity and convert it\n//   into a Javascript data type.\n// - **stringify**. The function used to convert a Javascript data type into a\n//   raw content entity.\nContent.registerProcessor = function(types,processor) {\n  \n// You can pass an array of types that will trigger this processor, or just one.\n// We determine the array via duck-typing here.\n  if (types.forEach) {\n    types.forEach(function(type) {\n      Content.processors[type] = processor;\n    });\n  } else {\n    // If you didn't pass an array, we just use what you pass in.\n    Content.processors[types] = processor;\n  }\n};\n\n// Register the identity processor, which is used for text-based media types.\nvar identity = function(x) { return x; }\n  , toString = function(x) { return x.toString(); }\nContent.registerProcessor(\n  [\"text/html\",\"text/plain\",\"text\"],\n  { parser: identity, stringify: toString });\n\n// Register the JSON processor, which is used for JSON-based media types.\nContent.registerProcessor(\n  [\"application/json; charset=utf-8\",\"application/json\",\"json\"],\n  {\n    parser: function(string) {\n      return JSON.parse(string);\n    },\n    stringify: function(data) {\n      return JSON.stringify(data); }});\n\nvar qs = require('querystring');\n// Register the post processor, which is used for JSON-based media types.\nContent.registerProcessor(\n  [\"application/x-www-form-urlencoded\"],\n  { parser : qs.parse, stringify : qs.stringify });\n\n// Error functions are defined separately here in an attempt to make the code\n// easier to read.\nvar Errors = {\n  setDataWithBody: function(object) {\n    throw new Error(\"Attempt to set data attribute of a content object \" +\n        \"when the body attributes was already set.\");\n  },\n  setBodyWithData: function(object) {\n    throw new Error(\"Attempt to set body attribute of a content object \" +\n        \"when the data attributes was already set.\");\n  }\n}\nmodule.exports = Content;"}